(function(global) {

  var defined = {};

  // indexOf polyfill for IE8
  var indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++)
      if (this[i] === item)
        return i;
    return -1;
  }

  function dedupe(deps) {
    var newDeps = [];
    for (var i = 0, l = deps.length; i < l; i++)
      if (indexOf.call(newDeps, deps[i]) == -1)
        newDeps.push(deps[i])
    return newDeps;
  }

  function register(name, deps, declare, execute) {
    if (typeof name != 'string')
      throw "System.register provided no module name";

    var entry;

    // dynamic
    if (typeof declare == 'boolean') {
      entry = {
        declarative: false,
        deps: deps,
        execute: execute,
        executingRequire: declare
      };
    }
    else {
      // ES6 declarative
      entry = {
        declarative: true,
        deps: deps,
        declare: declare
      };
    }

    entry.name = name;

    // we never overwrite an existing define
    if (!(name in defined))
      defined[name] = entry; 

    entry.deps = dedupe(entry.deps);

    // we have to normalize dependencies
    // (assume dependencies are normalized for now)
    // entry.normalizedDeps = entry.deps.map(normalize);
    entry.normalizedDeps = entry.deps;
  }

  function buildGroups(entry, groups) {
    groups[entry.groupIndex] = groups[entry.groupIndex] || [];

    if (indexOf.call(groups[entry.groupIndex], entry) != -1)
      return;

    groups[entry.groupIndex].push(entry);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = defined[depName];

      // not in the registry means already linked / ES6
      if (!depEntry || depEntry.evaluated)
        continue;

      // now we know the entry is in our unlinked linkage group
      var depGroupIndex = entry.groupIndex + (depEntry.declarative != entry.declarative);

      // the group index of an entry is always the maximum
      if (depEntry.groupIndex === undefined || depEntry.groupIndex < depGroupIndex) {

        // if already in a group, remove from the old group
        if (depEntry.groupIndex !== undefined) {
          groups[depEntry.groupIndex].splice(indexOf.call(groups[depEntry.groupIndex], depEntry), 1);

          // if the old group is empty, then we have a mixed depndency cycle
          if (groups[depEntry.groupIndex].length == 0)
            throw new TypeError("Mixed dependency cycle detected");
        }

        depEntry.groupIndex = depGroupIndex;
      }

      buildGroups(depEntry, groups);
    }
  }

  function link(name) {
    var startEntry = defined[name];

    startEntry.groupIndex = 0;

    var groups = [];

    buildGroups(startEntry, groups);

    var curGroupDeclarative = !!startEntry.declarative == groups.length % 2;
    for (var i = groups.length - 1; i >= 0; i--) {
      var group = groups[i];
      for (var j = 0; j < group.length; j++) {
        var entry = group[j];

        // link each group
        if (curGroupDeclarative)
          linkDeclarativeModule(entry);
        else
          linkDynamicModule(entry);
      }
      curGroupDeclarative = !curGroupDeclarative; 
    }
  }

  // module binding records
  var moduleRecords = {};
  function getOrCreateModuleRecord(name) {
    return moduleRecords[name] || (moduleRecords[name] = {
      name: name,
      dependencies: [],
      exports: {}, // start from an empty module and extend
      importers: []
    })
  }

  function linkDeclarativeModule(entry) {
    // only link if already not already started linking (stops at circular)
    if (entry.module)
      return;

    var module = entry.module = getOrCreateModuleRecord(entry.name);
    var exports = entry.module.exports;

    var declaration = entry.declare.call(global, function(name, value) {
      module.locked = true;
      exports[name] = value;

      for (var i = 0, l = module.importers.length; i < l; i++) {
        var importerModule = module.importers[i];
        if (!importerModule.locked) {
          var importerIndex = indexOf.call(importerModule.dependencies, module);
          importerModule.setters[importerIndex](exports);
        }
      }

      module.locked = false;
      return value;
    });

    module.setters = declaration.setters;
    module.execute = declaration.execute;

    if (!module.setters || !module.execute)
      throw new TypeError("Invalid System.register form for " + entry.name);

    // now link all the module dependencies
    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = defined[depName];
      var depModule = moduleRecords[depName];

      // work out how to set depExports based on scenarios...
      var depExports;

      if (depModule) {
        depExports = depModule.exports;
      }
      else if (depEntry && !depEntry.declarative) {
        if (depEntry.module.exports && depEntry.module.exports.__esModule)
          depExports = depEntry.module.exports;
        else
          depExports = { 'default': depEntry.module.exports, __useDefault: true };
      }
      // in the module registry
      else if (!depEntry) {
        depExports = load(depName);
      }
      // we have an entry -> link
      else {
        linkDeclarativeModule(depEntry);
        depModule = depEntry.module;
        depExports = depModule.exports;
      }

      // only declarative modules have dynamic bindings
      if (depModule && depModule.importers) {
        depModule.importers.push(module);
        module.dependencies.push(depModule);
      }
      else
        module.dependencies.push(null);

      // run the setter for this dependency
      if (module.setters[i])
        module.setters[i](depExports);
    }
  }

  // An analog to loader.get covering execution of all three layers (real declarative, simulated declarative, simulated dynamic)
  function getModule(name) {
    var exports;
    var entry = defined[name];

    if (!entry) {
      exports = load(name);
      if (!exports)
        throw new Error("Unable to load dependency " + name + ".");
    }

    else {
      if (entry.declarative)
        ensureEvaluated(name, []);

      else if (!entry.evaluated)
        linkDynamicModule(entry);

      exports = entry.module.exports;
    }

    if ((!entry || entry.declarative) && exports && exports.__useDefault)
      return exports['default'];

    return exports;
  }

  function linkDynamicModule(entry) {
    if (entry.module)
      return;

    var exports = {};

    var module = entry.module = { exports: exports, id: entry.name };

    // AMD requires execute the tree first
    if (!entry.executingRequire) {
      for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
        var depName = entry.normalizedDeps[i];
        var depEntry = defined[depName];
        if (depEntry)
          linkDynamicModule(depEntry);
      }
    }

    // now execute
    entry.evaluated = true;
    var output = entry.execute.call(global, function(name) {
      for (var i = 0, l = entry.deps.length; i < l; i++) {
        if (entry.deps[i] != name)
          continue;
        return getModule(entry.normalizedDeps[i]);
      }
      throw new TypeError('Module ' + name + ' not declared as a dependency.');
    }, exports, module);

    if (output)
      module.exports = output;
  }

  /*
   * Given a module, and the list of modules for this current branch,
   *  ensure that each of the dependencies of this module is evaluated
   *  (unless one is a circular dependency already in the list of seen
   *  modules, in which case we execute it)
   *
   * Then we evaluate the module itself depth-first left to right 
   * execution to match ES6 modules
   */
  function ensureEvaluated(moduleName, seen) {
    var entry = defined[moduleName];

    // if already seen, that means it's an already-evaluated non circular dependency
    if (!entry || entry.evaluated || !entry.declarative)
      return;

    // this only applies to declarative modules which late-execute

    seen.push(moduleName);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      if (indexOf.call(seen, depName) == -1) {
        if (!defined[depName])
          load(depName);
        else
          ensureEvaluated(depName, seen);
      }
    }

    if (entry.evaluated)
      return;

    entry.evaluated = true;
    entry.module.execute.call(global);
  }

  // magical execution function
  var modules = {};
  function load(name) {
    if (modules[name])
      return modules[name];

    var entry = defined[name];

    // first we check if this module has already been defined in the registry
    if (!entry)
      throw "Module " + name + " not present.";

    // recursively ensure that the module and all its 
    // dependencies are linked (with dependency group handling)
    link(name);

    // now handle dependency execution in correct order
    ensureEvaluated(name, []);

    // remove from the registry
    defined[name] = undefined;

    var module = entry.module.exports;

    if (!module || !entry.declarative && module.__esModule !== true)
      module = { 'default': module, __useDefault: true };

    // return the defined module object
    return modules[name] = module;
  };

  return function(mains, declare) {

    var System;
    var System = {
      register: register, 
      get: load, 
      set: function(name, module) {
        modules[name] = module; 
      },
      newModule: function(module) {
        return module;
      },
      global: global 
    };
    System.set('@empty', {});

    declare(System);

    for (var i = 0; i < mains.length; i++)
      load(mains[i]);
  }

})(typeof window != 'undefined' ? window : global)
/* (['mainModule'], function(System) {
  System.register(...);
}); */

(['webapp/js/main'], function(System) {


System.register("github:driftyco/ionic-bower@1.1.0/js/ionic", [], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, []);
  (function() {
    "format global";
    (function() {
      window.ionic = window.ionic || {};
      window.ionic.views = {};
      window.ionic.version = '1.1.0';
      (function(ionic) {
        ionic.DelegateService = function(methodNames) {
          if (methodNames.indexOf('$getByHandle') > -1) {
            throw new Error("Method '$getByHandle' is implicitly added to each delegate service. Do not list it as a method.");
          }
          function trueFn() {
            return true;
          }
          return ['$log', function($log) {
            function DelegateInstance(instances, handle) {
              this._instances = instances;
              this.handle = handle;
            }
            methodNames.forEach(function(methodName) {
              DelegateInstance.prototype[methodName] = instanceMethodCaller(methodName);
            });
            function DelegateService() {
              this._instances = [];
            }
            DelegateService.prototype = DelegateInstance.prototype;
            DelegateService.prototype._registerInstance = function(instance, handle, filterFn) {
              var instances = this._instances;
              instance.$$delegateHandle = handle;
              instance.$$filterFn = filterFn || trueFn;
              instances.push(instance);
              return function deregister() {
                var index = instances.indexOf(instance);
                if (index !== -1) {
                  instances.splice(index, 1);
                }
              };
            };
            DelegateService.prototype.$getByHandle = function(handle) {
              return new DelegateInstance(this._instances, handle);
            };
            return new DelegateService();
            function instanceMethodCaller(methodName) {
              return function caller() {
                var handle = this.handle;
                var args = arguments;
                var foundInstancesCount = 0;
                var returnValue;
                this._instances.forEach(function(instance) {
                  if ((!handle || handle == instance.$$delegateHandle) && instance.$$filterFn(instance)) {
                    foundInstancesCount++;
                    var ret = instance[methodName].apply(instance, args);
                    if (foundInstancesCount === 1) {
                      returnValue = ret;
                    }
                  }
                });
                if (!foundInstancesCount && handle) {
                  return $log.warn('Delegate for handle "' + handle + '" could not find a ' + 'corresponding element with delegate-handle="' + handle + '"! ' + methodName + '() was not called!\n' + 'Possible cause: If you are calling ' + methodName + '() immediately, and ' + 'your element with delegate-handle="' + handle + '" is a child of your ' + 'controller, then your element may not be compiled yet. Put a $timeout ' + 'around your call to ' + methodName + '() and try again.');
                }
                return returnValue;
              };
            }
          }];
        };
      })(window.ionic);
      (function(window, document, ionic) {
        var readyCallbacks = [];
        var isDomReady = document.readyState === 'complete' || document.readyState === 'interactive';
        function domReady() {
          isDomReady = true;
          for (var x = 0; x < readyCallbacks.length; x++) {
            ionic.requestAnimationFrame(readyCallbacks[x]);
          }
          readyCallbacks = [];
          document.removeEventListener('DOMContentLoaded', domReady);
        }
        if (!isDomReady) {
          document.addEventListener('DOMContentLoaded', domReady);
        }
        window._rAF = (function() {
          return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
            window.setTimeout(callback, 16);
          };
        })();
        var cancelAnimationFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelRequestAnimationFrame;
        ionic.DomUtil = {
          requestAnimationFrame: function(cb) {
            return window._rAF(cb);
          },
          cancelAnimationFrame: function(requestId) {
            cancelAnimationFrame(requestId);
          },
          animationFrameThrottle: function(cb) {
            var args,
                isQueued,
                context;
            return function() {
              args = arguments;
              context = this;
              if (!isQueued) {
                isQueued = true;
                ionic.requestAnimationFrame(function() {
                  cb.apply(context, args);
                  isQueued = false;
                });
              }
            };
          },
          contains: function(parentNode, otherNode) {
            var current = otherNode;
            while (current) {
              if (current === parentNode)
                return true;
              current = current.parentNode;
            }
          },
          getPositionInParent: function(el) {
            return {
              left: el.offsetLeft,
              top: el.offsetTop
            };
          },
          ready: function(cb) {
            if (isDomReady) {
              ionic.requestAnimationFrame(cb);
            } else {
              readyCallbacks.push(cb);
            }
          },
          getTextBounds: function(textNode) {
            if (document.createRange) {
              var range = document.createRange();
              range.selectNodeContents(textNode);
              if (range.getBoundingClientRect) {
                var rect = range.getBoundingClientRect();
                if (rect) {
                  var sx = window.scrollX;
                  var sy = window.scrollY;
                  return {
                    top: rect.top + sy,
                    left: rect.left + sx,
                    right: rect.left + sx + rect.width,
                    bottom: rect.top + sy + rect.height,
                    width: rect.width,
                    height: rect.height
                  };
                }
              }
            }
            return null;
          },
          getChildIndex: function(element, type) {
            if (type) {
              var ch = element.parentNode.children;
              var c;
              for (var i = 0,
                  k = 0,
                  j = ch.length; i < j; i++) {
                c = ch[i];
                if (c.nodeName && c.nodeName.toLowerCase() == type) {
                  if (c == element) {
                    return k;
                  }
                  k++;
                }
              }
            }
            return Array.prototype.slice.call(element.parentNode.children).indexOf(element);
          },
          swapNodes: function(src, dest) {
            dest.parentNode.insertBefore(src, dest);
          },
          elementIsDescendant: function(el, parent, stopAt) {
            var current = el;
            do {
              if (current === parent)
                return true;
              current = current.parentNode;
            } while (current && current !== stopAt);
            return false;
          },
          getParentWithClass: function(e, className, depth) {
            depth = depth || 10;
            while (e.parentNode && depth--) {
              if (e.parentNode.classList && e.parentNode.classList.contains(className)) {
                return e.parentNode;
              }
              e = e.parentNode;
            }
            return null;
          },
          getParentOrSelfWithClass: function(e, className, depth) {
            depth = depth || 10;
            while (e && depth--) {
              if (e.classList && e.classList.contains(className)) {
                return e;
              }
              e = e.parentNode;
            }
            return null;
          },
          rectContains: function(x, y, x1, y1, x2, y2) {
            if (x < x1 || x > x2)
              return false;
            if (y < y1 || y > y2)
              return false;
            return true;
          },
          blurAll: function() {
            if (document.activeElement && document.activeElement != document.body) {
              document.activeElement.blur();
              return document.activeElement;
            }
            return null;
          },
          cachedAttr: function(ele, key, value) {
            ele = ele && ele.length && ele[0] || ele;
            if (ele && ele.setAttribute) {
              var dataKey = '$attr-' + key;
              if (arguments.length > 2) {
                if (ele[dataKey] !== value) {
                  ele.setAttribute(key, value);
                  ele[dataKey] = value;
                }
              } else if (typeof ele[dataKey] == 'undefined') {
                ele[dataKey] = ele.getAttribute(key);
              }
              return ele[dataKey];
            }
          },
          cachedStyles: function(ele, styles) {
            ele = ele && ele.length && ele[0] || ele;
            if (ele && ele.style) {
              for (var prop in styles) {
                if (ele['$style-' + prop] !== styles[prop]) {
                  ele.style[prop] = ele['$style-' + prop] = styles[prop];
                }
              }
            }
          }
        };
        ionic.requestAnimationFrame = ionic.DomUtil.requestAnimationFrame;
        ionic.cancelAnimationFrame = ionic.DomUtil.cancelAnimationFrame;
        ionic.animationFrameThrottle = ionic.DomUtil.animationFrameThrottle;
      })(window, document, ionic);
      (function(ionic) {
        ionic.CustomEvent = (function() {
          if (typeof window.CustomEvent === 'function')
            return CustomEvent;
          var customEvent = function(event, params) {
            var evt;
            params = params || {
              bubbles: false,
              cancelable: false,
              detail: undefined
            };
            try {
              evt = document.createEvent("CustomEvent");
              evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
            } catch (error) {
              evt = document.createEvent("Event");
              for (var param in params) {
                evt[param] = params[param];
              }
              evt.initEvent(event, params.bubbles, params.cancelable);
            }
            return evt;
          };
          customEvent.prototype = window.Event.prototype;
          return customEvent;
        })();
        ionic.EventController = {
          VIRTUALIZED_EVENTS: ['tap', 'swipe', 'swiperight', 'swipeleft', 'drag', 'hold', 'release'],
          trigger: function(eventType, data, bubbles, cancelable) {
            var event = new ionic.CustomEvent(eventType, {
              detail: data,
              bubbles: !!bubbles,
              cancelable: !!cancelable
            });
            data && data.target && data.target.dispatchEvent && data.target.dispatchEvent(event) || window.dispatchEvent(event);
          },
          on: function(type, callback, element) {
            var e = element || window;
            for (var i = 0,
                j = this.VIRTUALIZED_EVENTS.length; i < j; i++) {
              if (type == this.VIRTUALIZED_EVENTS[i]) {
                var gesture = new ionic.Gesture(element);
                gesture.on(type, callback);
                return gesture;
              }
            }
            e.addEventListener(type, callback);
          },
          off: function(type, callback, element) {
            element.removeEventListener(type, callback);
          },
          onGesture: function(type, callback, element, options) {
            var gesture = new ionic.Gesture(element, options);
            gesture.on(type, callback);
            return gesture;
          },
          offGesture: function(gesture, type, callback) {
            gesture && gesture.off(type, callback);
          },
          handlePopState: function() {}
        };
        ionic.on = function() {
          ionic.EventController.on.apply(ionic.EventController, arguments);
        };
        ionic.off = function() {
          ionic.EventController.off.apply(ionic.EventController, arguments);
        };
        ionic.trigger = ionic.EventController.trigger;
        ionic.onGesture = function() {
          return ionic.EventController.onGesture.apply(ionic.EventController.onGesture, arguments);
        };
        ionic.offGesture = function() {
          return ionic.EventController.offGesture.apply(ionic.EventController.offGesture, arguments);
        };
      })(window.ionic);
      (function(ionic) {
        ionic.Gesture = function(element, options) {
          return new ionic.Gestures.Instance(element, options || {});
        };
        ionic.Gestures = {};
        ionic.Gestures.defaults = {stop_browser_behavior: 'disable-user-behavior'};
        ionic.Gestures.HAS_POINTEREVENTS = window.navigator.pointerEnabled || window.navigator.msPointerEnabled;
        ionic.Gestures.HAS_TOUCHEVENTS = ('ontouchstart' in window);
        ionic.Gestures.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android|silk/i;
        ionic.Gestures.NO_MOUSEEVENTS = ionic.Gestures.HAS_TOUCHEVENTS && window.navigator.userAgent.match(ionic.Gestures.MOBILE_REGEX);
        ionic.Gestures.EVENT_TYPES = {};
        ionic.Gestures.DIRECTION_DOWN = 'down';
        ionic.Gestures.DIRECTION_LEFT = 'left';
        ionic.Gestures.DIRECTION_UP = 'up';
        ionic.Gestures.DIRECTION_RIGHT = 'right';
        ionic.Gestures.POINTER_MOUSE = 'mouse';
        ionic.Gestures.POINTER_TOUCH = 'touch';
        ionic.Gestures.POINTER_PEN = 'pen';
        ionic.Gestures.EVENT_START = 'start';
        ionic.Gestures.EVENT_MOVE = 'move';
        ionic.Gestures.EVENT_END = 'end';
        ionic.Gestures.DOCUMENT = window.document;
        ionic.Gestures.plugins = {};
        ionic.Gestures.READY = false;
        function setup() {
          if (ionic.Gestures.READY) {
            return ;
          }
          ionic.Gestures.event.determineEventTypes();
          for (var name in ionic.Gestures.gestures) {
            if (ionic.Gestures.gestures.hasOwnProperty(name)) {
              ionic.Gestures.detection.register(ionic.Gestures.gestures[name]);
            }
          }
          ionic.Gestures.event.onTouch(ionic.Gestures.DOCUMENT, ionic.Gestures.EVENT_MOVE, ionic.Gestures.detection.detect);
          ionic.Gestures.event.onTouch(ionic.Gestures.DOCUMENT, ionic.Gestures.EVENT_END, ionic.Gestures.detection.detect);
          ionic.Gestures.READY = true;
        }
        ionic.Gestures.Instance = function(element, options) {
          var self = this;
          if (element === null) {
            void 0;
            return this;
          }
          setup();
          this.element = element;
          this.enabled = true;
          this.options = ionic.Gestures.utils.extend(ionic.Gestures.utils.extend({}, ionic.Gestures.defaults), options || {});
          if (this.options.stop_browser_behavior) {
            ionic.Gestures.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior);
          }
          ionic.Gestures.event.onTouch(element, ionic.Gestures.EVENT_START, function(ev) {
            if (self.enabled) {
              ionic.Gestures.detection.startDetect(self, ev);
            }
          });
          return this;
        };
        ionic.Gestures.Instance.prototype = {
          on: function onEvent(gesture, handler) {
            var gestures = gesture.split(' ');
            for (var t = 0; t < gestures.length; t++) {
              this.element.addEventListener(gestures[t], handler, false);
            }
            return this;
          },
          off: function offEvent(gesture, handler) {
            var gestures = gesture.split(' ');
            for (var t = 0; t < gestures.length; t++) {
              this.element.removeEventListener(gestures[t], handler, false);
            }
            return this;
          },
          trigger: function triggerEvent(gesture, eventData) {
            var event = ionic.Gestures.DOCUMENT.createEvent('Event');
            event.initEvent(gesture, true, true);
            event.gesture = eventData;
            var element = this.element;
            if (ionic.Gestures.utils.hasParent(eventData.target, element)) {
              element = eventData.target;
            }
            element.dispatchEvent(event);
            return this;
          },
          enable: function enable(state) {
            this.enabled = state;
            return this;
          }
        };
        var last_move_event = null;
        var enable_detect = false;
        var touch_triggered = false;
        ionic.Gestures.event = {
          bindDom: function(element, type, handler) {
            var types = type.split(' ');
            for (var t = 0; t < types.length; t++) {
              element.addEventListener(types[t], handler, false);
            }
          },
          onTouch: function onTouch(element, eventType, handler) {
            var self = this;
            this.bindDom(element, ionic.Gestures.EVENT_TYPES[eventType], function bindDomOnTouch(ev) {
              var sourceEventType = ev.type.toLowerCase();
              if (sourceEventType.match(/mouse/) && touch_triggered) {
                return ;
              } else if (sourceEventType.match(/touch/) || sourceEventType.match(/pointerdown/) || (sourceEventType.match(/mouse/) && ev.which === 1)) {
                enable_detect = true;
              } else if (sourceEventType.match(/mouse/) && ev.which !== 1) {
                enable_detect = false;
              }
              if (sourceEventType.match(/touch|pointer/)) {
                touch_triggered = true;
              }
              var count_touches = 0;
              if (enable_detect) {
                if (ionic.Gestures.HAS_POINTEREVENTS && eventType != ionic.Gestures.EVENT_END) {
                  count_touches = ionic.Gestures.PointerEvent.updatePointer(eventType, ev);
                } else if (sourceEventType.match(/touch/)) {
                  count_touches = ev.touches.length;
                } else if (!touch_triggered) {
                  count_touches = sourceEventType.match(/up/) ? 0 : 1;
                }
                if (count_touches > 0 && eventType == ionic.Gestures.EVENT_END) {
                  eventType = ionic.Gestures.EVENT_MOVE;
                } else if (!count_touches) {
                  eventType = ionic.Gestures.EVENT_END;
                }
                if (count_touches || last_move_event === null) {
                  last_move_event = ev;
                }
                handler.call(ionic.Gestures.detection, self.collectEventData(element, eventType, self.getTouchList(last_move_event, eventType), ev));
                if (ionic.Gestures.HAS_POINTEREVENTS && eventType == ionic.Gestures.EVENT_END) {
                  count_touches = ionic.Gestures.PointerEvent.updatePointer(eventType, ev);
                }
              }
              if (!count_touches) {
                last_move_event = null;
                enable_detect = false;
                touch_triggered = false;
                ionic.Gestures.PointerEvent.reset();
              }
            });
          },
          determineEventTypes: function determineEventTypes() {
            var types;
            if (ionic.Gestures.HAS_POINTEREVENTS) {
              types = ionic.Gestures.PointerEvent.getEvents();
            } else if (ionic.Gestures.NO_MOUSEEVENTS) {
              types = ['touchstart', 'touchmove', 'touchend touchcancel'];
            } else {
              types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];
            }
            ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_START] = types[0];
            ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_MOVE] = types[1];
            ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_END] = types[2];
          },
          getTouchList: function getTouchList(ev) {
            if (ionic.Gestures.HAS_POINTEREVENTS) {
              return ionic.Gestures.PointerEvent.getTouchList();
            } else if (ev.touches) {
              return ev.touches;
            } else {
              ev.identifier = 1;
              return [ev];
            }
          },
          collectEventData: function collectEventData(element, eventType, touches, ev) {
            var pointerType = ionic.Gestures.POINTER_TOUCH;
            if (ev.type.match(/mouse/) || ionic.Gestures.PointerEvent.matchType(ionic.Gestures.POINTER_MOUSE, ev)) {
              pointerType = ionic.Gestures.POINTER_MOUSE;
            }
            return {
              center: ionic.Gestures.utils.getCenter(touches),
              timeStamp: new Date().getTime(),
              target: ev.target,
              touches: touches,
              eventType: eventType,
              pointerType: pointerType,
              srcEvent: ev,
              preventDefault: function() {
                if (this.srcEvent.preventManipulation) {
                  this.srcEvent.preventManipulation();
                }
                if (this.srcEvent.preventDefault) {}
              },
              stopPropagation: function() {
                this.srcEvent.stopPropagation();
              },
              stopDetect: function() {
                return ionic.Gestures.detection.stopDetect();
              }
            };
          }
        };
        ionic.Gestures.PointerEvent = {
          pointers: {},
          getTouchList: function() {
            var self = this;
            var touchlist = [];
            Object.keys(self.pointers).sort().forEach(function(id) {
              touchlist.push(self.pointers[id]);
            });
            return touchlist;
          },
          updatePointer: function(type, pointerEvent) {
            if (type == ionic.Gestures.EVENT_END) {
              this.pointers = {};
            } else {
              pointerEvent.identifier = pointerEvent.pointerId;
              this.pointers[pointerEvent.pointerId] = pointerEvent;
            }
            return Object.keys(this.pointers).length;
          },
          matchType: function(pointerType, ev) {
            if (!ev.pointerType) {
              return false;
            }
            var types = {};
            types[ionic.Gestures.POINTER_MOUSE] = (ev.pointerType == ev.MSPOINTER_TYPE_MOUSE || ev.pointerType == ionic.Gestures.POINTER_MOUSE);
            types[ionic.Gestures.POINTER_TOUCH] = (ev.pointerType == ev.MSPOINTER_TYPE_TOUCH || ev.pointerType == ionic.Gestures.POINTER_TOUCH);
            types[ionic.Gestures.POINTER_PEN] = (ev.pointerType == ev.MSPOINTER_TYPE_PEN || ev.pointerType == ionic.Gestures.POINTER_PEN);
            return types[pointerType];
          },
          getEvents: function() {
            return ['pointerdown MSPointerDown', 'pointermove MSPointerMove', 'pointerup pointercancel MSPointerUp MSPointerCancel'];
          },
          reset: function() {
            this.pointers = {};
          }
        };
        ionic.Gestures.utils = {
          extend: function extend(dest, src, merge) {
            for (var key in src) {
              if (dest[key] !== undefined && merge) {
                continue;
              }
              dest[key] = src[key];
            }
            return dest;
          },
          hasParent: function(node, parent) {
            while (node) {
              if (node == parent) {
                return true;
              }
              node = node.parentNode;
            }
            return false;
          },
          getCenter: function getCenter(touches) {
            var valuesX = [],
                valuesY = [];
            for (var t = 0,
                len = touches.length; t < len; t++) {
              valuesX.push(touches[t].pageX);
              valuesY.push(touches[t].pageY);
            }
            return {
              pageX: ((Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2),
              pageY: ((Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2)
            };
          },
          getVelocity: function getVelocity(delta_time, delta_x, delta_y) {
            return {
              x: Math.abs(delta_x / delta_time) || 0,
              y: Math.abs(delta_y / delta_time) || 0
            };
          },
          getAngle: function getAngle(touch1, touch2) {
            var y = touch2.pageY - touch1.pageY,
                x = touch2.pageX - touch1.pageX;
            return Math.atan2(y, x) * 180 / Math.PI;
          },
          getDirection: function getDirection(touch1, touch2) {
            var x = Math.abs(touch1.pageX - touch2.pageX),
                y = Math.abs(touch1.pageY - touch2.pageY);
            if (x >= y) {
              return touch1.pageX - touch2.pageX > 0 ? ionic.Gestures.DIRECTION_LEFT : ionic.Gestures.DIRECTION_RIGHT;
            } else {
              return touch1.pageY - touch2.pageY > 0 ? ionic.Gestures.DIRECTION_UP : ionic.Gestures.DIRECTION_DOWN;
            }
          },
          getDistance: function getDistance(touch1, touch2) {
            var x = touch2.pageX - touch1.pageX,
                y = touch2.pageY - touch1.pageY;
            return Math.sqrt((x * x) + (y * y));
          },
          getScale: function getScale(start, end) {
            if (start.length >= 2 && end.length >= 2) {
              return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
            }
            return 1;
          },
          getRotation: function getRotation(start, end) {
            if (start.length >= 2 && end.length >= 2) {
              return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
            }
            return 0;
          },
          isVertical: function isVertical(direction) {
            return (direction == ionic.Gestures.DIRECTION_UP || direction == ionic.Gestures.DIRECTION_DOWN);
          },
          stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(element, css_class) {
            if (element && element.classList) {
              element.classList.add(css_class);
              element.onselectstart = function() {
                return false;
              };
            }
          }
        };
        ionic.Gestures.detection = {
          gestures: [],
          current: null,
          previous: null,
          stopped: false,
          startDetect: function startDetect(inst, eventData) {
            if (this.current) {
              return ;
            }
            this.stopped = false;
            this.current = {
              inst: inst,
              startEvent: ionic.Gestures.utils.extend({}, eventData),
              lastEvent: false,
              name: ''
            };
            this.detect(eventData);
          },
          detect: function detect(eventData) {
            if (!this.current || this.stopped) {
              return null;
            }
            eventData = this.extendEventData(eventData);
            var inst_options = this.current.inst.options;
            for (var g = 0,
                len = this.gestures.length; g < len; g++) {
              var gesture = this.gestures[g];
              if (!this.stopped && inst_options[gesture.name] !== false) {
                if (gesture.handler.call(gesture, eventData, this.current.inst) === false) {
                  this.stopDetect();
                  break;
                }
              }
            }
            if (this.current) {
              this.current.lastEvent = eventData;
            }
            if (eventData.eventType == ionic.Gestures.EVENT_END && !eventData.touches.length - 1) {
              this.stopDetect();
            }
            return eventData;
          },
          stopDetect: function stopDetect() {
            this.previous = ionic.Gestures.utils.extend({}, this.current);
            this.current = null;
            this.stopped = true;
          },
          extendEventData: function extendEventData(ev) {
            var startEv = this.current.startEvent;
            if (startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {
              startEv.touches = [];
              for (var i = 0,
                  len = ev.touches.length; i < len; i++) {
                startEv.touches.push(ionic.Gestures.utils.extend({}, ev.touches[i]));
              }
            }
            var delta_time = ev.timeStamp - startEv.timeStamp,
                delta_x = ev.center.pageX - startEv.center.pageX,
                delta_y = ev.center.pageY - startEv.center.pageY,
                velocity = ionic.Gestures.utils.getVelocity(delta_time, delta_x, delta_y);
            ionic.Gestures.utils.extend(ev, {
              deltaTime: delta_time,
              deltaX: delta_x,
              deltaY: delta_y,
              velocityX: velocity.x,
              velocityY: velocity.y,
              distance: ionic.Gestures.utils.getDistance(startEv.center, ev.center),
              angle: ionic.Gestures.utils.getAngle(startEv.center, ev.center),
              direction: ionic.Gestures.utils.getDirection(startEv.center, ev.center),
              scale: ionic.Gestures.utils.getScale(startEv.touches, ev.touches),
              rotation: ionic.Gestures.utils.getRotation(startEv.touches, ev.touches),
              startEvent: startEv
            });
            return ev;
          },
          register: function register(gesture) {
            var options = gesture.defaults || {};
            if (options[gesture.name] === undefined) {
              options[gesture.name] = true;
            }
            ionic.Gestures.utils.extend(ionic.Gestures.defaults, options, true);
            gesture.index = gesture.index || 1000;
            this.gestures.push(gesture);
            this.gestures.sort(function(a, b) {
              if (a.index < b.index) {
                return -1;
              }
              if (a.index > b.index) {
                return 1;
              }
              return 0;
            });
            return this.gestures;
          }
        };
        ionic.Gestures.gestures = ionic.Gestures.gestures || {};
        ionic.Gestures.gestures.Hold = {
          name: 'hold',
          index: 10,
          defaults: {
            hold_timeout: 500,
            hold_threshold: 1
          },
          timer: null,
          handler: function holdGesture(ev, inst) {
            switch (ev.eventType) {
              case ionic.Gestures.EVENT_START:
                clearTimeout(this.timer);
                ionic.Gestures.detection.current.name = this.name;
                this.timer = setTimeout(function() {
                  if (ionic.Gestures.detection.current.name == 'hold') {
                    ionic.tap.cancelClick();
                    inst.trigger('hold', ev);
                  }
                }, inst.options.hold_timeout);
                break;
              case ionic.Gestures.EVENT_MOVE:
                if (ev.distance > inst.options.hold_threshold) {
                  clearTimeout(this.timer);
                }
                break;
              case ionic.Gestures.EVENT_END:
                clearTimeout(this.timer);
                break;
            }
          }
        };
        ionic.Gestures.gestures.Tap = {
          name: 'tap',
          index: 100,
          defaults: {
            tap_max_touchtime: 250,
            tap_max_distance: 10,
            tap_always: true,
            doubletap_distance: 20,
            doubletap_interval: 300
          },
          handler: function tapGesture(ev, inst) {
            if (ev.eventType == ionic.Gestures.EVENT_END && ev.srcEvent.type != 'touchcancel') {
              var prev = ionic.Gestures.detection.previous,
                  did_doubletap = false;
              if (ev.deltaTime > inst.options.tap_max_touchtime || ev.distance > inst.options.tap_max_distance) {
                return ;
              }
              if (prev && prev.name == 'tap' && (ev.timeStamp - prev.lastEvent.timeStamp) < inst.options.doubletap_interval && ev.distance < inst.options.doubletap_distance) {
                inst.trigger('doubletap', ev);
                did_doubletap = true;
              }
              if (!did_doubletap || inst.options.tap_always) {
                ionic.Gestures.detection.current.name = 'tap';
                inst.trigger('tap', ev);
              }
            }
          }
        };
        ionic.Gestures.gestures.Swipe = {
          name: 'swipe',
          index: 40,
          defaults: {
            swipe_max_touches: 1,
            swipe_velocity: 0.4
          },
          handler: function swipeGesture(ev, inst) {
            if (ev.eventType == ionic.Gestures.EVENT_END) {
              if (inst.options.swipe_max_touches > 0 && ev.touches.length > inst.options.swipe_max_touches) {
                return ;
              }
              if (ev.velocityX > inst.options.swipe_velocity || ev.velocityY > inst.options.swipe_velocity) {
                inst.trigger(this.name, ev);
                inst.trigger(this.name + ev.direction, ev);
              }
            }
          }
        };
        ionic.Gestures.gestures.Drag = {
          name: 'drag',
          index: 50,
          defaults: {
            drag_min_distance: 10,
            correct_for_drag_min_distance: true,
            drag_max_touches: 1,
            drag_block_horizontal: true,
            drag_block_vertical: true,
            drag_lock_to_axis: false,
            drag_lock_min_distance: 25,
            prevent_default_directions: []
          },
          triggered: false,
          handler: function dragGesture(ev, inst) {
            if (ev.srcEvent.type == 'touchstart' || ev.srcEvent.type == 'touchend') {
              this.preventedFirstMove = false;
            } else if (!this.preventedFirstMove && ev.srcEvent.type == 'touchmove') {
              if (inst.options.prevent_default_directions.length > 0 && inst.options.prevent_default_directions.indexOf(ev.direction) != -1) {
                ev.srcEvent.preventDefault();
              }
              this.preventedFirstMove = true;
            }
            if (ionic.Gestures.detection.current.name != this.name && this.triggered) {
              inst.trigger(this.name + 'end', ev);
              this.triggered = false;
              return ;
            }
            if (inst.options.drag_max_touches > 0 && ev.touches.length > inst.options.drag_max_touches) {
              return ;
            }
            switch (ev.eventType) {
              case ionic.Gestures.EVENT_START:
                this.triggered = false;
                break;
              case ionic.Gestures.EVENT_MOVE:
                if (ev.distance < inst.options.drag_min_distance && ionic.Gestures.detection.current.name != this.name) {
                  return ;
                }
                if (ionic.Gestures.detection.current.name != this.name) {
                  ionic.Gestures.detection.current.name = this.name;
                  if (inst.options.correct_for_drag_min_distance) {
                    var factor = Math.abs(inst.options.drag_min_distance / ev.distance);
                    ionic.Gestures.detection.current.startEvent.center.pageX += ev.deltaX * factor;
                    ionic.Gestures.detection.current.startEvent.center.pageY += ev.deltaY * factor;
                    ev = ionic.Gestures.detection.extendEventData(ev);
                  }
                }
                if (ionic.Gestures.detection.current.lastEvent.drag_locked_to_axis || (inst.options.drag_lock_to_axis && inst.options.drag_lock_min_distance <= ev.distance)) {
                  ev.drag_locked_to_axis = true;
                }
                var last_direction = ionic.Gestures.detection.current.lastEvent.direction;
                if (ev.drag_locked_to_axis && last_direction !== ev.direction) {
                  if (ionic.Gestures.utils.isVertical(last_direction)) {
                    ev.direction = (ev.deltaY < 0) ? ionic.Gestures.DIRECTION_UP : ionic.Gestures.DIRECTION_DOWN;
                  } else {
                    ev.direction = (ev.deltaX < 0) ? ionic.Gestures.DIRECTION_LEFT : ionic.Gestures.DIRECTION_RIGHT;
                  }
                }
                if (!this.triggered) {
                  inst.trigger(this.name + 'start', ev);
                  this.triggered = true;
                }
                inst.trigger(this.name, ev);
                inst.trigger(this.name + ev.direction, ev);
                if ((inst.options.drag_block_vertical && ionic.Gestures.utils.isVertical(ev.direction)) || (inst.options.drag_block_horizontal && !ionic.Gestures.utils.isVertical(ev.direction))) {
                  ev.preventDefault();
                }
                break;
              case ionic.Gestures.EVENT_END:
                if (this.triggered) {
                  inst.trigger(this.name + 'end', ev);
                }
                this.triggered = false;
                break;
            }
          }
        };
        ionic.Gestures.gestures.Transform = {
          name: 'transform',
          index: 45,
          defaults: {
            transform_min_scale: 0.01,
            transform_min_rotation: 1,
            transform_always_block: false
          },
          triggered: false,
          handler: function transformGesture(ev, inst) {
            if (ionic.Gestures.detection.current.name != this.name && this.triggered) {
              inst.trigger(this.name + 'end', ev);
              this.triggered = false;
              return ;
            }
            if (ev.touches.length < 2) {
              return ;
            }
            if (inst.options.transform_always_block) {
              ev.preventDefault();
            }
            switch (ev.eventType) {
              case ionic.Gestures.EVENT_START:
                this.triggered = false;
                break;
              case ionic.Gestures.EVENT_MOVE:
                var scale_threshold = Math.abs(1 - ev.scale);
                var rotation_threshold = Math.abs(ev.rotation);
                if (scale_threshold < inst.options.transform_min_scale && rotation_threshold < inst.options.transform_min_rotation) {
                  return ;
                }
                ionic.Gestures.detection.current.name = this.name;
                if (!this.triggered) {
                  inst.trigger(this.name + 'start', ev);
                  this.triggered = true;
                }
                inst.trigger(this.name, ev);
                if (rotation_threshold > inst.options.transform_min_rotation) {
                  inst.trigger('rotate', ev);
                }
                if (scale_threshold > inst.options.transform_min_scale) {
                  inst.trigger('pinch', ev);
                  inst.trigger('pinch' + ((ev.scale < 1) ? 'in' : 'out'), ev);
                }
                break;
              case ionic.Gestures.EVENT_END:
                if (this.triggered) {
                  inst.trigger(this.name + 'end', ev);
                }
                this.triggered = false;
                break;
            }
          }
        };
        ionic.Gestures.gestures.Touch = {
          name: 'touch',
          index: -Infinity,
          defaults: {
            prevent_default: false,
            prevent_mouseevents: false
          },
          handler: function touchGesture(ev, inst) {
            if (inst.options.prevent_mouseevents && ev.pointerType == ionic.Gestures.POINTER_MOUSE) {
              ev.stopDetect();
              return ;
            }
            if (inst.options.prevent_default) {
              ev.preventDefault();
            }
            if (ev.eventType == ionic.Gestures.EVENT_START) {
              inst.trigger(this.name, ev);
            }
          }
        };
        ionic.Gestures.gestures.Release = {
          name: 'release',
          index: Infinity,
          handler: function releaseGesture(ev, inst) {
            if (ev.eventType == ionic.Gestures.EVENT_END) {
              inst.trigger(this.name, ev);
            }
          }
        };
      })(window.ionic);
      (function(window, document, ionic) {
        function getParameterByName(name) {
          name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
          var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
              results = regex.exec(location.search);
          return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
        }
        var IOS = 'ios';
        var ANDROID = 'android';
        var WINDOWS_PHONE = 'windowsphone';
        var requestAnimationFrame = ionic.requestAnimationFrame;
        var self = ionic.Platform = {
          navigator: window.navigator,
          isReady: false,
          isFullScreen: false,
          platforms: null,
          grade: null,
          ua: navigator.userAgent,
          ready: function(cb) {
            if (self.isReady) {
              cb();
            } else {
              readyCallbacks.push(cb);
            }
          },
          detect: function() {
            self._checkPlatforms();
            requestAnimationFrame(function() {
              for (var i = 0; i < self.platforms.length; i++) {
                document.body.classList.add('platform-' + self.platforms[i]);
              }
            });
          },
          setGrade: function(grade) {
            var oldGrade = self.grade;
            self.grade = grade;
            requestAnimationFrame(function() {
              if (oldGrade) {
                document.body.classList.remove('grade-' + oldGrade);
              }
              document.body.classList.add('grade-' + grade);
            });
          },
          device: function() {
            return window.device || {};
          },
          _checkPlatforms: function() {
            self.platforms = [];
            var grade = 'a';
            if (self.isWebView()) {
              self.platforms.push('webview');
              if (!(!window.cordova && !window.PhoneGap && !window.phonegap)) {
                self.platforms.push('cordova');
              } else if (window.forge) {
                self.platforms.push('trigger');
              }
            } else {
              self.platforms.push('browser');
            }
            if (self.isIPad())
              self.platforms.push('ipad');
            var platform = self.platform();
            if (platform) {
              self.platforms.push(platform);
              var version = self.version();
              if (version) {
                var v = version.toString();
                if (v.indexOf('.') > 0) {
                  v = v.replace('.', '_');
                } else {
                  v += '_0';
                }
                self.platforms.push(platform + v.split('_')[0]);
                self.platforms.push(platform + v);
                if (self.isAndroid() && version < 4.4) {
                  grade = (version < 4 ? 'c' : 'b');
                } else if (self.isWindowsPhone()) {
                  grade = 'b';
                }
              }
            }
            self.setGrade(grade);
          },
          isWebView: function() {
            return !(!window.cordova && !window.PhoneGap && !window.phonegap && !window.forge);
          },
          isIPad: function() {
            if (/iPad/i.test(self.navigator.platform)) {
              return true;
            }
            return /iPad/i.test(self.ua);
          },
          isIOS: function() {
            return self.is(IOS);
          },
          isAndroid: function() {
            return self.is(ANDROID);
          },
          isWindowsPhone: function() {
            return self.is(WINDOWS_PHONE);
          },
          platform: function() {
            if (platformName === null)
              self.setPlatform(self.device().platform);
            return platformName;
          },
          setPlatform: function(n) {
            if (typeof n != 'undefined' && n !== null && n.length) {
              platformName = n.toLowerCase();
            } else if (getParameterByName('ionicplatform')) {
              platformName = getParameterByName('ionicplatform');
            } else if (self.ua.indexOf('Android') > 0) {
              platformName = ANDROID;
            } else if (/iPhone|iPad|iPod/.test(self.ua)) {
              platformName = IOS;
            } else if (self.ua.indexOf('Windows Phone') > -1) {
              platformName = WINDOWS_PHONE;
            } else {
              platformName = self.navigator.platform && navigator.platform.toLowerCase().split(' ')[0] || '';
            }
          },
          version: function() {
            if (platformVersion === null)
              self.setVersion(self.device().version);
            return platformVersion;
          },
          setVersion: function(v) {
            if (typeof v != 'undefined' && v !== null) {
              v = v.split('.');
              v = parseFloat(v[0] + '.' + (v.length > 1 ? v[1] : 0));
              if (!isNaN(v)) {
                platformVersion = v;
                return ;
              }
            }
            platformVersion = 0;
            var pName = self.platform();
            var versionMatch = {
              'android': /Android (\d+).(\d+)?/,
              'ios': /OS (\d+)_(\d+)?/,
              'windowsphone': /Windows Phone (\d+).(\d+)?/
            };
            if (versionMatch[pName]) {
              v = self.ua.match(versionMatch[pName]);
              if (v && v.length > 2) {
                platformVersion = parseFloat(v[1] + '.' + v[2]);
              }
            }
          },
          is: function(type) {
            type = type.toLowerCase();
            if (self.platforms) {
              for (var x = 0; x < self.platforms.length; x++) {
                if (self.platforms[x] === type)
                  return true;
              }
            }
            var pName = self.platform();
            if (pName) {
              return pName === type.toLowerCase();
            }
            return self.ua.toLowerCase().indexOf(type) >= 0;
          },
          exitApp: function() {
            self.ready(function() {
              navigator.app && navigator.app.exitApp && navigator.app.exitApp();
            });
          },
          showStatusBar: function(val) {
            self._showStatusBar = val;
            self.ready(function() {
              requestAnimationFrame(function() {
                if (self._showStatusBar) {
                  window.StatusBar && window.StatusBar.show();
                  document.body.classList.remove('status-bar-hide');
                } else {
                  window.StatusBar && window.StatusBar.hide();
                  document.body.classList.add('status-bar-hide');
                }
              });
            });
          },
          fullScreen: function(showFullScreen, showStatusBar) {
            self.isFullScreen = (showFullScreen !== false);
            ionic.DomUtil.ready(function() {
              requestAnimationFrame(function() {
                if (self.isFullScreen) {
                  document.body.classList.add('fullscreen');
                } else {
                  document.body.classList.remove('fullscreen');
                }
              });
              self.showStatusBar((showStatusBar === true));
            });
          }
        };
        var platformName = null,
            platformVersion = null,
            readyCallbacks = [],
            windowLoadListenderAttached;
        function onWindowLoad() {
          if (self.isWebView()) {
            document.addEventListener("deviceready", onPlatformReady, false);
          } else {
            onPlatformReady();
          }
          if (windowLoadListenderAttached) {
            window.removeEventListener("load", onWindowLoad, false);
          }
        }
        if (document.readyState === 'complete') {
          onWindowLoad();
        } else {
          windowLoadListenderAttached = true;
          window.addEventListener("load", onWindowLoad, false);
        }
        function onPlatformReady() {
          self.isReady = true;
          self.detect();
          for (var x = 0; x < readyCallbacks.length; x++) {
            readyCallbacks[x]();
          }
          readyCallbacks = [];
          ionic.trigger('platformready', {target: document});
          requestAnimationFrame(function() {
            document.body.classList.add('platform-ready');
          });
        }
      })(this, document, ionic);
      (function(document, ionic) {
        'use strict';
        ionic.CSS = {};
        (function() {
          var i,
              keys = ['webkitTransform', 'transform', '-webkit-transform', 'webkit-transform', '-moz-transform', 'moz-transform', 'MozTransform', 'mozTransform', 'msTransform'];
          for (i = 0; i < keys.length; i++) {
            if (document.documentElement.style[keys[i]] !== undefined) {
              ionic.CSS.TRANSFORM = keys[i];
              break;
            }
          }
          keys = ['webkitTransition', 'mozTransition', 'msTransition', 'transition'];
          for (i = 0; i < keys.length; i++) {
            if (document.documentElement.style[keys[i]] !== undefined) {
              ionic.CSS.TRANSITION = keys[i];
              break;
            }
          }
          var isWebkit = ionic.CSS.TRANSITION.indexOf('webkit') > -1;
          ionic.CSS.TRANSITION_DURATION = (isWebkit ? '-webkit-' : '') + 'transition-duration';
          ionic.CSS.TRANSITIONEND = (isWebkit ? 'webkitTransitionEnd ' : '') + 'transitionend';
        })();
        if (!("classList" in document.documentElement) && Object.defineProperty && typeof HTMLElement !== 'undefined') {
          Object.defineProperty(HTMLElement.prototype, 'classList', {get: function() {
              var self = this;
              function update(fn) {
                return function() {
                  var x,
                      classes = self.className.split(/\s+/);
                  for (x = 0; x < arguments.length; x++) {
                    fn(classes, classes.indexOf(arguments[x]), arguments[x]);
                  }
                  self.className = classes.join(" ");
                };
              }
              return {
                add: update(function(classes, index, value) {
                  ~index || classes.push(value);
                }),
                remove: update(function(classes, index) {
                  ~index && classes.splice(index, 1);
                }),
                toggle: update(function(classes, index, value) {
                  ~index ? classes.splice(index, 1) : classes.push(value);
                }),
                contains: function(value) {
                  return !!~self.className.split(/\s+/).indexOf(value);
                },
                item: function(i) {
                  return self.className.split(/\s+/)[i] || null;
                }
              };
            }});
        }
      })(document, ionic);
      var tapDoc;
      var tapActiveEle;
      var tapEnabledTouchEvents;
      var tapMouseResetTimer;
      var tapPointerMoved;
      var tapPointerStart;
      var tapTouchFocusedInput;
      var tapLastTouchTarget;
      var tapTouchMoveListener = 'touchmove';
      var TAP_RELEASE_TOLERANCE = 12;
      var TAP_RELEASE_BUTTON_TOLERANCE = 50;
      var tapEventListeners = {
        'click': tapClickGateKeeper,
        'mousedown': tapMouseDown,
        'mouseup': tapMouseUp,
        'mousemove': tapMouseMove,
        'touchstart': tapTouchStart,
        'touchend': tapTouchEnd,
        'touchcancel': tapTouchCancel,
        'touchmove': tapTouchMove,
        'pointerdown': tapTouchStart,
        'pointerup': tapTouchEnd,
        'pointercancel': tapTouchCancel,
        'pointermove': tapTouchMove,
        'MSPointerDown': tapTouchStart,
        'MSPointerUp': tapTouchEnd,
        'MSPointerCancel': tapTouchCancel,
        'MSPointerMove': tapTouchMove,
        'focusin': tapFocusIn,
        'focusout': tapFocusOut
      };
      ionic.tap = {
        register: function(ele) {
          tapDoc = ele;
          tapEventListener('click', true, true);
          tapEventListener('mouseup');
          tapEventListener('mousedown');
          if (window.navigator.pointerEnabled) {
            tapEventListener('pointerdown');
            tapEventListener('pointerup');
            tapEventListener('pointcancel');
            tapTouchMoveListener = 'pointermove';
          } else if (window.navigator.msPointerEnabled) {
            tapEventListener('MSPointerDown');
            tapEventListener('MSPointerUp');
            tapEventListener('MSPointerCancel');
            tapTouchMoveListener = 'MSPointerMove';
          } else {
            tapEventListener('touchstart');
            tapEventListener('touchend');
            tapEventListener('touchcancel');
          }
          tapEventListener('focusin');
          tapEventListener('focusout');
          return function() {
            for (var type in tapEventListeners) {
              tapEventListener(type, false);
            }
            tapDoc = null;
            tapActiveEle = null;
            tapEnabledTouchEvents = false;
            tapPointerMoved = false;
            tapPointerStart = null;
          };
        },
        ignoreScrollStart: function(e) {
          return (e.defaultPrevented) || (/^(file|range)$/i).test(e.target.type) || (e.target.dataset ? e.target.dataset.preventScroll : e.target.getAttribute('data-prevent-scroll')) == 'true' || (!!(/^(object|embed)$/i).test(e.target.tagName)) || ionic.tap.isElementTapDisabled(e.target);
        },
        isTextInput: function(ele) {
          return !!ele && (ele.tagName == 'TEXTAREA' || ele.contentEditable === 'true' || (ele.tagName == 'INPUT' && !(/^(radio|checkbox|range|file|submit|reset|color|image|button)$/i).test(ele.type)));
        },
        isDateInput: function(ele) {
          return !!ele && (ele.tagName == 'INPUT' && (/^(date|time|datetime-local|month|week)$/i).test(ele.type));
        },
        isKeyboardElement: function(ele) {
          if (!ionic.Platform.isIOS() || ionic.Platform.isIPad()) {
            return ionic.tap.isTextInput(ele) && !ionic.tap.isDateInput(ele);
          } else {
            return ionic.tap.isTextInput(ele) || (!!ele && ele.tagName == "SELECT");
          }
        },
        isLabelWithTextInput: function(ele) {
          var container = tapContainingElement(ele, false);
          return !!container && ionic.tap.isTextInput(tapTargetElement(container));
        },
        containsOrIsTextInput: function(ele) {
          return ionic.tap.isTextInput(ele) || ionic.tap.isLabelWithTextInput(ele);
        },
        cloneFocusedInput: function(container) {
          if (ionic.tap.hasCheckedClone)
            return ;
          ionic.tap.hasCheckedClone = true;
          ionic.requestAnimationFrame(function() {
            var focusInput = container.querySelector(':focus');
            if (ionic.tap.isTextInput(focusInput) && !ionic.tap.isDateInput(focusInput)) {
              var clonedInput = focusInput.cloneNode(true);
              clonedInput.value = focusInput.value;
              clonedInput.classList.add('cloned-text-input');
              clonedInput.readOnly = true;
              if (focusInput.isContentEditable) {
                clonedInput.contentEditable = focusInput.contentEditable;
                clonedInput.innerHTML = focusInput.innerHTML;
              }
              focusInput.parentElement.insertBefore(clonedInput, focusInput);
              focusInput.classList.add('previous-input-focus');
              clonedInput.scrollTop = focusInput.scrollTop;
            }
          });
        },
        hasCheckedClone: false,
        removeClonedInputs: function(container) {
          ionic.tap.hasCheckedClone = false;
          ionic.requestAnimationFrame(function() {
            var clonedInputs = container.querySelectorAll('.cloned-text-input');
            var previousInputFocus = container.querySelectorAll('.previous-input-focus');
            var x;
            for (x = 0; x < clonedInputs.length; x++) {
              clonedInputs[x].parentElement.removeChild(clonedInputs[x]);
            }
            for (x = 0; x < previousInputFocus.length; x++) {
              previousInputFocus[x].classList.remove('previous-input-focus');
              previousInputFocus[x].style.top = '';
              if (ionic.keyboard.isOpen && !ionic.keyboard.isClosing)
                previousInputFocus[x].focus();
            }
          });
        },
        requiresNativeClick: function(ele) {
          if (!ele || ele.disabled || (/^(file|range)$/i).test(ele.type) || (/^(object|video)$/i).test(ele.tagName) || ionic.tap.isLabelContainingFileInput(ele)) {
            return true;
          }
          return ionic.tap.isElementTapDisabled(ele);
        },
        isLabelContainingFileInput: function(ele) {
          var lbl = tapContainingElement(ele);
          if (lbl.tagName !== 'LABEL')
            return false;
          var fileInput = lbl.querySelector('input[type=file]');
          if (fileInput && fileInput.disabled === false)
            return true;
          return false;
        },
        isElementTapDisabled: function(ele) {
          if (ele && ele.nodeType === 1) {
            var element = ele;
            while (element) {
              if ((element.dataset ? element.dataset.tapDisabled : element.getAttribute('data-tap-disabled')) == 'true') {
                return true;
              }
              element = element.parentElement;
            }
          }
          return false;
        },
        setTolerance: function(releaseTolerance, releaseButtonTolerance) {
          TAP_RELEASE_TOLERANCE = releaseTolerance;
          TAP_RELEASE_BUTTON_TOLERANCE = releaseButtonTolerance;
        },
        cancelClick: function() {
          tapPointerMoved = true;
        },
        pointerCoord: function(event) {
          var c = {
            x: 0,
            y: 0
          };
          if (event) {
            var touches = event.touches && event.touches.length ? event.touches : [event];
            var e = (event.changedTouches && event.changedTouches[0]) || touches[0];
            if (e) {
              c.x = e.clientX || e.pageX || 0;
              c.y = e.clientY || e.pageY || 0;
            }
          }
          return c;
        }
      };
      function tapEventListener(type, enable, useCapture) {
        if (enable !== false) {
          tapDoc.addEventListener(type, tapEventListeners[type], useCapture);
        } else {
          tapDoc.removeEventListener(type, tapEventListeners[type]);
        }
      }
      function tapClick(e) {
        var container = tapContainingElement(e.target);
        var ele = tapTargetElement(container);
        if (ionic.tap.requiresNativeClick(ele) || tapPointerMoved)
          return false;
        var c = ionic.tap.pointerCoord(e);
        triggerMouseEvent('click', ele, c.x, c.y);
        tapHandleFocus(ele);
      }
      function triggerMouseEvent(type, ele, x, y) {
        var clickEvent = document.createEvent("MouseEvents");
        clickEvent.initMouseEvent(type, true, true, window, 1, 0, 0, x, y, false, false, false, false, 0, null);
        clickEvent.isIonicTap = true;
        ele.dispatchEvent(clickEvent);
      }
      function tapClickGateKeeper(e) {
        if (e.target.type == 'submit' && e.detail === 0) {
          return null;
        }
        if ((ionic.scroll.isScrolling && ionic.tap.containsOrIsTextInput(e.target)) || (!e.isIonicTap && !ionic.tap.requiresNativeClick(e.target))) {
          e.stopPropagation();
          if (!ionic.tap.isLabelWithTextInput(e.target)) {
            e.preventDefault();
          }
          return false;
        }
      }
      function tapMouseDown(e) {
        if (e.isIonicTap || tapIgnoreEvent(e))
          return null;
        if (tapEnabledTouchEvents) {
          void 0;
          e.stopPropagation();
          if ((!ionic.tap.isTextInput(e.target) || tapLastTouchTarget !== e.target) && !(/^(select|option)$/i).test(e.target.tagName)) {
            e.preventDefault();
          }
          return false;
        }
        tapPointerMoved = false;
        tapPointerStart = ionic.tap.pointerCoord(e);
        tapEventListener('mousemove');
        ionic.activator.start(e);
      }
      function tapMouseUp(e) {
        if (tapEnabledTouchEvents) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }
        if (tapIgnoreEvent(e) || (/^(select|option)$/i).test(e.target.tagName))
          return false;
        if (!tapHasPointerMoved(e)) {
          tapClick(e);
        }
        tapEventListener('mousemove', false);
        ionic.activator.end();
        tapPointerMoved = false;
      }
      function tapMouseMove(e) {
        if (tapHasPointerMoved(e)) {
          tapEventListener('mousemove', false);
          ionic.activator.end();
          tapPointerMoved = true;
          return false;
        }
      }
      function tapTouchStart(e) {
        if (tapIgnoreEvent(e))
          return ;
        tapPointerMoved = false;
        tapEnableTouchEvents();
        tapPointerStart = ionic.tap.pointerCoord(e);
        tapEventListener(tapTouchMoveListener);
        ionic.activator.start(e);
        if (ionic.Platform.isIOS() && ionic.tap.isLabelWithTextInput(e.target)) {
          var textInput = tapTargetElement(tapContainingElement(e.target));
          if (textInput !== tapActiveEle) {
            e.preventDefault();
          }
        }
      }
      function tapTouchEnd(e) {
        if (tapIgnoreEvent(e))
          return ;
        tapEnableTouchEvents();
        if (!tapHasPointerMoved(e)) {
          tapClick(e);
          if ((/^(select|option)$/i).test(e.target.tagName)) {
            e.preventDefault();
          }
        }
        tapLastTouchTarget = e.target;
        tapTouchCancel();
      }
      function tapTouchMove(e) {
        if (tapHasPointerMoved(e)) {
          tapPointerMoved = true;
          tapEventListener(tapTouchMoveListener, false);
          ionic.activator.end();
          return false;
        }
      }
      function tapTouchCancel() {
        tapEventListener(tapTouchMoveListener, false);
        ionic.activator.end();
        tapPointerMoved = false;
      }
      function tapEnableTouchEvents() {
        tapEnabledTouchEvents = true;
        clearTimeout(tapMouseResetTimer);
        tapMouseResetTimer = setTimeout(function() {
          tapEnabledTouchEvents = false;
        }, 600);
      }
      function tapIgnoreEvent(e) {
        if (e.isTapHandled)
          return true;
        e.isTapHandled = true;
        if (ionic.scroll.isScrolling && ionic.tap.containsOrIsTextInput(e.target)) {
          e.preventDefault();
          return true;
        }
      }
      function tapHandleFocus(ele) {
        tapTouchFocusedInput = null;
        var triggerFocusIn = false;
        if (ele.tagName == 'SELECT') {
          triggerMouseEvent('mousedown', ele, 0, 0);
          ele.focus && ele.focus();
          triggerFocusIn = true;
        } else if (tapActiveElement() === ele) {
          triggerFocusIn = true;
        } else if ((/^(input|textarea)$/i).test(ele.tagName) || ele.isContentEditable) {
          triggerFocusIn = true;
          ele.focus && ele.focus();
          ele.value = ele.value;
          if (tapEnabledTouchEvents) {
            tapTouchFocusedInput = ele;
          }
        } else {
          tapFocusOutActive();
        }
        if (triggerFocusIn) {
          tapActiveElement(ele);
          ionic.trigger('ionic.focusin', {target: ele}, true);
        }
      }
      function tapFocusOutActive() {
        var ele = tapActiveElement();
        if (ele && ((/^(input|textarea|select)$/i).test(ele.tagName) || ele.isContentEditable)) {
          void 0;
          ele.blur();
        }
        tapActiveElement(null);
      }
      function tapFocusIn(e) {
        if (tapEnabledTouchEvents && ionic.tap.isTextInput(tapActiveElement()) && ionic.tap.isTextInput(tapTouchFocusedInput) && tapTouchFocusedInput !== e.target) {
          void 0;
          tapTouchFocusedInput.focus();
          tapTouchFocusedInput = null;
        }
        ionic.scroll.isScrolling = false;
      }
      function tapFocusOut() {
        tapActiveElement(null);
      }
      function tapActiveElement(ele) {
        if (arguments.length) {
          tapActiveEle = ele;
        }
        return tapActiveEle || document.activeElement;
      }
      function tapHasPointerMoved(endEvent) {
        if (!endEvent || endEvent.target.nodeType !== 1 || !tapPointerStart || (tapPointerStart.x === 0 && tapPointerStart.y === 0)) {
          return false;
        }
        var endCoordinates = ionic.tap.pointerCoord(endEvent);
        var hasClassList = !!(endEvent.target.classList && endEvent.target.classList.contains && typeof endEvent.target.classList.contains === 'function');
        var releaseTolerance = hasClassList && endEvent.target.classList.contains('button') ? TAP_RELEASE_BUTTON_TOLERANCE : TAP_RELEASE_TOLERANCE;
        return Math.abs(tapPointerStart.x - endCoordinates.x) > releaseTolerance || Math.abs(tapPointerStart.y - endCoordinates.y) > releaseTolerance;
      }
      function tapContainingElement(ele, allowSelf) {
        var climbEle = ele;
        for (var x = 0; x < 6; x++) {
          if (!climbEle)
            break;
          if (climbEle.tagName === 'LABEL')
            return climbEle;
          climbEle = climbEle.parentElement;
        }
        if (allowSelf !== false)
          return ele;
      }
      function tapTargetElement(ele) {
        if (ele && ele.tagName === 'LABEL') {
          if (ele.control)
            return ele.control;
          if (ele.querySelector) {
            var control = ele.querySelector('input,textarea,select');
            if (control)
              return control;
          }
        }
        return ele;
      }
      ionic.DomUtil.ready(function() {
        var ng = typeof angular !== 'undefined' ? angular : null;
        if (!ng || (ng && !ng.scenario)) {
          ionic.tap.register(document);
        }
      });
      (function(document, ionic) {
        'use strict';
        var queueElements = {};
        var activeElements = {};
        var keyId = 0;
        var ACTIVATED_CLASS = 'activated';
        ionic.activator = {
          start: function(e) {
            var hitX = ionic.tap.pointerCoord(e).x;
            if (hitX > 0 && hitX < 30) {
              return ;
            }
            ionic.requestAnimationFrame(function() {
              if ((ionic.scroll && ionic.scroll.isScrolling) || ionic.tap.requiresNativeClick(e.target))
                return ;
              var ele = e.target;
              var eleToActivate;
              for (var x = 0; x < 6; x++) {
                if (!ele || ele.nodeType !== 1)
                  break;
                if (eleToActivate && ele.classList && ele.classList.contains('item')) {
                  eleToActivate = ele;
                  break;
                }
                if (ele.tagName == 'A' || ele.tagName == 'BUTTON' || ele.hasAttribute('ng-click')) {
                  eleToActivate = ele;
                  break;
                }
                if (ele.classList.contains('button')) {
                  eleToActivate = ele;
                  break;
                }
                if (ele.tagName == 'ION-CONTENT' || (ele.classList && ele.classList.contains('pane')) || ele.tagName == 'BODY') {
                  break;
                }
                ele = ele.parentElement;
              }
              if (eleToActivate) {
                queueElements[keyId] = eleToActivate;
                ionic.requestAnimationFrame(activateElements);
                keyId = (keyId > 29 ? 0 : keyId + 1);
              }
            });
          },
          end: function() {
            setTimeout(clear, 200);
          }
        };
        function clear() {
          queueElements = {};
          ionic.requestAnimationFrame(deactivateElements);
        }
        function activateElements() {
          for (var key in queueElements) {
            if (queueElements[key]) {
              queueElements[key].classList.add(ACTIVATED_CLASS);
              activeElements[key] = queueElements[key];
            }
          }
          queueElements = {};
        }
        function deactivateElements() {
          if (ionic.transition && ionic.transition.isActive) {
            setTimeout(deactivateElements, 400);
            return ;
          }
          for (var key in activeElements) {
            if (activeElements[key]) {
              activeElements[key].classList.remove(ACTIVATED_CLASS);
              delete activeElements[key];
            }
          }
        }
      })(document, ionic);
      (function(ionic) {
        var nextId = 0;
        ionic.Utils = {
          arrayMove: function(arr, oldIndex, newIndex) {
            if (newIndex >= arr.length) {
              var k = newIndex - arr.length;
              while ((k--) + 1) {
                arr.push(undefined);
              }
            }
            arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);
            return arr;
          },
          proxy: function(func, context) {
            var args = Array.prototype.slice.call(arguments, 2);
            return function() {
              return func.apply(context, args.concat(Array.prototype.slice.call(arguments)));
            };
          },
          debounce: function(func, wait, immediate) {
            var timeout,
                args,
                context,
                timestamp,
                result;
            return function() {
              context = this;
              args = arguments;
              timestamp = new Date();
              var later = function() {
                var last = (new Date()) - timestamp;
                if (last < wait) {
                  timeout = setTimeout(later, wait - last);
                } else {
                  timeout = null;
                  if (!immediate)
                    result = func.apply(context, args);
                }
              };
              var callNow = immediate && !timeout;
              if (!timeout) {
                timeout = setTimeout(later, wait);
              }
              if (callNow)
                result = func.apply(context, args);
              return result;
            };
          },
          throttle: function(func, wait, options) {
            var context,
                args,
                result;
            var timeout = null;
            var previous = 0;
            options || (options = {});
            var later = function() {
              previous = options.leading === false ? 0 : Date.now();
              timeout = null;
              result = func.apply(context, args);
            };
            return function() {
              var now = Date.now();
              if (!previous && options.leading === false)
                previous = now;
              var remaining = wait - (now - previous);
              context = this;
              args = arguments;
              if (remaining <= 0) {
                clearTimeout(timeout);
                timeout = null;
                previous = now;
                result = func.apply(context, args);
              } else if (!timeout && options.trailing !== false) {
                timeout = setTimeout(later, remaining);
              }
              return result;
            };
          },
          inherit: function(protoProps, staticProps) {
            var parent = this;
            var child;
            if (protoProps && protoProps.hasOwnProperty('constructor')) {
              child = protoProps.constructor;
            } else {
              child = function() {
                return parent.apply(this, arguments);
              };
            }
            ionic.extend(child, parent, staticProps);
            var Surrogate = function() {
              this.constructor = child;
            };
            Surrogate.prototype = parent.prototype;
            child.prototype = new Surrogate();
            if (protoProps)
              ionic.extend(child.prototype, protoProps);
            child.__super__ = parent.prototype;
            return child;
          },
          extend: function(obj) {
            var args = Array.prototype.slice.call(arguments, 1);
            for (var i = 0; i < args.length; i++) {
              var source = args[i];
              if (source) {
                for (var prop in source) {
                  obj[prop] = source[prop];
                }
              }
            }
            return obj;
          },
          nextUid: function() {
            return 'ion' + (nextId++);
          },
          disconnectScope: function disconnectScope(scope) {
            if (!scope)
              return ;
            if (scope.$root === scope) {
              return ;
            }
            var parent = scope.$parent;
            scope.$$disconnected = true;
            scope.$broadcast('$ionic.disconnectScope', scope);
            if (parent.$$childHead === scope) {
              parent.$$childHead = scope.$$nextSibling;
            }
            if (parent.$$childTail === scope) {
              parent.$$childTail = scope.$$prevSibling;
            }
            if (scope.$$prevSibling) {
              scope.$$prevSibling.$$nextSibling = scope.$$nextSibling;
            }
            if (scope.$$nextSibling) {
              scope.$$nextSibling.$$prevSibling = scope.$$prevSibling;
            }
            scope.$$nextSibling = scope.$$prevSibling = null;
          },
          reconnectScope: function reconnectScope(scope) {
            if (!scope)
              return ;
            if (scope.$root === scope) {
              return ;
            }
            if (!scope.$$disconnected) {
              return ;
            }
            var parent = scope.$parent;
            scope.$$disconnected = false;
            scope.$broadcast('$ionic.reconnectScope', scope);
            scope.$$prevSibling = parent.$$childTail;
            if (parent.$$childHead) {
              parent.$$childTail.$$nextSibling = scope;
              parent.$$childTail = scope;
            } else {
              parent.$$childHead = parent.$$childTail = scope;
            }
          },
          isScopeDisconnected: function(scope) {
            var climbScope = scope;
            while (climbScope) {
              if (climbScope.$$disconnected)
                return true;
              climbScope = climbScope.$parent;
            }
            return false;
          }
        };
        ionic.inherit = ionic.Utils.inherit;
        ionic.extend = ionic.Utils.extend;
        ionic.throttle = ionic.Utils.throttle;
        ionic.proxy = ionic.Utils.proxy;
        ionic.debounce = ionic.Utils.debounce;
      })(window.ionic);
      var keyboardCurrentViewportHeight = 0;
      var keyboardPortraitViewportHeight = 0;
      var keyboardLandscapeViewportHeight = 0;
      var keyboardActiveElement;
      var scrollView;
      var waitForResizeTimer;
      var keyboardFocusOutTimer;
      var wasOrientationChange = false;
      var KEYBOARD_OPEN_CSS = 'keyboard-open';
      var SCROLL_CONTAINER_CSS = 'scroll-content';
      var debouncedKeyboardFocusIn = ionic.debounce(keyboardFocusIn, 200, true);
      var debouncedKeyboardNativeShow = ionic.debounce(keyboardNativeShow, 100, true);
      ionic.keyboard = {
        isOpen: false,
        isClosing: false,
        isOpening: false,
        height: 0,
        isLandscape: false,
        isInitialized: false,
        hide: function() {
          if (keyboardHasPlugin()) {
            cordova.plugins.Keyboard.close();
          }
          keyboardActiveElement && keyboardActiveElement.blur();
        },
        show: function() {
          if (keyboardHasPlugin()) {
            cordova.plugins.Keyboard.show();
          }
        },
        disable: function() {
          if (keyboardHasPlugin()) {
            window.removeEventListener('native.keyboardshow', debouncedKeyboardNativeShow);
            window.removeEventListener('native.keyboardhide', keyboardFocusOut);
          } else {
            document.body.removeEventListener('focusout', keyboardFocusOut);
          }
          document.body.removeEventListener('ionic.focusin', debouncedKeyboardFocusIn);
          document.body.removeEventListener('focusin', debouncedKeyboardFocusIn);
          window.removeEventListener('orientationchange', keyboardOrientationChange);
          if (window.navigator.msPointerEnabled) {
            document.removeEventListener("MSPointerDown", keyboardInit);
          } else {
            document.removeEventListener('touchstart', keyboardInit);
          }
          ionic.keyboard.isInitialized = false;
        },
        enable: function() {
          keyboardInit();
        }
      };
      keyboardCurrentViewportHeight = getViewportHeight();
      function keyboardInit() {
        if (ionic.keyboard.isInitialized)
          return ;
        if (keyboardHasPlugin()) {
          window.addEventListener('native.keyboardshow', debouncedKeyboardNativeShow);
          window.addEventListener('native.keyboardhide', keyboardFocusOut);
        } else {
          document.body.addEventListener('focusout', keyboardFocusOut);
        }
        document.body.addEventListener('ionic.focusin', debouncedKeyboardFocusIn);
        document.body.addEventListener('focusin', debouncedKeyboardFocusIn);
        if (window.navigator.msPointerEnabled) {
          document.removeEventListener("MSPointerDown", keyboardInit);
        } else {
          document.removeEventListener('touchstart', keyboardInit);
        }
        ionic.keyboard.isInitialized = true;
      }
      function keyboardNativeShow(e) {
        clearTimeout(keyboardFocusOutTimer);
        if (!ionic.keyboard.isOpen || ionic.keyboard.isClosing) {
          ionic.keyboard.isOpening = true;
          ionic.keyboard.isClosing = false;
        }
        ionic.keyboard.height = e.keyboardHeight;
        if (wasOrientationChange) {
          keyboardWaitForResize(keyboardUpdateViewportHeight, true);
        } else {
          keyboardWaitForResize(keyboardShow, true);
        }
      }
      function keyboardFocusIn(e) {
        clearTimeout(keyboardFocusOutTimer);
        if (!e.target || e.target.readOnly || !ionic.tap.isKeyboardElement(e.target) || !(scrollView = ionic.DomUtil.getParentWithClass(e.target, SCROLL_CONTAINER_CSS))) {
          keyboardActiveElement = null;
          return ;
        }
        keyboardActiveElement = e.target;
        if (!scrollView.classList.contains("overflow-scroll")) {
          document.body.scrollTop = 0;
          scrollView.scrollTop = 0;
          ionic.requestAnimationFrame(function() {
            document.body.scrollTop = 0;
            scrollView.scrollTop = 0;
          });
          if (window.navigator.msPointerEnabled) {
            document.addEventListener("MSPointerMove", keyboardPreventDefault, false);
          } else {
            document.addEventListener('touchmove', keyboardPreventDefault, false);
          }
        }
        if (!ionic.keyboard.isOpen || ionic.keyboard.isClosing) {
          ionic.keyboard.isOpening = true;
          ionic.keyboard.isClosing = false;
        }
        document.addEventListener('keydown', keyboardOnKeyDown, false);
        if (!ionic.keyboard.isOpen && !keyboardHasPlugin()) {
          keyboardWaitForResize(keyboardShow, true);
        } else if (ionic.keyboard.isOpen) {
          keyboardShow();
        }
      }
      function keyboardFocusOut() {
        clearTimeout(keyboardFocusOutTimer);
        if (ionic.keyboard.isOpen || ionic.keyboard.isOpening) {
          ionic.keyboard.isClosing = true;
          ionic.keyboard.isOpening = false;
        }
        keyboardFocusOutTimer = setTimeout(function() {
          ionic.requestAnimationFrame(function() {
            if (wasOrientationChange) {
              keyboardWaitForResize(function() {
                keyboardUpdateViewportHeight();
                keyboardHide();
              }, false);
            } else {
              keyboardWaitForResize(keyboardHide, false);
            }
          });
        }, 50);
      }
      function keyboardOrientationChange() {
        ionic.keyboard.isLandscape = !ionic.keyboard.isLandscape;
        if (ionic.Platform.isIOS()) {
          keyboardUpdateViewportHeight();
        }
        if (ionic.Platform.isAndroid()) {
          if (!ionic.keyboard.isOpen || !keyboardHasPlugin()) {
            keyboardWaitForResize(keyboardUpdateViewportHeight, false);
          } else {
            wasOrientationChange = true;
          }
        }
      }
      function keyboardOnKeyDown(e) {
        if (ionic.scroll.isScrolling) {
          keyboardPreventDefault(e);
        }
      }
      function keyboardPreventDefault(e) {
        if (e.target.tagName !== 'TEXTAREA') {
          e.preventDefault();
        }
      }
      function keyboardWaitForResize(callback, isOpening) {
        clearInterval(waitForResizeTimer);
        var count = 0;
        var maxCount;
        var initialHeight = getViewportHeight();
        var viewportHeight = initialHeight;
        if (ionic.Platform.isAndroid() && ionic.Platform.version() < 4.4) {
          maxCount = 30;
        } else if (ionic.Platform.isAndroid()) {
          maxCount = 10;
        } else {
          maxCount = 1;
        }
        waitForResizeTimer = setInterval(function() {
          viewportHeight = getViewportHeight();
          if (++count < maxCount && ((!isPortraitViewportHeight(viewportHeight) && !isLandscapeViewportHeight(viewportHeight)) || !ionic.keyboard.height)) {
            return ;
          }
          if (!keyboardHasPlugin()) {
            ionic.keyboard.height = Math.abs(initialHeight - window.innerHeight);
          }
          ionic.keyboard.isOpen = isOpening;
          clearInterval(waitForResizeTimer);
          callback();
        }, 50);
        return maxCount;
      }
      function keyboardHide() {
        clearTimeout(keyboardFocusOutTimer);
        ionic.keyboard.isOpen = false;
        ionic.keyboard.isClosing = false;
        if (keyboardActiveElement) {
          ionic.trigger('resetScrollView', {target: keyboardActiveElement}, true);
        }
        ionic.requestAnimationFrame(function() {
          document.body.classList.remove(KEYBOARD_OPEN_CSS);
        });
        if (window.navigator.msPointerEnabled) {
          document.removeEventListener("MSPointerMove", keyboardPreventDefault);
        } else {
          document.removeEventListener('touchmove', keyboardPreventDefault);
        }
        document.removeEventListener('keydown', keyboardOnKeyDown);
        if (ionic.Platform.isAndroid()) {
          if (keyboardHasPlugin())
            cordova.plugins.Keyboard.close();
          keyboardActiveElement && keyboardActiveElement.blur();
        }
        keyboardActiveElement = null;
      }
      function keyboardShow() {
        ionic.keyboard.isOpen = true;
        ionic.keyboard.isOpening = false;
        var details = {
          keyboardHeight: keyboardGetHeight(),
          viewportHeight: keyboardCurrentViewportHeight
        };
        if (keyboardActiveElement) {
          details.target = keyboardActiveElement;
          var elementBounds = keyboardActiveElement.getBoundingClientRect();
          details.elementTop = Math.round(elementBounds.top);
          details.elementBottom = Math.round(elementBounds.bottom);
          details.windowHeight = details.viewportHeight - details.keyboardHeight;
          details.isElementUnderKeyboard = (details.elementBottom > details.windowHeight);
          ionic.trigger('scrollChildIntoView', details, true);
        }
        setTimeout(function() {
          document.body.classList.add(KEYBOARD_OPEN_CSS);
        }, 400);
        return details;
      }
      function keyboardGetHeight() {
        if (ionic.keyboard.height) {
          return ionic.keyboard.height;
        }
        if (ionic.Platform.isAndroid()) {
          if (ionic.Platform.isFullScreen) {
            return 275;
          }
          var contentHeight = window.innerHeight;
          if (contentHeight < keyboardCurrentViewportHeight) {
            return keyboardCurrentViewportHeight - contentHeight;
          } else {
            return 0;
          }
        }
        if (ionic.Platform.isIOS()) {
          if (ionic.keyboard.isLandscape) {
            return 206;
          }
          if (!ionic.Platform.isWebView()) {
            return 216;
          }
          return 260;
        }
        return 275;
      }
      function isPortraitViewportHeight(viewportHeight) {
        return !!(!ionic.keyboard.isLandscape && keyboardPortraitViewportHeight && (Math.abs(keyboardPortraitViewportHeight - viewportHeight) < 2));
      }
      function isLandscapeViewportHeight(viewportHeight) {
        return !!(ionic.keyboard.isLandscape && keyboardLandscapeViewportHeight && (Math.abs(keyboardLandscapeViewportHeight - viewportHeight) < 2));
      }
      function keyboardUpdateViewportHeight() {
        wasOrientationChange = false;
        keyboardCurrentViewportHeight = getViewportHeight();
        if (ionic.keyboard.isLandscape && !keyboardLandscapeViewportHeight) {
          keyboardLandscapeViewportHeight = keyboardCurrentViewportHeight;
        } else if (!ionic.keyboard.isLandscape && !keyboardPortraitViewportHeight) {
          keyboardPortraitViewportHeight = keyboardCurrentViewportHeight;
        }
        if (keyboardActiveElement) {
          ionic.trigger('resetScrollView', {target: keyboardActiveElement}, true);
        }
        if (ionic.keyboard.isOpen && ionic.tap.isTextInput(keyboardActiveElement)) {
          keyboardShow();
        }
      }
      function keyboardInitViewportHeight() {
        var viewportHeight = getViewportHeight();
        if ((viewportHeight / window.innerWidth) < 1) {
          ionic.keyboard.isLandscape = true;
        }
        keyboardCurrentViewportHeight = viewportHeight;
        if (ionic.keyboard.isLandscape && !keyboardLandscapeViewportHeight) {
          keyboardLandscapeViewportHeight = keyboardCurrentViewportHeight;
        } else if (!ionic.keyboard.isLandscape && !keyboardPortraitViewportHeight) {
          keyboardPortraitViewportHeight = keyboardCurrentViewportHeight;
        }
      }
      function getViewportHeight() {
        var windowHeight = window.innerHeight;
        if (!(ionic.Platform.isAndroid() && ionic.Platform.isFullScreen) && (ionic.keyboard.isOpen || ionic.keyboard.isOpening) && !ionic.keyboard.isClosing) {
          return windowHeight + keyboardGetHeight();
        }
        return windowHeight;
      }
      function keyboardHasPlugin() {
        return !!(window.cordova && cordova.plugins && cordova.plugins.Keyboard);
      }
      ionic.Platform.ready(function() {
        keyboardInitViewportHeight();
        window.addEventListener('orientationchange', keyboardOrientationChange);
        setTimeout(keyboardInitViewportHeight, 999);
        if (window.navigator.msPointerEnabled) {
          document.addEventListener("MSPointerDown", keyboardInit, false);
        } else {
          document.addEventListener('touchstart', keyboardInit, false);
        }
      });
      var viewportTag;
      var viewportProperties = {};
      ionic.viewport = {orientation: function() {
          return (window.innerWidth > window.innerHeight ? 90 : 0);
        }};
      function viewportLoadTag() {
        var x;
        for (x = 0; x < document.head.children.length; x++) {
          if (document.head.children[x].name == 'viewport') {
            viewportTag = document.head.children[x];
            break;
          }
        }
        if (viewportTag) {
          var props = viewportTag.content.toLowerCase().replace(/\s+/g, '').split(',');
          var keyValue;
          for (x = 0; x < props.length; x++) {
            if (props[x]) {
              keyValue = props[x].split('=');
              viewportProperties[keyValue[0]] = (keyValue.length > 1 ? keyValue[1] : '_');
            }
          }
          viewportUpdate();
        }
      }
      function viewportUpdate() {
        var initWidth = viewportProperties.width;
        var initHeight = viewportProperties.height;
        var p = ionic.Platform;
        var version = p.version();
        var DEVICE_WIDTH = 'device-width';
        var DEVICE_HEIGHT = 'device-height';
        var orientation = ionic.viewport.orientation();
        delete viewportProperties.height;
        viewportProperties.width = DEVICE_WIDTH;
        if (p.isIPad()) {
          if (version > 7) {
            delete viewportProperties.width;
          } else {
            if (p.isWebView()) {
              if (orientation == 90) {
                viewportProperties.height = '0';
              } else if (version == 7) {
                viewportProperties.height = DEVICE_HEIGHT;
              }
            } else {
              if (version < 7) {
                viewportProperties.height = '0';
              }
            }
          }
        } else if (p.isIOS()) {
          if (p.isWebView()) {
            if (version > 7) {
              delete viewportProperties.width;
            } else if (version < 7) {
              if (initHeight)
                viewportProperties.height = '0';
            } else if (version == 7) {
              viewportProperties.height = DEVICE_HEIGHT;
            }
          } else {
            if (version < 7) {
              if (initHeight)
                viewportProperties.height = '0';
            }
          }
        }
        if (initWidth !== viewportProperties.width || initHeight !== viewportProperties.height) {
          viewportTagUpdate();
        }
      }
      function viewportTagUpdate() {
        var key,
            props = [];
        for (key in viewportProperties) {
          if (viewportProperties[key]) {
            props.push(key + (viewportProperties[key] == '_' ? '' : '=' + viewportProperties[key]));
          }
        }
        viewportTag.content = props.join(', ');
      }
      ionic.Platform.ready(function() {
        viewportLoadTag();
        window.addEventListener("orientationchange", function() {
          setTimeout(viewportUpdate, 1000);
        }, false);
      });
      (function(ionic) {
        'use strict';
        ionic.views.View = function() {
          this.initialize.apply(this, arguments);
        };
        ionic.views.View.inherit = ionic.inherit;
        ionic.extend(ionic.views.View.prototype, {initialize: function() {}});
      })(window.ionic);
      var zyngaCore = {effect: {}};
      (function(global) {
        var time = Date.now || function() {
          return +new Date();
        };
        var desiredFrames = 60;
        var millisecondsPerSecond = 1000;
        var running = {};
        var counter = 1;
        zyngaCore.effect.Animate = {
          requestAnimationFrame: (function() {
            var requestFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame;
            var isNative = !!requestFrame;
            if (requestFrame && !/requestAnimationFrame\(\)\s*\{\s*\[native code\]\s*\}/i.test(requestFrame.toString())) {
              isNative = false;
            }
            if (isNative) {
              return function(callback, root) {
                requestFrame(callback, root);
              };
            }
            var TARGET_FPS = 60;
            var requests = {};
            var requestCount = 0;
            var rafHandle = 1;
            var intervalHandle = null;
            var lastActive = +new Date();
            return function(callback) {
              var callbackHandle = rafHandle++;
              requests[callbackHandle] = callback;
              requestCount++;
              if (intervalHandle === null) {
                intervalHandle = setInterval(function() {
                  var time = +new Date();
                  var currentRequests = requests;
                  requests = {};
                  requestCount = 0;
                  for (var key in currentRequests) {
                    if (currentRequests.hasOwnProperty(key)) {
                      currentRequests[key](time);
                      lastActive = time;
                    }
                  }
                  if (time - lastActive > 2500) {
                    clearInterval(intervalHandle);
                    intervalHandle = null;
                  }
                }, 1000 / TARGET_FPS);
              }
              return callbackHandle;
            };
          })(),
          stop: function(id) {
            var cleared = running[id] != null;
            if (cleared) {
              running[id] = null;
            }
            return cleared;
          },
          isRunning: function(id) {
            return running[id] != null;
          },
          start: function(stepCallback, verifyCallback, completedCallback, duration, easingMethod, root) {
            var start = time();
            var lastFrame = start;
            var percent = 0;
            var dropCounter = 0;
            var id = counter++;
            if (!root) {
              root = document.body;
            }
            if (id % 20 === 0) {
              var newRunning = {};
              for (var usedId in running) {
                newRunning[usedId] = true;
              }
              running = newRunning;
            }
            var step = function(virtual) {
              var render = virtual !== true;
              var now = time();
              if (!running[id] || (verifyCallback && !verifyCallback(id))) {
                running[id] = null;
                completedCallback && completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, false);
                return ;
              }
              if (render) {
                var droppedFrames = Math.round((now - lastFrame) / (millisecondsPerSecond / desiredFrames)) - 1;
                for (var j = 0; j < Math.min(droppedFrames, 4); j++) {
                  step(true);
                  dropCounter++;
                }
              }
              if (duration) {
                percent = (now - start) / duration;
                if (percent > 1) {
                  percent = 1;
                }
              }
              var value = easingMethod ? easingMethod(percent) : percent;
              if ((stepCallback(value, now, render) === false || percent === 1) && render) {
                running[id] = null;
                completedCallback && completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, percent === 1 || duration == null);
              } else if (render) {
                lastFrame = now;
                zyngaCore.effect.Animate.requestAnimationFrame(step, root);
              }
            };
            running[id] = true;
            zyngaCore.effect.Animate.requestAnimationFrame(step, root);
            return id;
          }
        };
      })(this);
      (function(ionic) {
        var NOOP = function() {};
        var easeOutCubic = function(pos) {
          return (Math.pow((pos - 1), 3) + 1);
        };
        var easeInOutCubic = function(pos) {
          if ((pos /= 0.5) < 1) {
            return 0.5 * Math.pow(pos, 3);
          }
          return 0.5 * (Math.pow((pos - 2), 3) + 2);
        };
        ionic.views.Scroll = ionic.views.View.inherit({
          initialize: function(options) {
            var self = this;
            self.__container = options.el;
            self.__content = options.el.firstElementChild;
            setTimeout(function() {
              if (self.__container && self.__content) {
                self.__container.scrollTop = 0;
                self.__content.scrollTop = 0;
              }
            });
            self.options = {
              scrollingX: false,
              scrollbarX: true,
              scrollingY: true,
              scrollbarY: true,
              startX: 0,
              startY: 0,
              wheelDampen: 6,
              minScrollbarSizeX: 5,
              minScrollbarSizeY: 5,
              scrollbarsFade: true,
              scrollbarFadeDelay: 300,
              scrollbarResizeFadeDelay: 1000,
              animating: true,
              animationDuration: 250,
              decelVelocityThreshold: 4,
              decelVelocityThresholdPaging: 4,
              bouncing: true,
              locking: true,
              paging: false,
              snapping: false,
              zooming: false,
              minZoom: 0.5,
              maxZoom: 3,
              speedMultiplier: 1,
              deceleration: 0.97,
              preventDefault: false,
              scrollingComplete: NOOP,
              penetrationDeceleration: 0.03,
              penetrationAcceleration: 0.08,
              scrollEventInterval: 10,
              freeze: false,
              getContentWidth: function() {
                return Math.max(self.__content.scrollWidth, self.__content.offsetWidth);
              },
              getContentHeight: function() {
                return Math.max(self.__content.scrollHeight, self.__content.offsetHeight + (self.__content.offsetTop * 2));
              }
            };
            for (var key in options) {
              self.options[key] = options[key];
            }
            self.hintResize = ionic.debounce(function() {
              self.resize();
            }, 1000, true);
            self.onScroll = function() {
              if (!ionic.scroll.isScrolling) {
                setTimeout(self.setScrollStart, 50);
              } else {
                clearTimeout(self.scrollTimer);
                self.scrollTimer = setTimeout(self.setScrollStop, 80);
              }
            };
            self.freeze = function(shouldFreeze) {
              if (arguments.length) {
                self.options.freeze = shouldFreeze;
              }
              return self.options.freeze;
            };
            self.setScrollStart = function() {
              ionic.scroll.isScrolling = Math.abs(ionic.scroll.lastTop - self.__scrollTop) > 1;
              clearTimeout(self.scrollTimer);
              self.scrollTimer = setTimeout(self.setScrollStop, 80);
            };
            self.setScrollStop = function() {
              ionic.scroll.isScrolling = false;
              ionic.scroll.lastTop = self.__scrollTop;
            };
            self.triggerScrollEvent = ionic.throttle(function() {
              self.onScroll();
              ionic.trigger('scroll', {
                scrollTop: self.__scrollTop,
                scrollLeft: self.__scrollLeft,
                target: self.__container
              });
            }, self.options.scrollEventInterval);
            self.triggerScrollEndEvent = function() {
              ionic.trigger('scrollend', {
                scrollTop: self.__scrollTop,
                scrollLeft: self.__scrollLeft,
                target: self.__container
              });
            };
            self.__scrollLeft = self.options.startX;
            self.__scrollTop = self.options.startY;
            self.__callback = self.getRenderFn();
            self.__initEventHandlers();
            self.__createScrollbars();
          },
          run: function() {
            this.resize();
            this.__fadeScrollbars('out', this.options.scrollbarResizeFadeDelay);
          },
          __isSingleTouch: false,
          __isTracking: false,
          __didDecelerationComplete: false,
          __isGesturing: false,
          __isDragging: false,
          __isDecelerating: false,
          __isAnimating: false,
          __clientLeft: 0,
          __clientTop: 0,
          __clientWidth: 0,
          __clientHeight: 0,
          __contentWidth: 0,
          __contentHeight: 0,
          __snapWidth: 100,
          __snapHeight: 100,
          __refreshHeight: null,
          __refreshActive: false,
          __refreshActivate: null,
          __refreshDeactivate: null,
          __refreshStart: null,
          __zoomLevel: 1,
          __scrollLeft: 0,
          __scrollTop: 0,
          __maxScrollLeft: 0,
          __maxScrollTop: 0,
          __scheduledLeft: 0,
          __scheduledTop: 0,
          __scheduledZoom: 0,
          __lastTouchLeft: null,
          __lastTouchTop: null,
          __lastTouchMove: null,
          __positions: null,
          __minDecelerationScrollLeft: null,
          __minDecelerationScrollTop: null,
          __maxDecelerationScrollLeft: null,
          __maxDecelerationScrollTop: null,
          __decelerationVelocityX: null,
          __decelerationVelocityY: null,
          __transformProperty: null,
          __perspectiveProperty: null,
          __indicatorX: null,
          __indicatorY: null,
          __scrollbarFadeTimeout: null,
          __didWaitForSize: null,
          __sizerTimeout: null,
          __initEventHandlers: function() {
            var self = this;
            var container = self.__container;
            var scrollViewOffsetHeight;
            self.scrollChildIntoView = function(e) {
              var scrollBottomOffsetToTop = container.getBoundingClientRect().bottom;
              scrollViewOffsetHeight = container.offsetHeight;
              var alreadyShrunk = self.isShrunkForKeyboard;
              var isModal = container.parentNode.classList.contains('modal');
              var isInsetModal = isModal && window.innerWidth >= 680;
              if (!alreadyShrunk) {
                if (ionic.Platform.isIOS() || ionic.Platform.isFullScreen || isInsetModal) {
                  var scrollBottomOffsetToBottom = e.detail.viewportHeight - scrollBottomOffsetToTop;
                  var keyboardOffset = Math.max(0, e.detail.keyboardHeight - scrollBottomOffsetToBottom);
                  ionic.requestAnimationFrame(function() {
                    scrollViewOffsetHeight = scrollViewOffsetHeight - keyboardOffset;
                    container.style.height = scrollViewOffsetHeight + "px";
                    container.style.overflow = "visible";
                    self.resize();
                  });
                }
                self.isShrunkForKeyboard = true;
              }
              if (e.detail.isElementUnderKeyboard) {
                ionic.requestAnimationFrame(function() {
                  container.scrollTop = 0;
                  if (self.isShrunkForKeyboard && !alreadyShrunk) {
                    scrollBottomOffsetToTop = container.getBoundingClientRect().bottom;
                  }
                  var scrollMidpointOffset = scrollViewOffsetHeight * 0.5;
                  var inputMidpoint = ((e.detail.elementBottom + e.detail.elementTop) / 2);
                  var inputMidpointOffsetToScrollBottom = inputMidpoint - scrollBottomOffsetToTop;
                  var scrollTop = inputMidpointOffsetToScrollBottom + scrollMidpointOffset;
                  if (scrollTop > 0) {
                    if (ionic.Platform.isIOS())
                      ionic.tap.cloneFocusedInput(container, self);
                    self.scrollBy(0, scrollTop, true);
                    self.onScroll();
                  }
                });
              }
              e.stopPropagation();
            };
            self.resetScrollView = function() {
              if (self.isShrunkForKeyboard) {
                self.isShrunkForKeyboard = false;
                container.style.height = "";
                container.style.overflow = "";
              }
              self.resize();
            };
            container.addEventListener('scrollChildIntoView', self.scrollChildIntoView);
            document.addEventListener('resetScrollView', self.resetScrollView);
            function getEventTouches(e) {
              return e.touches && e.touches.length ? e.touches : [{
                pageX: e.pageX,
                pageY: e.pageY
              }];
            }
            self.touchStart = function(e) {
              self.startCoordinates = ionic.tap.pointerCoord(e);
              if (ionic.tap.ignoreScrollStart(e)) {
                return ;
              }
              self.__isDown = true;
              if (ionic.tap.containsOrIsTextInput(e.target) || e.target.tagName === 'SELECT') {
                self.__hasStarted = false;
                return ;
              }
              self.__isSelectable = true;
              self.__enableScrollY = true;
              self.__hasStarted = true;
              self.doTouchStart(getEventTouches(e), e.timeStamp);
              e.preventDefault();
            };
            self.touchMove = function(e) {
              if (self.options.freeze || !self.__isDown || (!self.__isDown && e.defaultPrevented) || (e.target.tagName === 'TEXTAREA' && e.target.parentElement.querySelector(':focus'))) {
                return ;
              }
              if (!self.__hasStarted && (ionic.tap.containsOrIsTextInput(e.target) || e.target.tagName === 'SELECT')) {
                self.__hasStarted = true;
                self.doTouchStart(getEventTouches(e), e.timeStamp);
                e.preventDefault();
                return ;
              }
              if (self.startCoordinates) {
                var currentCoordinates = ionic.tap.pointerCoord(e);
                if (self.__isSelectable && ionic.tap.isTextInput(e.target) && Math.abs(self.startCoordinates.x - currentCoordinates.x) > 20) {
                  self.__enableScrollY = false;
                  self.__isSelectable = true;
                }
                if (self.__enableScrollY && Math.abs(self.startCoordinates.y - currentCoordinates.y) > 10) {
                  self.__isSelectable = false;
                  ionic.tap.cloneFocusedInput(container, self);
                }
              }
              self.doTouchMove(getEventTouches(e), e.timeStamp, e.scale);
              self.__isDown = true;
            };
            self.touchMoveBubble = function(e) {
              if (self.__isDown && self.options.preventDefault) {
                e.preventDefault();
              }
            };
            self.touchEnd = function(e) {
              if (!self.__isDown)
                return ;
              self.doTouchEnd(e, e.timeStamp);
              self.__isDown = false;
              self.__hasStarted = false;
              self.__isSelectable = true;
              self.__enableScrollY = true;
              if (!self.__isDragging && !self.__isDecelerating && !self.__isAnimating) {
                ionic.tap.removeClonedInputs(container, self);
              }
            };
            self.mouseWheel = ionic.animationFrameThrottle(function(e) {
              var scrollParent = ionic.DomUtil.getParentOrSelfWithClass(e.target, 'ionic-scroll');
              if (!self.options.freeze && scrollParent === self.__container) {
                self.hintResize();
                self.scrollBy((e.wheelDeltaX || e.deltaX || 0) / self.options.wheelDampen, (-e.wheelDeltaY || e.deltaY || 0) / self.options.wheelDampen);
                self.__fadeScrollbars('in');
                clearTimeout(self.__wheelHideBarTimeout);
                self.__wheelHideBarTimeout = setTimeout(function() {
                  self.__fadeScrollbars('out');
                }, 100);
              }
            });
            if ('ontouchstart' in window) {
              container.addEventListener("touchstart", self.touchStart, false);
              if (self.options.preventDefault)
                container.addEventListener("touchmove", self.touchMoveBubble, false);
              document.addEventListener("touchmove", self.touchMove, false);
              document.addEventListener("touchend", self.touchEnd, false);
              document.addEventListener("touchcancel", self.touchEnd, false);
            } else if (window.navigator.pointerEnabled) {
              container.addEventListener("pointerdown", self.touchStart, false);
              if (self.options.preventDefault)
                container.addEventListener("pointermove", self.touchMoveBubble, false);
              document.addEventListener("pointermove", self.touchMove, false);
              document.addEventListener("pointerup", self.touchEnd, false);
              document.addEventListener("pointercancel", self.touchEnd, false);
              document.addEventListener("wheel", self.mouseWheel, false);
            } else if (window.navigator.msPointerEnabled) {
              container.addEventListener("MSPointerDown", self.touchStart, false);
              if (self.options.preventDefault)
                container.addEventListener("MSPointerMove", self.touchMoveBubble, false);
              document.addEventListener("MSPointerMove", self.touchMove, false);
              document.addEventListener("MSPointerUp", self.touchEnd, false);
              document.addEventListener("MSPointerCancel", self.touchEnd, false);
              document.addEventListener("wheel", self.mouseWheel, false);
            } else {
              var mousedown = false;
              self.mouseDown = function(e) {
                if (ionic.tap.ignoreScrollStart(e) || e.target.tagName === 'SELECT') {
                  return ;
                }
                self.doTouchStart(getEventTouches(e), e.timeStamp);
                if (!ionic.tap.isTextInput(e.target)) {
                  e.preventDefault();
                }
                mousedown = true;
              };
              self.mouseMove = function(e) {
                if (self.options.freeze || !mousedown || (!mousedown && e.defaultPrevented)) {
                  return ;
                }
                self.doTouchMove(getEventTouches(e), e.timeStamp);
                mousedown = true;
              };
              self.mouseMoveBubble = function(e) {
                if (mousedown && self.options.preventDefault) {
                  e.preventDefault();
                }
              };
              self.mouseUp = function(e) {
                if (!mousedown) {
                  return ;
                }
                self.doTouchEnd(e, e.timeStamp);
                mousedown = false;
              };
              container.addEventListener("mousedown", self.mouseDown, false);
              if (self.options.preventDefault)
                container.addEventListener("mousemove", self.mouseMoveBubble, false);
              document.addEventListener("mousemove", self.mouseMove, false);
              document.addEventListener("mouseup", self.mouseUp, false);
              document.addEventListener('mousewheel', self.mouseWheel, false);
              document.addEventListener('wheel', self.mouseWheel, false);
            }
          },
          __cleanup: function() {
            var self = this;
            var container = self.__container;
            container.removeEventListener('touchstart', self.touchStart);
            container.removeEventListener('touchmove', self.touchMoveBubble);
            document.removeEventListener('touchmove', self.touchMove);
            document.removeEventListener('touchend', self.touchEnd);
            document.removeEventListener('touchcancel', self.touchEnd);
            container.removeEventListener("pointerdown", self.touchStart);
            container.removeEventListener("pointermove", self.touchMoveBubble);
            document.removeEventListener("pointermove", self.touchMove);
            document.removeEventListener("pointerup", self.touchEnd);
            document.removeEventListener("pointercancel", self.touchEnd);
            container.removeEventListener("MSPointerDown", self.touchStart);
            container.removeEventListener("MSPointerMove", self.touchMoveBubble);
            document.removeEventListener("MSPointerMove", self.touchMove);
            document.removeEventListener("MSPointerUp", self.touchEnd);
            document.removeEventListener("MSPointerCancel", self.touchEnd);
            container.removeEventListener("mousedown", self.mouseDown);
            container.removeEventListener("mousemove", self.mouseMoveBubble);
            document.removeEventListener("mousemove", self.mouseMove);
            document.removeEventListener("mouseup", self.mouseUp);
            document.removeEventListener('mousewheel', self.mouseWheel);
            document.removeEventListener('wheel', self.mouseWheel);
            container.removeEventListener('scrollChildIntoView', self.scrollChildIntoView);
            document.removeEventListener('resetScrollView', self.resetScrollView);
            ionic.tap.removeClonedInputs(container, self);
            delete self.__container;
            delete self.__content;
            delete self.__indicatorX;
            delete self.__indicatorY;
            delete self.options.el;
            self.__callback = self.scrollChildIntoView = self.resetScrollView = NOOP;
            self.mouseMove = self.mouseDown = self.mouseUp = self.mouseWheel = self.touchStart = self.touchMove = self.touchEnd = self.touchCancel = NOOP;
            self.resize = self.scrollTo = self.zoomTo = self.__scrollingComplete = NOOP;
            container = null;
          },
          __createScrollbar: function(direction) {
            var bar = document.createElement('div'),
                indicator = document.createElement('div');
            indicator.className = 'scroll-bar-indicator scroll-bar-fade-out';
            if (direction == 'h') {
              bar.className = 'scroll-bar scroll-bar-h';
            } else {
              bar.className = 'scroll-bar scroll-bar-v';
            }
            bar.appendChild(indicator);
            return bar;
          },
          __createScrollbars: function() {
            var self = this;
            var indicatorX,
                indicatorY;
            if (self.options.scrollingX) {
              indicatorX = {
                el: self.__createScrollbar('h'),
                sizeRatio: 1
              };
              indicatorX.indicator = indicatorX.el.children[0];
              if (self.options.scrollbarX) {
                self.__container.appendChild(indicatorX.el);
              }
              self.__indicatorX = indicatorX;
            }
            if (self.options.scrollingY) {
              indicatorY = {
                el: self.__createScrollbar('v'),
                sizeRatio: 1
              };
              indicatorY.indicator = indicatorY.el.children[0];
              if (self.options.scrollbarY) {
                self.__container.appendChild(indicatorY.el);
              }
              self.__indicatorY = indicatorY;
            }
          },
          __resizeScrollbars: function() {
            var self = this;
            if (self.__indicatorX) {
              var width = Math.max(Math.round(self.__clientWidth * self.__clientWidth / (self.__contentWidth)), 20);
              if (width > self.__contentWidth) {
                width = 0;
              }
              if (width !== self.__indicatorX.size) {
                ionic.requestAnimationFrame(function() {
                  self.__indicatorX.indicator.style.width = width + 'px';
                });
              }
              self.__indicatorX.size = width;
              self.__indicatorX.minScale = self.options.minScrollbarSizeX / width;
              self.__indicatorX.maxPos = self.__clientWidth - width;
              self.__indicatorX.sizeRatio = self.__maxScrollLeft ? self.__indicatorX.maxPos / self.__maxScrollLeft : 1;
            }
            if (self.__indicatorY) {
              var height = Math.max(Math.round(self.__clientHeight * self.__clientHeight / (self.__contentHeight)), 20);
              if (height > self.__contentHeight) {
                height = 0;
              }
              if (height !== self.__indicatorY.size) {
                ionic.requestAnimationFrame(function() {
                  self.__indicatorY && (self.__indicatorY.indicator.style.height = height + 'px');
                });
              }
              self.__indicatorY.size = height;
              self.__indicatorY.minScale = self.options.minScrollbarSizeY / height;
              self.__indicatorY.maxPos = self.__clientHeight - height;
              self.__indicatorY.sizeRatio = self.__maxScrollTop ? self.__indicatorY.maxPos / self.__maxScrollTop : 1;
            }
          },
          __repositionScrollbars: function() {
            var self = this,
                heightScale,
                widthScale,
                widthDiff,
                heightDiff,
                x,
                y,
                xstop = 0,
                ystop = 0;
            if (self.__indicatorX) {
              if (self.__indicatorY)
                xstop = 10;
              x = Math.round(self.__indicatorX.sizeRatio * self.__scrollLeft) || 0;
              widthDiff = self.__scrollLeft - (self.__maxScrollLeft - xstop);
              if (self.__scrollLeft < 0) {
                widthScale = Math.max(self.__indicatorX.minScale, (self.__indicatorX.size - Math.abs(self.__scrollLeft)) / self.__indicatorX.size);
                x = 0;
                self.__indicatorX.indicator.style[self.__transformOriginProperty] = 'left center';
              } else if (widthDiff > 0) {
                widthScale = Math.max(self.__indicatorX.minScale, (self.__indicatorX.size - widthDiff) / self.__indicatorX.size);
                x = self.__indicatorX.maxPos - xstop;
                self.__indicatorX.indicator.style[self.__transformOriginProperty] = 'right center';
              } else {
                x = Math.min(self.__maxScrollLeft, Math.max(0, x));
                widthScale = 1;
              }
              var translate3dX = 'translate3d(' + x + 'px, 0, 0) scaleX(' + widthScale + ')';
              if (self.__indicatorX.transformProp !== translate3dX) {
                self.__indicatorX.indicator.style[self.__transformProperty] = translate3dX;
                self.__indicatorX.transformProp = translate3dX;
              }
            }
            if (self.__indicatorY) {
              y = Math.round(self.__indicatorY.sizeRatio * self.__scrollTop) || 0;
              if (self.__indicatorX)
                ystop = 10;
              heightDiff = self.__scrollTop - (self.__maxScrollTop - ystop);
              if (self.__scrollTop < 0) {
                heightScale = Math.max(self.__indicatorY.minScale, (self.__indicatorY.size - Math.abs(self.__scrollTop)) / self.__indicatorY.size);
                y = 0;
                if (self.__indicatorY.originProp !== 'center top') {
                  self.__indicatorY.indicator.style[self.__transformOriginProperty] = 'center top';
                  self.__indicatorY.originProp = 'center top';
                }
              } else if (heightDiff > 0) {
                heightScale = Math.max(self.__indicatorY.minScale, (self.__indicatorY.size - heightDiff) / self.__indicatorY.size);
                y = self.__indicatorY.maxPos - ystop;
                if (self.__indicatorY.originProp !== 'center bottom') {
                  self.__indicatorY.indicator.style[self.__transformOriginProperty] = 'center bottom';
                  self.__indicatorY.originProp = 'center bottom';
                }
              } else {
                y = Math.min(self.__maxScrollTop, Math.max(0, y));
                heightScale = 1;
              }
              var translate3dY = 'translate3d(0,' + y + 'px, 0) scaleY(' + heightScale + ')';
              if (self.__indicatorY.transformProp !== translate3dY) {
                self.__indicatorY.indicator.style[self.__transformProperty] = translate3dY;
                self.__indicatorY.transformProp = translate3dY;
              }
            }
          },
          __fadeScrollbars: function(direction, delay) {
            var self = this;
            if (!self.options.scrollbarsFade) {
              return ;
            }
            var className = 'scroll-bar-fade-out';
            if (self.options.scrollbarsFade === true) {
              clearTimeout(self.__scrollbarFadeTimeout);
              if (direction == 'in') {
                if (self.__indicatorX) {
                  self.__indicatorX.indicator.classList.remove(className);
                }
                if (self.__indicatorY) {
                  self.__indicatorY.indicator.classList.remove(className);
                }
              } else {
                self.__scrollbarFadeTimeout = setTimeout(function() {
                  if (self.__indicatorX) {
                    self.__indicatorX.indicator.classList.add(className);
                  }
                  if (self.__indicatorY) {
                    self.__indicatorY.indicator.classList.add(className);
                  }
                }, delay || self.options.scrollbarFadeDelay);
              }
            }
          },
          __scrollingComplete: function() {
            this.options.scrollingComplete();
            ionic.tap.removeClonedInputs(this.__container, this);
            this.__fadeScrollbars('out');
          },
          resize: function(continueScrolling) {
            var self = this;
            if (!self.__container || !self.options)
              return ;
            self.setDimensions(self.__container.clientWidth, self.__container.clientHeight, self.options.getContentWidth(), self.options.getContentHeight(), continueScrolling);
          },
          getRenderFn: function() {
            var self = this;
            var content = self.__content;
            var docStyle = document.documentElement.style;
            var engine;
            if ('MozAppearance' in docStyle) {
              engine = 'gecko';
            } else if ('WebkitAppearance' in docStyle) {
              engine = 'webkit';
            } else if (typeof navigator.cpuClass === 'string') {
              engine = 'trident';
            }
            var vendorPrefix = {
              trident: 'ms',
              gecko: 'Moz',
              webkit: 'Webkit',
              presto: 'O'
            }[engine];
            var helperElem = document.createElement("div");
            var undef;
            var perspectiveProperty = vendorPrefix + "Perspective";
            var transformProperty = vendorPrefix + "Transform";
            var transformOriginProperty = vendorPrefix + 'TransformOrigin';
            self.__perspectiveProperty = transformProperty;
            self.__transformProperty = transformProperty;
            self.__transformOriginProperty = transformOriginProperty;
            if (helperElem.style[perspectiveProperty] !== undef) {
              return function(left, top, zoom, wasResize) {
                var translate3d = 'translate3d(' + (-left) + 'px,' + (-top) + 'px,0) scale(' + zoom + ')';
                if (translate3d !== self.contentTransform) {
                  content.style[transformProperty] = translate3d;
                  self.contentTransform = translate3d;
                }
                self.__repositionScrollbars();
                if (!wasResize) {
                  self.triggerScrollEvent();
                }
              };
            } else if (helperElem.style[transformProperty] !== undef) {
              return function(left, top, zoom, wasResize) {
                content.style[transformProperty] = 'translate(' + (-left) + 'px,' + (-top) + 'px) scale(' + zoom + ')';
                self.__repositionScrollbars();
                if (!wasResize) {
                  self.triggerScrollEvent();
                }
              };
            } else {
              return function(left, top, zoom, wasResize) {
                content.style.marginLeft = left ? (-left / zoom) + 'px' : '';
                content.style.marginTop = top ? (-top / zoom) + 'px' : '';
                content.style.zoom = zoom || '';
                self.__repositionScrollbars();
                if (!wasResize) {
                  self.triggerScrollEvent();
                }
              };
            }
          },
          setDimensions: function(clientWidth, clientHeight, contentWidth, contentHeight, continueScrolling) {
            var self = this;
            if (!clientWidth && !clientHeight && !contentWidth && !contentHeight) {
              return ;
            }
            if (clientWidth === +clientWidth) {
              self.__clientWidth = clientWidth;
            }
            if (clientHeight === +clientHeight) {
              self.__clientHeight = clientHeight;
            }
            if (contentWidth === +contentWidth) {
              self.__contentWidth = contentWidth;
            }
            if (contentHeight === +contentHeight) {
              self.__contentHeight = contentHeight;
            }
            self.__computeScrollMax();
            self.__resizeScrollbars();
            if (!continueScrolling) {
              self.scrollTo(self.__scrollLeft, self.__scrollTop, true, null, true);
            }
          },
          setPosition: function(left, top) {
            this.__clientLeft = left || 0;
            this.__clientTop = top || 0;
          },
          setSnapSize: function(width, height) {
            this.__snapWidth = width;
            this.__snapHeight = height;
          },
          activatePullToRefresh: function(height, refresherMethods) {
            var self = this;
            self.__refreshHeight = height;
            self.__refreshActivate = function() {
              ionic.requestAnimationFrame(refresherMethods.activate);
            };
            self.__refreshDeactivate = function() {
              ionic.requestAnimationFrame(refresherMethods.deactivate);
            };
            self.__refreshStart = function() {
              ionic.requestAnimationFrame(refresherMethods.start);
            };
            self.__refreshShow = function() {
              ionic.requestAnimationFrame(refresherMethods.show);
            };
            self.__refreshHide = function() {
              ionic.requestAnimationFrame(refresherMethods.hide);
            };
            self.__refreshTail = function() {
              ionic.requestAnimationFrame(refresherMethods.tail);
            };
            self.__refreshTailTime = 100;
            self.__minSpinTime = 600;
          },
          triggerPullToRefresh: function() {
            this.__publish(this.__scrollLeft, -this.__refreshHeight, this.__zoomLevel, true);
            var d = new Date();
            this.refreshStartTime = d.getTime();
            if (this.__refreshStart) {
              this.__refreshStart();
            }
          },
          finishPullToRefresh: function() {
            var self = this;
            var d = new Date();
            var delay = 0;
            if (self.refreshStartTime + self.__minSpinTime > d.getTime()) {
              delay = self.refreshStartTime + self.__minSpinTime - d.getTime();
            }
            setTimeout(function() {
              if (self.__refreshTail) {
                self.__refreshTail();
              }
              setTimeout(function() {
                self.__refreshActive = false;
                if (self.__refreshDeactivate) {
                  self.__refreshDeactivate();
                }
                if (self.__refreshHide) {
                  self.__refreshHide();
                }
                self.scrollTo(self.__scrollLeft, self.__scrollTop, true);
              }, self.__refreshTailTime);
            }, delay);
          },
          getValues: function() {
            return {
              left: this.__scrollLeft,
              top: this.__scrollTop,
              zoom: this.__zoomLevel
            };
          },
          getScrollMax: function() {
            return {
              left: this.__maxScrollLeft,
              top: this.__maxScrollTop
            };
          },
          zoomTo: function(level, animate, originLeft, originTop) {
            var self = this;
            if (!self.options.zooming) {
              throw new Error("Zooming is not enabled!");
            }
            if (self.__isDecelerating) {
              zyngaCore.effect.Animate.stop(self.__isDecelerating);
              self.__isDecelerating = false;
            }
            var oldLevel = self.__zoomLevel;
            if (originLeft == null) {
              originLeft = self.__clientWidth / 2;
            }
            if (originTop == null) {
              originTop = self.__clientHeight / 2;
            }
            level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);
            self.__computeScrollMax(level);
            var left = ((originLeft + self.__scrollLeft) * level / oldLevel) - originLeft;
            var top = ((originTop + self.__scrollTop) * level / oldLevel) - originTop;
            if (left > self.__maxScrollLeft) {
              left = self.__maxScrollLeft;
            } else if (left < 0) {
              left = 0;
            }
            if (top > self.__maxScrollTop) {
              top = self.__maxScrollTop;
            } else if (top < 0) {
              top = 0;
            }
            self.__publish(left, top, level, animate);
          },
          zoomBy: function(factor, animate, originLeft, originTop) {
            this.zoomTo(this.__zoomLevel * factor, animate, originLeft, originTop);
          },
          scrollTo: function(left, top, animate, zoom, wasResize) {
            var self = this;
            if (self.__isDecelerating) {
              zyngaCore.effect.Animate.stop(self.__isDecelerating);
              self.__isDecelerating = false;
            }
            if (zoom != null && zoom !== self.__zoomLevel) {
              if (!self.options.zooming) {
                throw new Error("Zooming is not enabled!");
              }
              left *= zoom;
              top *= zoom;
              self.__computeScrollMax(zoom);
            } else {
              zoom = self.__zoomLevel;
            }
            if (!self.options.scrollingX) {
              left = self.__scrollLeft;
            } else {
              if (self.options.paging) {
                left = Math.round(left / self.__clientWidth) * self.__clientWidth;
              } else if (self.options.snapping) {
                left = Math.round(left / self.__snapWidth) * self.__snapWidth;
              }
            }
            if (!self.options.scrollingY) {
              top = self.__scrollTop;
            } else {
              if (self.options.paging) {
                top = Math.round(top / self.__clientHeight) * self.__clientHeight;
              } else if (self.options.snapping) {
                top = Math.round(top / self.__snapHeight) * self.__snapHeight;
              }
            }
            left = Math.max(Math.min(self.__maxScrollLeft, left), 0);
            top = Math.max(Math.min(self.__maxScrollTop, top), 0);
            if (left === self.__scrollLeft && top === self.__scrollTop) {
              animate = false;
            }
            self.__publish(left, top, zoom, animate, wasResize);
          },
          scrollBy: function(left, top, animate) {
            var self = this;
            var startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft;
            var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;
            self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);
          },
          doMouseZoom: function(wheelDelta, timeStamp, pageX, pageY) {
            var change = wheelDelta > 0 ? 0.97 : 1.03;
            return this.zoomTo(this.__zoomLevel * change, false, pageX - this.__clientLeft, pageY - this.__clientTop);
          },
          doTouchStart: function(touches, timeStamp) {
            var self = this;
            self.__decStopped = !!(self.__isDecelerating || self.__isAnimating);
            self.hintResize();
            if (timeStamp instanceof Date) {
              timeStamp = timeStamp.valueOf();
            }
            if (typeof timeStamp !== "number") {
              timeStamp = Date.now();
            }
            self.__interruptedAnimation = true;
            if (self.__isDecelerating) {
              zyngaCore.effect.Animate.stop(self.__isDecelerating);
              self.__isDecelerating = false;
              self.__interruptedAnimation = true;
            }
            if (self.__isAnimating) {
              zyngaCore.effect.Animate.stop(self.__isAnimating);
              self.__isAnimating = false;
              self.__interruptedAnimation = true;
            }
            var currentTouchLeft,
                currentTouchTop;
            var isSingleTouch = touches.length === 1;
            if (isSingleTouch) {
              currentTouchLeft = touches[0].pageX;
              currentTouchTop = touches[0].pageY;
            } else {
              currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;
              currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;
            }
            self.__initialTouchLeft = currentTouchLeft;
            self.__initialTouchTop = currentTouchTop;
            self.__initialTouches = touches;
            self.__zoomLevelStart = self.__zoomLevel;
            self.__lastTouchLeft = currentTouchLeft;
            self.__lastTouchTop = currentTouchTop;
            self.__lastTouchMove = timeStamp;
            self.__lastScale = 1;
            self.__enableScrollX = !isSingleTouch && self.options.scrollingX;
            self.__enableScrollY = !isSingleTouch && self.options.scrollingY;
            self.__isTracking = true;
            self.__didDecelerationComplete = false;
            self.__isDragging = !isSingleTouch;
            self.__isSingleTouch = isSingleTouch;
            self.__positions = [];
          },
          doTouchMove: function(touches, timeStamp, scale) {
            if (timeStamp instanceof Date) {
              timeStamp = timeStamp.valueOf();
            }
            if (typeof timeStamp !== "number") {
              timeStamp = Date.now();
            }
            var self = this;
            if (!self.__isTracking) {
              return ;
            }
            var currentTouchLeft,
                currentTouchTop;
            if (touches.length === 2) {
              currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;
              currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;
              if (!scale && self.options.zooming) {
                scale = self.__getScale(self.__initialTouches, touches);
              }
            } else {
              currentTouchLeft = touches[0].pageX;
              currentTouchTop = touches[0].pageY;
            }
            var positions = self.__positions;
            if (self.__isDragging) {
              self.__decStopped = false;
              var moveX = currentTouchLeft - self.__lastTouchLeft;
              var moveY = currentTouchTop - self.__lastTouchTop;
              var scrollLeft = self.__scrollLeft;
              var scrollTop = self.__scrollTop;
              var level = self.__zoomLevel;
              if (scale != null && self.options.zooming) {
                var oldLevel = level;
                level = level / self.__lastScale * scale;
                level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);
                if (oldLevel !== level) {
                  var currentTouchLeftRel = currentTouchLeft - self.__clientLeft;
                  var currentTouchTopRel = currentTouchTop - self.__clientTop;
                  scrollLeft = ((currentTouchLeftRel + scrollLeft) * level / oldLevel) - currentTouchLeftRel;
                  scrollTop = ((currentTouchTopRel + scrollTop) * level / oldLevel) - currentTouchTopRel;
                  self.__computeScrollMax(level);
                }
              }
              if (self.__enableScrollX) {
                scrollLeft -= moveX * self.options.speedMultiplier;
                var maxScrollLeft = self.__maxScrollLeft;
                if (scrollLeft > maxScrollLeft || scrollLeft < 0) {
                  if (self.options.bouncing) {
                    scrollLeft += (moveX / 2 * self.options.speedMultiplier);
                  } else if (scrollLeft > maxScrollLeft) {
                    scrollLeft = maxScrollLeft;
                  } else {
                    scrollLeft = 0;
                  }
                }
              }
              if (self.__enableScrollY) {
                scrollTop -= moveY * self.options.speedMultiplier;
                var maxScrollTop = self.__maxScrollTop;
                if (scrollTop > maxScrollTop || scrollTop < 0) {
                  if (self.options.bouncing || (self.__refreshHeight && scrollTop < 0)) {
                    scrollTop += (moveY / 2 * self.options.speedMultiplier);
                    if (!self.__enableScrollX && self.__refreshHeight != null) {
                      if (scrollTop < 0) {
                        self.__refreshHidden = false;
                        self.__refreshShow();
                      } else {
                        self.__refreshHide();
                        self.__refreshHidden = true;
                      }
                      if (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {
                        self.__refreshActive = true;
                        if (self.__refreshActivate) {
                          self.__refreshActivate();
                        }
                      } else if (self.__refreshActive && scrollTop > -self.__refreshHeight) {
                        self.__refreshActive = false;
                        if (self.__refreshDeactivate) {
                          self.__refreshDeactivate();
                        }
                      }
                    }
                  } else if (scrollTop > maxScrollTop) {
                    scrollTop = maxScrollTop;
                  } else {
                    scrollTop = 0;
                  }
                } else if (self.__refreshHeight && !self.__refreshHidden) {
                  self.__refreshHide();
                  self.__refreshHidden = true;
                }
              }
              if (positions.length > 60) {
                positions.splice(0, 30);
              }
              positions.push(scrollLeft, scrollTop, timeStamp);
              self.__publish(scrollLeft, scrollTop, level);
            } else {
              var minimumTrackingForScroll = self.options.locking ? 3 : 0;
              var minimumTrackingForDrag = 5;
              var distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);
              var distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);
              self.__enableScrollX = self.options.scrollingX && distanceX >= minimumTrackingForScroll;
              self.__enableScrollY = self.options.scrollingY && distanceY >= minimumTrackingForScroll;
              positions.push(self.__scrollLeft, self.__scrollTop, timeStamp);
              self.__isDragging = (self.__enableScrollX || self.__enableScrollY) && (distanceX >= minimumTrackingForDrag || distanceY >= minimumTrackingForDrag);
              if (self.__isDragging) {
                self.__interruptedAnimation = false;
                self.__fadeScrollbars('in');
              }
            }
            self.__lastTouchLeft = currentTouchLeft;
            self.__lastTouchTop = currentTouchTop;
            self.__lastTouchMove = timeStamp;
            self.__lastScale = scale;
          },
          doTouchEnd: function(e, timeStamp) {
            if (timeStamp instanceof Date) {
              timeStamp = timeStamp.valueOf();
            }
            if (typeof timeStamp !== "number") {
              timeStamp = Date.now();
            }
            var self = this;
            if (!self.__isTracking) {
              return ;
            }
            self.__isTracking = false;
            if (self.__isDragging) {
              self.__isDragging = false;
              if (self.__isSingleTouch && self.options.animating && (timeStamp - self.__lastTouchMove) <= 100) {
                var positions = self.__positions;
                var endPos = positions.length - 1;
                var startPos = endPos;
                for (var i = endPos; i > 0 && positions[i] > (self.__lastTouchMove - 100); i -= 3) {
                  startPos = i;
                }
                if (startPos !== endPos) {
                  var timeOffset = positions[endPos] - positions[startPos];
                  var movedLeft = self.__scrollLeft - positions[startPos - 2];
                  var movedTop = self.__scrollTop - positions[startPos - 1];
                  self.__decelerationVelocityX = movedLeft / timeOffset * (1000 / 60);
                  self.__decelerationVelocityY = movedTop / timeOffset * (1000 / 60);
                  var minVelocityToStartDeceleration = self.options.paging || self.options.snapping ? self.options.decelVelocityThresholdPaging : self.options.decelVelocityThreshold;
                  if (Math.abs(self.__decelerationVelocityX) > minVelocityToStartDeceleration || Math.abs(self.__decelerationVelocityY) > minVelocityToStartDeceleration) {
                    if (!self.__refreshActive) {
                      self.__startDeceleration(timeStamp);
                    }
                  }
                } else {
                  self.__scrollingComplete();
                }
              } else if ((timeStamp - self.__lastTouchMove) > 100) {
                self.__scrollingComplete();
              }
            } else if (self.__decStopped) {
              e.isTapHandled = true;
              self.__decStopped = false;
            }
            if (!self.__isDecelerating) {
              if (self.__refreshActive && self.__refreshStart) {
                self.__publish(self.__scrollLeft, -self.__refreshHeight, self.__zoomLevel, true);
                var d = new Date();
                self.refreshStartTime = d.getTime();
                if (self.__refreshStart) {
                  self.__refreshStart();
                }
                if (!ionic.Platform.isAndroid())
                  self.__startDeceleration();
              } else {
                if (self.__interruptedAnimation || self.__isDragging) {
                  self.__scrollingComplete();
                }
                self.scrollTo(self.__scrollLeft, self.__scrollTop, true, self.__zoomLevel);
                if (self.__refreshActive) {
                  self.__refreshActive = false;
                  if (self.__refreshDeactivate) {
                    self.__refreshDeactivate();
                  }
                }
              }
            }
            self.__positions.length = 0;
          },
          __publish: function(left, top, zoom, animate, wasResize) {
            var self = this;
            var wasAnimating = self.__isAnimating;
            if (wasAnimating) {
              zyngaCore.effect.Animate.stop(wasAnimating);
              self.__isAnimating = false;
            }
            if (animate && self.options.animating) {
              self.__scheduledLeft = left;
              self.__scheduledTop = top;
              self.__scheduledZoom = zoom;
              var oldLeft = self.__scrollLeft;
              var oldTop = self.__scrollTop;
              var oldZoom = self.__zoomLevel;
              var diffLeft = left - oldLeft;
              var diffTop = top - oldTop;
              var diffZoom = zoom - oldZoom;
              var step = function(percent, now, render) {
                if (render) {
                  self.__scrollLeft = oldLeft + (diffLeft * percent);
                  self.__scrollTop = oldTop + (diffTop * percent);
                  self.__zoomLevel = oldZoom + (diffZoom * percent);
                  if (self.__callback) {
                    self.__callback(self.__scrollLeft, self.__scrollTop, self.__zoomLevel, wasResize);
                  }
                }
              };
              var verify = function(id) {
                return self.__isAnimating === id;
              };
              var completed = function(renderedFramesPerSecond, animationId, wasFinished) {
                if (animationId === self.__isAnimating) {
                  self.__isAnimating = false;
                }
                if (self.__didDecelerationComplete || wasFinished) {
                  self.__scrollingComplete();
                }
                if (self.options.zooming) {
                  self.__computeScrollMax();
                }
              };
              self.__isAnimating = zyngaCore.effect.Animate.start(step, verify, completed, self.options.animationDuration, wasAnimating ? easeOutCubic : easeInOutCubic);
            } else {
              self.__scheduledLeft = self.__scrollLeft = left;
              self.__scheduledTop = self.__scrollTop = top;
              self.__scheduledZoom = self.__zoomLevel = zoom;
              if (self.__callback) {
                self.__callback(left, top, zoom, wasResize);
              }
              if (self.options.zooming) {
                self.__computeScrollMax();
              }
            }
          },
          __computeScrollMax: function(zoomLevel) {
            var self = this;
            if (zoomLevel == null) {
              zoomLevel = self.__zoomLevel;
            }
            self.__maxScrollLeft = Math.max((self.__contentWidth * zoomLevel) - self.__clientWidth, 0);
            self.__maxScrollTop = Math.max((self.__contentHeight * zoomLevel) - self.__clientHeight, 0);
            if (!self.__didWaitForSize && !self.__maxScrollLeft && !self.__maxScrollTop) {
              self.__didWaitForSize = true;
              self.__waitForSize();
            }
          },
          __waitForSize: function() {
            var self = this;
            clearTimeout(self.__sizerTimeout);
            var sizer = function() {
              self.resize(true);
            };
            sizer();
            self.__sizerTimeout = setTimeout(sizer, 500);
          },
          __startDeceleration: function() {
            var self = this;
            if (self.options.paging) {
              var scrollLeft = Math.max(Math.min(self.__scrollLeft, self.__maxScrollLeft), 0);
              var scrollTop = Math.max(Math.min(self.__scrollTop, self.__maxScrollTop), 0);
              var clientWidth = self.__clientWidth;
              var clientHeight = self.__clientHeight;
              self.__minDecelerationScrollLeft = Math.floor(scrollLeft / clientWidth) * clientWidth;
              self.__minDecelerationScrollTop = Math.floor(scrollTop / clientHeight) * clientHeight;
              self.__maxDecelerationScrollLeft = Math.ceil(scrollLeft / clientWidth) * clientWidth;
              self.__maxDecelerationScrollTop = Math.ceil(scrollTop / clientHeight) * clientHeight;
            } else {
              self.__minDecelerationScrollLeft = 0;
              self.__minDecelerationScrollTop = 0;
              self.__maxDecelerationScrollLeft = self.__maxScrollLeft;
              self.__maxDecelerationScrollTop = self.__maxScrollTop;
              if (self.__refreshActive)
                self.__minDecelerationScrollTop = self.__refreshHeight * -1;
            }
            var step = function(percent, now, render) {
              self.__stepThroughDeceleration(render);
            };
            self.__minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.1;
            var verify = function() {
              var shouldContinue = Math.abs(self.__decelerationVelocityX) >= self.__minVelocityToKeepDecelerating || Math.abs(self.__decelerationVelocityY) >= self.__minVelocityToKeepDecelerating;
              if (!shouldContinue) {
                self.__didDecelerationComplete = true;
                if (self.options.bouncing && !self.__refreshActive) {
                  self.scrollTo(Math.min(Math.max(self.__scrollLeft, 0), self.__maxScrollLeft), Math.min(Math.max(self.__scrollTop, 0), self.__maxScrollTop), self.__refreshActive);
                }
              }
              return shouldContinue;
            };
            var completed = function() {
              self.__isDecelerating = false;
              if (self.__didDecelerationComplete) {
                self.__scrollingComplete();
              }
              if (self.options.paging) {
                self.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);
              }
            };
            self.__isDecelerating = zyngaCore.effect.Animate.start(step, verify, completed);
          },
          __stepThroughDeceleration: function(render) {
            var self = this;
            var scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;
            var scrollTop = self.__scrollTop + self.__decelerationVelocityY;
            if (!self.options.bouncing) {
              var scrollLeftFixed = Math.max(Math.min(self.__maxDecelerationScrollLeft, scrollLeft), self.__minDecelerationScrollLeft);
              if (scrollLeftFixed !== scrollLeft) {
                scrollLeft = scrollLeftFixed;
                self.__decelerationVelocityX = 0;
              }
              var scrollTopFixed = Math.max(Math.min(self.__maxDecelerationScrollTop, scrollTop), self.__minDecelerationScrollTop);
              if (scrollTopFixed !== scrollTop) {
                scrollTop = scrollTopFixed;
                self.__decelerationVelocityY = 0;
              }
            }
            if (render) {
              self.__publish(scrollLeft, scrollTop, self.__zoomLevel);
            } else {
              self.__scrollLeft = scrollLeft;
              self.__scrollTop = scrollTop;
            }
            if (!self.options.paging) {
              var frictionFactor = self.options.deceleration;
              self.__decelerationVelocityX *= frictionFactor;
              self.__decelerationVelocityY *= frictionFactor;
            }
            if (self.options.bouncing) {
              var scrollOutsideX = 0;
              var scrollOutsideY = 0;
              var penetrationDeceleration = self.options.penetrationDeceleration;
              var penetrationAcceleration = self.options.penetrationAcceleration;
              if (scrollLeft < self.__minDecelerationScrollLeft) {
                scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;
              } else if (scrollLeft > self.__maxDecelerationScrollLeft) {
                scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;
              }
              if (scrollTop < self.__minDecelerationScrollTop) {
                scrollOutsideY = self.__minDecelerationScrollTop - scrollTop;
              } else if (scrollTop > self.__maxDecelerationScrollTop) {
                scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;
              }
              if (scrollOutsideX !== 0) {
                var isHeadingOutwardsX = scrollOutsideX * self.__decelerationVelocityX <= self.__minDecelerationScrollLeft;
                if (isHeadingOutwardsX) {
                  self.__decelerationVelocityX += scrollOutsideX * penetrationDeceleration;
                }
                var isStoppedX = Math.abs(self.__decelerationVelocityX) <= self.__minVelocityToKeepDecelerating;
                if (!isHeadingOutwardsX || isStoppedX) {
                  self.__decelerationVelocityX = scrollOutsideX * penetrationAcceleration;
                }
              }
              if (scrollOutsideY !== 0) {
                var isHeadingOutwardsY = scrollOutsideY * self.__decelerationVelocityY <= self.__minDecelerationScrollTop;
                if (isHeadingOutwardsY) {
                  self.__decelerationVelocityY += scrollOutsideY * penetrationDeceleration;
                }
                var isStoppedY = Math.abs(self.__decelerationVelocityY) <= self.__minVelocityToKeepDecelerating;
                if (!isHeadingOutwardsY || isStoppedY) {
                  self.__decelerationVelocityY = scrollOutsideY * penetrationAcceleration;
                }
              }
            }
          },
          __getDistance: function getDistance(touch1, touch2) {
            var x = touch2.pageX - touch1.pageX,
                y = touch2.pageY - touch1.pageY;
            return Math.sqrt((x * x) + (y * y));
          },
          __getScale: function getScale(start, end) {
            if (start.length >= 2 && end.length >= 2) {
              return this.__getDistance(end[0], end[1]) / this.__getDistance(start[0], start[1]);
            }
            return 1;
          }
        });
        ionic.scroll = {
          isScrolling: false,
          lastTop: 0
        };
      })(ionic);
      (function(ionic) {
        var NOOP = function() {};
        var depreciated = function(name) {
          void 0;
        };
        ionic.views.ScrollNative = ionic.views.View.inherit({
          initialize: function(options) {
            var self = this;
            self.__container = self.el = options.el;
            self.__content = options.el.firstElementChild;
            self.isNative = true;
            self.__scrollTop = self.el.scrollTop;
            self.__scrollLeft = self.el.scrollLeft;
            self.__clientHeight = self.__content.clientHeight;
            self.__clientWidth = self.__content.clientWidth;
            self.__maxScrollTop = Math.max((self.__contentHeight) - self.__clientHeight, 0);
            self.__maxScrollLeft = Math.max((self.__contentWidth) - self.__clientWidth, 0);
            self.options = {
              freeze: false,
              getContentWidth: function() {
                return Math.max(self.__content.scrollWidth, self.__content.offsetWidth);
              },
              getContentHeight: function() {
                return Math.max(self.__content.scrollHeight, self.__content.offsetHeight + (self.__content.offsetTop * 2));
              }
            };
            for (var key in options) {
              self.options[key] = options[key];
            }
            self.onScroll = function() {
              if (!ionic.scroll.isScrolling) {
                ionic.scroll.isScrolling = true;
              }
              clearTimeout(self.scrollTimer);
              self.scrollTimer = setTimeout(function() {
                ionic.scroll.isScrolling = false;
              }, 80);
            };
            self.freeze = NOOP;
            self.__initEventHandlers();
          },
          __callback: function() {
            depreciated('__callback');
          },
          zoomTo: function() {
            depreciated('zoomTo');
          },
          zoomBy: function() {
            depreciated('zoomBy');
          },
          activatePullToRefresh: function() {
            depreciated('activatePullToRefresh');
          },
          resize: function(continueScrolling) {
            var self = this;
            if (!self.__container || !self.options)
              return ;
            self.setDimensions(self.__container.clientWidth, self.__container.clientHeight, self.options.getContentWidth(), self.options.getContentHeight(), continueScrolling);
          },
          run: function() {
            this.resize();
          },
          getValues: function() {
            var self = this;
            self.update();
            return {
              left: self.__scrollLeft,
              top: self.__scrollTop,
              zoom: 1
            };
          },
          update: function() {
            var self = this;
            self.__scrollLeft = self.el.scrollLeft;
            self.__scrollTop = self.el.scrollTop;
          },
          setDimensions: function(clientWidth, clientHeight, contentWidth, contentHeight) {
            var self = this;
            if (!clientWidth && !clientHeight && !contentWidth && !contentHeight) {
              return ;
            }
            if (clientWidth === +clientWidth) {
              self.__clientWidth = clientWidth;
            }
            if (clientHeight === +clientHeight) {
              self.__clientHeight = clientHeight;
            }
            if (contentWidth === +contentWidth) {
              self.__contentWidth = contentWidth;
            }
            if (contentHeight === +contentHeight) {
              self.__contentHeight = contentHeight;
            }
            self.__computeScrollMax();
          },
          getScrollMax: function() {
            return {
              left: this.__maxScrollLeft,
              top: this.__maxScrollTop
            };
          },
          scrollBy: function(left, top, animate) {
            var self = this;
            self.update();
            var startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft;
            var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;
            self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);
          },
          scrollTo: function(left, top, animate) {
            var self = this;
            if (!animate) {
              self.el.scrollTop = top;
              self.el.scrollLeft = left;
              self.resize();
              return ;
            }
            animateScroll(top, left);
            function animateScroll(Y, X) {
              var start = Date.now(),
                  duration = 250,
                  fromY = self.el.scrollTop,
                  fromX = self.el.scrollLeft;
              if (fromY === Y && fromX === X) {
                self.resize();
                return ;
              }
              function easeOutCubic(t) {
                return (--t) * t * t + 1;
              }
              function animateScrollStep() {
                var currentTime = Date.now(),
                    time = Math.min(1, ((currentTime - start) / duration)),
                    easedT = easeOutCubic(time);
                if (fromY != Y) {
                  self.el.scrollTop = parseInt((easedT * (Y - fromY)) + fromY, 10);
                }
                if (fromX != X) {
                  self.el.scrollLeft = parseInt((easedT * (X - fromX)) + fromX, 10);
                }
                if (time < 1) {
                  ionic.requestAnimationFrame(animateScrollStep);
                } else {
                  ionic.tap.removeClonedInputs(self.__container, self);
                  self.resize();
                }
              }
              ionic.requestAnimationFrame(animateScrollStep);
            }
          },
          __waitForSize: function() {
            var self = this;
            clearTimeout(self.__sizerTimeout);
            var sizer = function() {
              self.resize(true);
            };
            sizer();
            self.__sizerTimeout = setTimeout(sizer, 500);
          },
          __computeScrollMax: function() {
            var self = this;
            self.__maxScrollLeft = Math.max((self.__contentWidth) - self.__clientWidth, 0);
            self.__maxScrollTop = Math.max((self.__contentHeight) - self.__clientHeight, 0);
            if (!self.__didWaitForSize && !self.__maxScrollLeft && !self.__maxScrollTop) {
              self.__didWaitForSize = true;
              self.__waitForSize();
            }
          },
          __initEventHandlers: function() {
            var self = this;
            var container = self.__container;
            var scrollViewOffsetHeight;
            self.scrollChildIntoView = function(e) {
              var scrollBottomOffsetToTop = container.getBoundingClientRect().bottom;
              scrollViewOffsetHeight = container.offsetHeight;
              var alreadyShrunk = self.isShrunkForKeyboard;
              var isModal = container.parentNode.classList.contains('modal');
              var isInsetModal = isModal && window.innerWidth >= 680;
              if (!alreadyShrunk) {
                if (ionic.Platform.isIOS() || ionic.Platform.isFullScreen || isInsetModal) {
                  var scrollBottomOffsetToBottom = e.detail.viewportHeight - scrollBottomOffsetToTop;
                  var keyboardOffset = Math.max(0, e.detail.keyboardHeight - scrollBottomOffsetToBottom);
                  ionic.requestAnimationFrame(function() {
                    scrollViewOffsetHeight = scrollViewOffsetHeight - keyboardOffset;
                    container.style.height = scrollViewOffsetHeight + "px";
                    self.resize();
                  });
                }
                self.isShrunkForKeyboard = true;
              }
              if (e.detail.isElementUnderKeyboard) {
                ionic.requestAnimationFrame(function() {
                  if (self.isShrunkForKeyboard && !alreadyShrunk) {
                    scrollBottomOffsetToTop = container.getBoundingClientRect().bottom;
                  }
                  var scrollMidpointOffset = scrollViewOffsetHeight * 0.5;
                  var inputMidpoint = ((e.detail.elementBottom + e.detail.elementTop) / 2);
                  var inputMidpointOffsetToScrollBottom = inputMidpoint - scrollBottomOffsetToTop;
                  var scrollTop = inputMidpointOffsetToScrollBottom + scrollMidpointOffset;
                  if (scrollTop > 0) {
                    if (ionic.Platform.isIOS()) {
                      setTimeout(function() {
                        ionic.tap.cloneFocusedInput(container, self);
                        self.scrollBy(0, scrollTop, true);
                        self.onScroll();
                      }, 32);
                    } else {
                      self.scrollBy(0, scrollTop, true);
                      self.onScroll();
                    }
                  }
                });
              }
              e.stopPropagation();
            };
            self.resetScrollView = function() {
              if (self.isShrunkForKeyboard) {
                self.isShrunkForKeyboard = false;
                container.style.height = "";
              }
              self.resize();
            };
            container.addEventListener('scroll', self.onScroll);
            container.addEventListener('scrollChildIntoView', self.scrollChildIntoView);
            document.addEventListener('resetScrollView', self.resetScrollView);
          },
          __cleanup: function() {
            var self = this;
            var container = self.__container;
            container.removeEventListener('resetScrollView', self.resetScrollView);
            container.removeEventListener('scroll', self.onScroll);
            container.removeEventListener('scrollChildIntoView', self.scrollChildIntoView);
            container.removeEventListener('resetScrollView', self.resetScrollView);
            ionic.tap.removeClonedInputs(container, self);
            delete self.__container;
            delete self.__content;
            delete self.__indicatorX;
            delete self.__indicatorY;
            delete self.options.el;
            self.resize = self.scrollTo = self.onScroll = self.resetScrollView = NOOP;
            self.scrollChildIntoView = NOOP;
            container = null;
          }
        });
      })(ionic);
      (function(ionic) {
        'use strict';
        var ITEM_CLASS = 'item';
        var ITEM_CONTENT_CLASS = 'item-content';
        var ITEM_SLIDING_CLASS = 'item-sliding';
        var ITEM_OPTIONS_CLASS = 'item-options';
        var ITEM_PLACEHOLDER_CLASS = 'item-placeholder';
        var ITEM_REORDERING_CLASS = 'item-reordering';
        var ITEM_REORDER_BTN_CLASS = 'item-reorder';
        var DragOp = function() {};
        DragOp.prototype = {
          start: function() {},
          drag: function() {},
          end: function() {},
          isSameItem: function() {
            return false;
          }
        };
        var SlideDrag = function(opts) {
          this.dragThresholdX = opts.dragThresholdX || 10;
          this.el = opts.el;
          this.item = opts.item;
          this.canSwipe = opts.canSwipe;
        };
        SlideDrag.prototype = new DragOp();
        SlideDrag.prototype.start = function(e) {
          var content,
              buttons,
              offsetX,
              buttonsWidth;
          if (!this.canSwipe()) {
            return ;
          }
          if (e.target.classList.contains(ITEM_CONTENT_CLASS)) {
            content = e.target;
          } else if (e.target.classList.contains(ITEM_CLASS)) {
            content = e.target.querySelector('.' + ITEM_CONTENT_CLASS);
          } else {
            content = ionic.DomUtil.getParentWithClass(e.target, ITEM_CONTENT_CLASS);
          }
          if (!content) {
            return ;
          }
          content.classList.remove(ITEM_SLIDING_CLASS);
          offsetX = parseFloat(content.style[ionic.CSS.TRANSFORM].replace('translate3d(', '').split(',')[0]) || 0;
          buttons = content.parentNode.querySelector('.' + ITEM_OPTIONS_CLASS);
          if (!buttons) {
            return ;
          }
          buttons.classList.remove('invisible');
          buttonsWidth = buttons.offsetWidth;
          this._currentDrag = {
            buttons: buttons,
            buttonsWidth: buttonsWidth,
            content: content,
            startOffsetX: offsetX
          };
        };
        SlideDrag.prototype.isSameItem = function(op) {
          if (op._lastDrag && this._currentDrag) {
            return this._currentDrag.content == op._lastDrag.content;
          }
          return false;
        };
        SlideDrag.prototype.clean = function(isInstant) {
          var lastDrag = this._lastDrag;
          if (!lastDrag || !lastDrag.content)
            return ;
          lastDrag.content.style[ionic.CSS.TRANSITION] = '';
          lastDrag.content.style[ionic.CSS.TRANSFORM] = '';
          if (isInstant) {
            lastDrag.content.style[ionic.CSS.TRANSITION] = 'none';
            makeInvisible();
            ionic.requestAnimationFrame(function() {
              lastDrag.content.style[ionic.CSS.TRANSITION] = '';
            });
          } else {
            ionic.requestAnimationFrame(function() {
              setTimeout(makeInvisible, 250);
            });
          }
          function makeInvisible() {
            lastDrag.buttons && lastDrag.buttons.classList.add('invisible');
          }
        };
        SlideDrag.prototype.drag = ionic.animationFrameThrottle(function(e) {
          var buttonsWidth;
          if (!this._currentDrag) {
            return ;
          }
          if (!this._isDragging && ((Math.abs(e.gesture.deltaX) > this.dragThresholdX) || (Math.abs(this._currentDrag.startOffsetX) > 0))) {
            this._isDragging = true;
          }
          if (this._isDragging) {
            buttonsWidth = this._currentDrag.buttonsWidth;
            var newX = Math.min(0, this._currentDrag.startOffsetX + e.gesture.deltaX);
            if (newX < -buttonsWidth) {
              newX = Math.min(-buttonsWidth, -buttonsWidth + (((e.gesture.deltaX + buttonsWidth) * 0.4)));
            }
            this._currentDrag.content.$$ionicOptionsOpen = newX !== 0;
            this._currentDrag.content.style[ionic.CSS.TRANSFORM] = 'translate3d(' + newX + 'px, 0, 0)';
            this._currentDrag.content.style[ionic.CSS.TRANSITION] = 'none';
          }
        });
        SlideDrag.prototype.end = function(e, doneCallback) {
          var self = this;
          if (!self._currentDrag) {
            doneCallback && doneCallback();
            return ;
          }
          var restingPoint = -self._currentDrag.buttonsWidth;
          if (e.gesture.deltaX > -(self._currentDrag.buttonsWidth / 2)) {
            if (e.gesture.direction == "left" && Math.abs(e.gesture.velocityX) < 0.3) {
              restingPoint = 0;
            } else if (e.gesture.direction == "right") {
              restingPoint = 0;
            }
          }
          ionic.requestAnimationFrame(function() {
            if (restingPoint === 0) {
              self._currentDrag.content.style[ionic.CSS.TRANSFORM] = '';
              var buttons = self._currentDrag.buttons;
              setTimeout(function() {
                buttons && buttons.classList.add('invisible');
              }, 250);
            } else {
              self._currentDrag.content.style[ionic.CSS.TRANSFORM] = 'translate3d(' + restingPoint + 'px,0,0)';
            }
            self._currentDrag.content.style[ionic.CSS.TRANSITION] = '';
            if (!self._lastDrag) {
              self._lastDrag = {};
            }
            ionic.extend(self._lastDrag, self._currentDrag);
            if (self._currentDrag) {
              self._currentDrag.buttons = null;
              self._currentDrag.content = null;
            }
            self._currentDrag = null;
            doneCallback && doneCallback();
          });
        };
        var ReorderDrag = function(opts) {
          var self = this;
          self.dragThresholdY = opts.dragThresholdY || 0;
          self.onReorder = opts.onReorder;
          self.listEl = opts.listEl;
          self.el = self.item = opts.el;
          self.scrollEl = opts.scrollEl;
          self.scrollView = opts.scrollView;
          self.listElTrueTop = 0;
          if (self.listEl.offsetParent) {
            var obj = self.listEl;
            do {
              self.listElTrueTop += obj.offsetTop;
              obj = obj.offsetParent;
            } while (obj);
          }
        };
        ReorderDrag.prototype = new DragOp();
        ReorderDrag.prototype._moveElement = function(e) {
          var y = e.gesture.center.pageY + this.scrollView.getValues().top - (this._currentDrag.elementHeight / 2) - this.listElTrueTop;
          this.el.style[ionic.CSS.TRANSFORM] = 'translate3d(0, ' + y + 'px, 0)';
        };
        ReorderDrag.prototype.deregister = function() {
          this.listEl = this.el = this.scrollEl = this.scrollView = null;
        };
        ReorderDrag.prototype.start = function(e) {
          var startIndex = ionic.DomUtil.getChildIndex(this.el, this.el.nodeName.toLowerCase());
          var elementHeight = this.el.scrollHeight;
          var placeholder = this.el.cloneNode(true);
          placeholder.classList.add(ITEM_PLACEHOLDER_CLASS);
          this.el.parentNode.insertBefore(placeholder, this.el);
          this.el.classList.add(ITEM_REORDERING_CLASS);
          this._currentDrag = {
            elementHeight: elementHeight,
            startIndex: startIndex,
            placeholder: placeholder,
            scrollHeight: scroll,
            list: placeholder.parentNode
          };
          this._moveElement(e);
        };
        ReorderDrag.prototype.drag = ionic.animationFrameThrottle(function(e) {
          var self = this;
          if (!this._currentDrag) {
            return ;
          }
          var scrollY = 0;
          var pageY = e.gesture.center.pageY;
          var offset = this.listElTrueTop;
          if (this.scrollView) {
            var container = this.scrollView.__container;
            scrollY = this.scrollView.getValues().top;
            var containerTop = container.offsetTop;
            var pixelsPastTop = containerTop - pageY + this._currentDrag.elementHeight / 2;
            var pixelsPastBottom = pageY + this._currentDrag.elementHeight / 2 - containerTop - container.offsetHeight;
            if (e.gesture.deltaY < 0 && pixelsPastTop > 0 && scrollY > 0) {
              this.scrollView.scrollBy(null, -pixelsPastTop);
              ionic.requestAnimationFrame(function() {
                self.drag(e);
              });
            }
            if (e.gesture.deltaY > 0 && pixelsPastBottom > 0) {
              if (scrollY < this.scrollView.getScrollMax().top) {
                this.scrollView.scrollBy(null, pixelsPastBottom);
                ionic.requestAnimationFrame(function() {
                  self.drag(e);
                });
              }
            }
          }
          if (!this._isDragging && Math.abs(e.gesture.deltaY) > this.dragThresholdY) {
            this._isDragging = true;
          }
          if (this._isDragging) {
            this._moveElement(e);
            this._currentDrag.currentY = scrollY + pageY - offset;
          }
        });
        ReorderDrag.prototype._getReorderIndex = function() {
          var self = this;
          var siblings = Array.prototype.slice.call(self._currentDrag.placeholder.parentNode.children).filter(function(el) {
            return el.nodeName === self.el.nodeName && el !== self.el;
          });
          var dragOffsetTop = self._currentDrag.currentY;
          var el;
          for (var i = 0,
              len = siblings.length; i < len; i++) {
            el = siblings[i];
            if (i === len - 1) {
              if (dragOffsetTop > el.offsetTop) {
                return i;
              }
            } else if (i === 0) {
              if (dragOffsetTop < el.offsetTop + el.offsetHeight) {
                return i;
              }
            } else if (dragOffsetTop > el.offsetTop - el.offsetHeight / 2 && dragOffsetTop < el.offsetTop + el.offsetHeight) {
              return i;
            }
          }
          return self._currentDrag.startIndex;
        };
        ReorderDrag.prototype.end = function(e, doneCallback) {
          if (!this._currentDrag) {
            doneCallback && doneCallback();
            return ;
          }
          var placeholder = this._currentDrag.placeholder;
          var finalIndex = this._getReorderIndex();
          this.el.classList.remove(ITEM_REORDERING_CLASS);
          this.el.style[ionic.CSS.TRANSFORM] = '';
          placeholder.parentNode.insertBefore(this.el, placeholder);
          placeholder.parentNode.removeChild(placeholder);
          this.onReorder && this.onReorder(this.el, this._currentDrag.startIndex, finalIndex);
          this._currentDrag = {
            placeholder: null,
            content: null
          };
          this._currentDrag = null;
          doneCallback && doneCallback();
        };
        ionic.views.ListView = ionic.views.View.inherit({
          initialize: function(opts) {
            var self = this;
            opts = ionic.extend({
              onReorder: function() {},
              virtualRemoveThreshold: -200,
              virtualAddThreshold: 200,
              canSwipe: function() {
                return true;
              }
            }, opts);
            ionic.extend(self, opts);
            if (!self.itemHeight && self.listEl) {
              self.itemHeight = self.listEl.children[0] && parseInt(self.listEl.children[0].style.height, 10);
            }
            self.onRefresh = opts.onRefresh || function() {};
            self.onRefreshOpening = opts.onRefreshOpening || function() {};
            self.onRefreshHolding = opts.onRefreshHolding || function() {};
            var gestureOpts = {};
            if (ionic.DomUtil.getParentOrSelfWithClass(self.el, 'overflow-scroll')) {
              gestureOpts.prevent_default_directions = ['left', 'right'];
            }
            window.ionic.onGesture('release', function(e) {
              self._handleEndDrag(e);
            }, self.el, gestureOpts);
            window.ionic.onGesture('drag', function(e) {
              self._handleDrag(e);
            }, self.el, gestureOpts);
            self._initDrag();
          },
          deregister: function() {
            this.el = this.listEl = this.scrollEl = this.scrollView = null;
            if (this.isScrollFreeze) {
              self.scrollView.freeze(false);
            }
          },
          stopRefreshing: function() {
            var refresher = this.el.querySelector('.list-refresher');
            refresher.style.height = '0';
          },
          didScroll: function(e) {
            var self = this;
            if (self.isVirtual) {
              var itemHeight = self.itemHeight;
              var scrollHeight = e.target.scrollHeight;
              var viewportHeight = self.el.parentNode.offsetHeight;
              var highWater = Math.max(0, e.scrollTop + self.virtualRemoveThreshold);
              var lowWater = Math.min(scrollHeight, Math.abs(e.scrollTop) + viewportHeight + self.virtualAddThreshold);
              var first = parseInt(Math.abs(highWater / itemHeight), 10);
              var last = parseInt(Math.abs(lowWater / itemHeight), 10);
              self._virtualItemsToRemove = Array.prototype.slice.call(self.listEl.children, 0, first);
              self.renderViewport && self.renderViewport(highWater, lowWater, first, last);
            }
          },
          didStopScrolling: function() {
            if (this.isVirtual) {
              for (var i = 0; i < this._virtualItemsToRemove.length; i++) {
                this.didHideItem && this.didHideItem(i);
              }
            }
          },
          clearDragEffects: function(isInstant) {
            if (this._lastDragOp) {
              this._lastDragOp.clean && this._lastDragOp.clean(isInstant);
              this._lastDragOp.deregister && this._lastDragOp.deregister();
              this._lastDragOp = null;
            }
          },
          _initDrag: function() {
            if (this._lastDragOp) {
              this._lastDragOp.deregister && this._lastDragOp.deregister();
            }
            this._lastDragOp = this._dragOp;
            this._dragOp = null;
          },
          _getItem: function(target) {
            while (target) {
              if (target.classList && target.classList.contains(ITEM_CLASS)) {
                return target;
              }
              target = target.parentNode;
            }
            return null;
          },
          _startDrag: function(e) {
            var self = this;
            self._isDragging = false;
            var lastDragOp = self._lastDragOp;
            var item;
            if (self._didDragUpOrDown && lastDragOp instanceof SlideDrag) {
              lastDragOp.clean && lastDragOp.clean();
            }
            if (ionic.DomUtil.getParentOrSelfWithClass(e.target, ITEM_REORDER_BTN_CLASS) && (e.gesture.direction == 'up' || e.gesture.direction == 'down')) {
              item = self._getItem(e.target);
              if (item) {
                self._dragOp = new ReorderDrag({
                  listEl: self.el,
                  el: item,
                  scrollEl: self.scrollEl,
                  scrollView: self.scrollView,
                  onReorder: function(el, start, end) {
                    self.onReorder && self.onReorder(el, start, end);
                  }
                });
                self._dragOp.start(e);
                e.preventDefault();
              }
            } else if (!self._didDragUpOrDown && (e.gesture.direction == 'left' || e.gesture.direction == 'right') && Math.abs(e.gesture.deltaX) > 5) {
              item = self._getItem(e.target);
              if (item && item.querySelector('.item-options')) {
                self._dragOp = new SlideDrag({
                  el: self.el,
                  item: item,
                  canSwipe: self.canSwipe
                });
                self._dragOp.start(e);
                e.preventDefault();
                self.isScrollFreeze = self.scrollView.freeze(true);
              }
            }
            if (lastDragOp && self._dragOp && !self._dragOp.isSameItem(lastDragOp) && e.defaultPrevented) {
              lastDragOp.clean && lastDragOp.clean();
            }
          },
          _handleEndDrag: function(e) {
            var self = this;
            if (self.scrollView) {
              self.isScrollFreeze = self.scrollView.freeze(false);
            }
            self._didDragUpOrDown = false;
            if (!self._dragOp) {
              return ;
            }
            self._dragOp.end(e, function() {
              self._initDrag();
            });
          },
          _handleDrag: function(e) {
            var self = this;
            if (Math.abs(e.gesture.deltaY) > 5) {
              self._didDragUpOrDown = true;
            }
            if (!self.isDragging && !self._dragOp) {
              self._startDrag(e);
            }
            if (!self._dragOp) {
              return ;
            }
            e.gesture.srcEvent.preventDefault();
            self._dragOp.drag(e);
          }
        });
      })(ionic);
      (function(ionic) {
        'use strict';
        ionic.views.Modal = ionic.views.View.inherit({
          initialize: function(opts) {
            opts = ionic.extend({
              focusFirstInput: false,
              unfocusOnHide: true,
              focusFirstDelay: 600,
              backdropClickToClose: true,
              hardwareBackButtonClose: true
            }, opts);
            ionic.extend(this, opts);
            this.el = opts.el;
          },
          show: function() {
            var self = this;
            if (self.focusFirstInput) {
              window.setTimeout(function() {
                var input = self.el.querySelector('input, textarea');
                input && input.focus && input.focus();
              }, self.focusFirstDelay);
            }
          },
          hide: function() {
            if (this.unfocusOnHide) {
              var inputs = this.el.querySelectorAll('input, textarea');
              window.setTimeout(function() {
                for (var i = 0; i < inputs.length; i++) {
                  inputs[i].blur && inputs[i].blur();
                }
              });
            }
          }
        });
      })(ionic);
      (function(ionic) {
        'use strict';
        ionic.views.SideMenu = ionic.views.View.inherit({
          initialize: function(opts) {
            this.el = opts.el;
            this.isEnabled = (typeof opts.isEnabled === 'undefined') ? true : opts.isEnabled;
            this.setWidth(opts.width);
          },
          getFullWidth: function() {
            return this.width;
          },
          setWidth: function(width) {
            this.width = width;
            this.el.style.width = width + 'px';
          },
          setIsEnabled: function(isEnabled) {
            this.isEnabled = isEnabled;
          },
          bringUp: function() {
            if (this.el.style.zIndex !== '0') {
              this.el.style.zIndex = '0';
            }
          },
          pushDown: function() {
            if (this.el.style.zIndex !== '-1') {
              this.el.style.zIndex = '-1';
            }
          }
        });
        ionic.views.SideMenuContent = ionic.views.View.inherit({
          initialize: function(opts) {
            ionic.extend(this, {
              animationClass: 'menu-animated',
              onDrag: function() {},
              onEndDrag: function() {}
            }, opts);
            ionic.onGesture('drag', ionic.proxy(this._onDrag, this), this.el);
            ionic.onGesture('release', ionic.proxy(this._onEndDrag, this), this.el);
          },
          _onDrag: function(e) {
            this.onDrag && this.onDrag(e);
          },
          _onEndDrag: function(e) {
            this.onEndDrag && this.onEndDrag(e);
          },
          disableAnimation: function() {
            this.el.classList.remove(this.animationClass);
          },
          enableAnimation: function() {
            this.el.classList.add(this.animationClass);
          },
          getTranslateX: function() {
            return parseFloat(this.el.style[ionic.CSS.TRANSFORM].replace('translate3d(', '').split(',')[0]);
          },
          setTranslateX: ionic.animationFrameThrottle(function(x) {
            this.el.style[ionic.CSS.TRANSFORM] = 'translate3d(' + x + 'px, 0, 0)';
          })
        });
      })(ionic);
      (function(ionic) {
        'use strict';
        ionic.views.Slider = ionic.views.View.inherit({initialize: function(options) {
            var slider = this;
            var noop = function() {};
            var offloadFn = function(fn) {
              setTimeout(fn || noop, 0);
            };
            var browser = {
              addEventListener: !!window.addEventListener,
              touch: ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch,
              transitions: (function(temp) {
                var props = ['transitionProperty', 'WebkitTransition', 'MozTransition', 'OTransition', 'msTransition'];
                for (var i in props)
                  if (temp.style[props[i]] !== undefined)
                    return true;
                return false;
              })(document.createElement('swipe'))
            };
            var container = options.el;
            if (!container)
              return ;
            var element = container.children[0];
            var slides,
                slidePos,
                width,
                length;
            options = options || {};
            var index = parseInt(options.startSlide, 10) || 0;
            var speed = options.speed || 300;
            options.continuous = options.continuous !== undefined ? options.continuous : true;
            function setup() {
              if (!container.offsetWidth) {
                return ;
              }
              slides = element.children;
              length = slides.length;
              if (slides.length < 2)
                options.continuous = false;
              if (browser.transitions && options.continuous && slides.length < 3) {
                element.appendChild(slides[0].cloneNode(true));
                element.appendChild(element.children[1].cloneNode(true));
                slides = element.children;
              }
              slidePos = new Array(slides.length);
              width = container.offsetWidth || container.getBoundingClientRect().width;
              element.style.width = (slides.length * width) + 'px';
              var pos = slides.length;
              while (pos--) {
                var slide = slides[pos];
                slide.style.width = width + 'px';
                slide.setAttribute('data-index', pos);
                if (browser.transitions) {
                  slide.style.left = (pos * -width) + 'px';
                  move(pos, index > pos ? -width : (index < pos ? width : 0), 0);
                }
              }
              if (options.continuous && browser.transitions) {
                move(circle(index - 1), -width, 0);
                move(circle(index + 1), width, 0);
              }
              if (!browser.transitions)
                element.style.left = (index * -width) + 'px';
              container.style.visibility = 'visible';
              options.slidesChanged && options.slidesChanged();
            }
            function prev(slideSpeed) {
              if (options.continuous)
                slide(index - 1, slideSpeed);
              else if (index)
                slide(index - 1, slideSpeed);
            }
            function next(slideSpeed) {
              if (options.continuous)
                slide(index + 1, slideSpeed);
              else if (index < slides.length - 1)
                slide(index + 1, slideSpeed);
            }
            function circle(index) {
              return (slides.length + (index % slides.length)) % slides.length;
            }
            function slide(to, slideSpeed) {
              if (index == to)
                return ;
              if (browser.transitions) {
                var direction = Math.abs(index - to) / (index - to);
                if (options.continuous) {
                  var naturalDirection = direction;
                  direction = -slidePos[circle(to)] / width;
                  if (direction !== naturalDirection)
                    to = -direction * slides.length + to;
                }
                var diff = Math.abs(index - to) - 1;
                while (diff--)
                  move(circle((to > index ? to : index) - diff - 1), width * direction, 0);
                to = circle(to);
                move(index, width * direction, slideSpeed || speed);
                move(to, 0, slideSpeed || speed);
                if (options.continuous)
                  move(circle(to - direction), -(width * direction), 0);
              } else {
                to = circle(to);
                animate(index * -width, to * -width, slideSpeed || speed);
              }
              index = to;
              offloadFn(options.callback && options.callback(index, slides[index]));
            }
            function move(index, dist, speed) {
              translate(index, dist, speed);
              slidePos[index] = dist;
            }
            function translate(index, dist, speed) {
              var slide = slides[index];
              var style = slide && slide.style;
              if (!style)
                return ;
              style.webkitTransitionDuration = style.MozTransitionDuration = style.msTransitionDuration = style.OTransitionDuration = style.transitionDuration = speed + 'ms';
              style.webkitTransform = 'translate(' + dist + 'px,0)' + 'translateZ(0)';
              style.msTransform = style.MozTransform = style.OTransform = 'translateX(' + dist + 'px)';
            }
            function animate(from, to, speed) {
              if (!speed) {
                element.style.left = to + 'px';
                return ;
              }
              var start = +new Date();
              var timer = setInterval(function() {
                var timeElap = +new Date() - start;
                if (timeElap > speed) {
                  element.style.left = to + 'px';
                  if (delay)
                    begin();
                  options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);
                  clearInterval(timer);
                  return ;
                }
                element.style.left = (((to - from) * (Math.floor((timeElap / speed) * 100) / 100)) + from) + 'px';
              }, 4);
            }
            var delay = options.auto || 0;
            var interval;
            function begin() {
              interval = setTimeout(next, delay);
            }
            function stop() {
              delay = options.auto || 0;
              clearTimeout(interval);
            }
            var start = {};
            var delta = {};
            var isScrolling;
            var events = {
              handleEvent: function(event) {
                if (event.type == 'mousedown' || event.type == 'mouseup' || event.type == 'mousemove') {
                  event.touches = [{
                    pageX: event.pageX,
                    pageY: event.pageY
                  }];
                }
                switch (event.type) {
                  case 'mousedown':
                    this.start(event);
                    break;
                  case 'touchstart':
                    this.start(event);
                    break;
                  case 'touchmove':
                    this.touchmove(event);
                    break;
                  case 'mousemove':
                    this.touchmove(event);
                    break;
                  case 'touchend':
                    offloadFn(this.end(event));
                    break;
                  case 'mouseup':
                    offloadFn(this.end(event));
                    break;
                  case 'webkitTransitionEnd':
                  case 'msTransitionEnd':
                  case 'oTransitionEnd':
                  case 'otransitionend':
                  case 'transitionend':
                    offloadFn(this.transitionEnd(event));
                    break;
                  case 'resize':
                    offloadFn(setup);
                    break;
                }
                if (options.stopPropagation)
                  event.stopPropagation();
              },
              start: function(event) {
                var touches = event.touches[0];
                start = {
                  x: touches.pageX,
                  y: touches.pageY,
                  time: +new Date()
                };
                isScrolling = undefined;
                delta = {};
                if (browser.touch) {
                  element.addEventListener('touchmove', this, false);
                  element.addEventListener('touchend', this, false);
                } else {
                  element.addEventListener('mousemove', this, false);
                  element.addEventListener('mouseup', this, false);
                  document.addEventListener('mouseup', this, false);
                }
              },
              touchmove: function(event) {
                if (event.touches.length > 1 || event.scale && event.scale !== 1 || slider.slideIsDisabled) {
                  return ;
                }
                if (options.disableScroll)
                  event.preventDefault();
                var touches = event.touches[0];
                delta = {
                  x: touches.pageX - start.x,
                  y: touches.pageY - start.y
                };
                if (typeof isScrolling == 'undefined') {
                  isScrolling = !!(isScrolling || Math.abs(delta.x) < Math.abs(delta.y));
                }
                if (!isScrolling) {
                  event.preventDefault();
                  stop();
                  if (options.continuous) {
                    translate(circle(index - 1), delta.x + slidePos[circle(index - 1)], 0);
                    translate(index, delta.x + slidePos[index], 0);
                    translate(circle(index + 1), delta.x + slidePos[circle(index + 1)], 0);
                  } else {
                    delta.x = delta.x / ((!index && delta.x > 0 || index == slides.length - 1 && delta.x < 0) ? (Math.abs(delta.x) / width + 1) : 1);
                    translate(index - 1, delta.x + slidePos[index - 1], 0);
                    translate(index, delta.x + slidePos[index], 0);
                    translate(index + 1, delta.x + slidePos[index + 1], 0);
                  }
                  options.onDrag && options.onDrag();
                }
              },
              end: function() {
                var duration = +new Date() - start.time;
                var isValidSlide = Number(duration) < 250 && Math.abs(delta.x) > 20 || Math.abs(delta.x) > width / 2;
                var isPastBounds = (!index && delta.x > 0) || (index == slides.length - 1 && delta.x < 0);
                if (options.continuous)
                  isPastBounds = false;
                var direction = delta.x < 0;
                if (!isScrolling) {
                  if (isValidSlide && !isPastBounds) {
                    if (direction) {
                      if (options.continuous) {
                        move(circle(index - 1), -width, 0);
                        move(circle(index + 2), width, 0);
                      } else {
                        move(index - 1, -width, 0);
                      }
                      move(index, slidePos[index] - width, speed);
                      move(circle(index + 1), slidePos[circle(index + 1)] - width, speed);
                      index = circle(index + 1);
                    } else {
                      if (options.continuous) {
                        move(circle(index + 1), width, 0);
                        move(circle(index - 2), -width, 0);
                      } else {
                        move(index + 1, width, 0);
                      }
                      move(index, slidePos[index] + width, speed);
                      move(circle(index - 1), slidePos[circle(index - 1)] + width, speed);
                      index = circle(index - 1);
                    }
                    options.callback && options.callback(index, slides[index]);
                  } else {
                    if (options.continuous) {
                      move(circle(index - 1), -width, speed);
                      move(index, 0, speed);
                      move(circle(index + 1), width, speed);
                    } else {
                      move(index - 1, -width, speed);
                      move(index, 0, speed);
                      move(index + 1, width, speed);
                    }
                  }
                }
                if (browser.touch) {
                  element.removeEventListener('touchmove', events, false);
                  element.removeEventListener('touchend', events, false);
                } else {
                  element.removeEventListener('mousemove', events, false);
                  element.removeEventListener('mouseup', events, false);
                  document.removeEventListener('mouseup', events, false);
                }
                options.onDragEnd && options.onDragEnd();
              },
              transitionEnd: function(event) {
                if (parseInt(event.target.getAttribute('data-index'), 10) == index) {
                  if (delay)
                    begin();
                  options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);
                }
              }
            };
            this.update = function() {
              setTimeout(setup);
            };
            this.setup = function() {
              setup();
            };
            this.loop = function(value) {
              if (arguments.length)
                options.continuous = !!value;
              return options.continuous;
            };
            this.enableSlide = function(shouldEnable) {
              if (arguments.length) {
                this.slideIsDisabled = !shouldEnable;
              }
              return !this.slideIsDisabled;
            };
            this.slide = this.select = function(to, speed) {
              stop();
              slide(to, speed);
            };
            this.prev = this.previous = function() {
              stop();
              prev();
            };
            this.next = function() {
              stop();
              next();
            };
            this.stop = function() {
              stop();
            };
            this.start = function() {
              begin();
            };
            this.autoPlay = function(newDelay) {
              if (!delay || delay < 0) {
                stop();
              } else {
                delay = newDelay;
                begin();
              }
            };
            this.currentIndex = this.selected = function() {
              return index;
            };
            this.slidesCount = this.count = function() {
              return length;
            };
            this.kill = function() {
              stop();
              element.style.width = '';
              element.style.left = '';
              slides && (slides = []);
              if (browser.addEventListener) {
                element.removeEventListener('touchstart', events, false);
                element.removeEventListener('webkitTransitionEnd', events, false);
                element.removeEventListener('msTransitionEnd', events, false);
                element.removeEventListener('oTransitionEnd', events, false);
                element.removeEventListener('otransitionend', events, false);
                element.removeEventListener('transitionend', events, false);
                window.removeEventListener('resize', events, false);
              } else {
                window.onresize = null;
              }
            };
            this.load = function() {
              setup();
              if (delay)
                begin();
              if (browser.addEventListener) {
                if (browser.touch) {
                  element.addEventListener('touchstart', events, false);
                } else {
                  element.addEventListener('mousedown', events, false);
                }
                if (browser.transitions) {
                  element.addEventListener('webkitTransitionEnd', events, false);
                  element.addEventListener('msTransitionEnd', events, false);
                  element.addEventListener('oTransitionEnd', events, false);
                  element.addEventListener('otransitionend', events, false);
                  element.addEventListener('transitionend', events, false);
                }
                window.addEventListener('resize', events, false);
              } else {
                window.onresize = function() {
                  setup();
                };
              }
            };
          }});
      })(ionic);
      (function(ionic) {
        'use strict';
        ionic.views.Toggle = ionic.views.View.inherit({
          initialize: function(opts) {
            var self = this;
            this.el = opts.el;
            this.checkbox = opts.checkbox;
            this.track = opts.track;
            this.handle = opts.handle;
            this.openPercent = -1;
            this.onChange = opts.onChange || function() {};
            this.triggerThreshold = opts.triggerThreshold || 20;
            this.dragStartHandler = function(e) {
              self.dragStart(e);
            };
            this.dragHandler = function(e) {
              self.drag(e);
            };
            this.holdHandler = function(e) {
              self.hold(e);
            };
            this.releaseHandler = function(e) {
              self.release(e);
            };
            this.dragStartGesture = ionic.onGesture('dragstart', this.dragStartHandler, this.el);
            this.dragGesture = ionic.onGesture('drag', this.dragHandler, this.el);
            this.dragHoldGesture = ionic.onGesture('hold', this.holdHandler, this.el);
            this.dragReleaseGesture = ionic.onGesture('release', this.releaseHandler, this.el);
          },
          destroy: function() {
            ionic.offGesture(this.dragStartGesture, 'dragstart', this.dragStartGesture);
            ionic.offGesture(this.dragGesture, 'drag', this.dragGesture);
            ionic.offGesture(this.dragHoldGesture, 'hold', this.holdHandler);
            ionic.offGesture(this.dragReleaseGesture, 'release', this.releaseHandler);
          },
          tap: function() {
            if (this.el.getAttribute('disabled') !== 'disabled') {
              this.val(!this.checkbox.checked);
            }
          },
          dragStart: function(e) {
            if (this.checkbox.disabled)
              return ;
            this._dragInfo = {
              width: this.el.offsetWidth,
              left: this.el.offsetLeft,
              right: this.el.offsetLeft + this.el.offsetWidth,
              triggerX: this.el.offsetWidth / 2,
              initialState: this.checkbox.checked
            };
            e.gesture.srcEvent.preventDefault();
            this.hold(e);
          },
          drag: function(e) {
            var self = this;
            if (!this._dragInfo) {
              return ;
            }
            e.gesture.srcEvent.preventDefault();
            ionic.requestAnimationFrame(function() {
              if (!self._dragInfo) {
                return ;
              }
              var px = e.gesture.touches[0].pageX - self._dragInfo.left;
              var mx = self._dragInfo.width - self.triggerThreshold;
              if (self._dragInfo.initialState) {
                if (px < self.triggerThreshold) {
                  self.setOpenPercent(0);
                } else if (px > self._dragInfo.triggerX) {
                  self.setOpenPercent(100);
                }
              } else {
                if (px < self._dragInfo.triggerX) {
                  self.setOpenPercent(0);
                } else if (px > mx) {
                  self.setOpenPercent(100);
                }
              }
            });
          },
          endDrag: function() {
            this._dragInfo = null;
          },
          hold: function() {
            this.el.classList.add('dragging');
          },
          release: function(e) {
            this.el.classList.remove('dragging');
            this.endDrag(e);
          },
          setOpenPercent: function(openPercent) {
            if (this.openPercent < 0 || (openPercent < (this.openPercent - 3) || openPercent > (this.openPercent + 3))) {
              this.openPercent = openPercent;
              if (openPercent === 0) {
                this.val(false);
              } else if (openPercent === 100) {
                this.val(true);
              } else {
                var openPixel = Math.round((openPercent / 100) * this.track.offsetWidth - (this.handle.offsetWidth));
                openPixel = (openPixel < 1 ? 0 : openPixel);
                this.handle.style[ionic.CSS.TRANSFORM] = 'translate3d(' + openPixel + 'px,0,0)';
              }
            }
          },
          val: function(value) {
            if (value === true || value === false) {
              if (this.handle.style[ionic.CSS.TRANSFORM] !== "") {
                this.handle.style[ionic.CSS.TRANSFORM] = "";
              }
              this.checkbox.checked = value;
              this.openPercent = (value ? 100 : 0);
              this.onChange && this.onChange();
            }
            return this.checkbox.checked;
          }
        });
      })(ionic);
    })();
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, false);
});

System.register("github:angular/bower-angular@1.4.4/angular", [], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, []);
  (function() {
    "format global";
    "exports angular";
    (function(window, document, undefined) {
      'use strict';
      function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        return function() {
          var SKIP_INDEXES = 2;
          var templateArgs = arguments,
              code = templateArgs[0],
              message = '[' + (module ? module + ':' : '') + code + '] ',
              template = templateArgs[1],
              paramPrefix,
              i;
          message += template.replace(/\{\d+\}/g, function(match) {
            var index = +match.slice(1, -1),
                shiftedIndex = index + SKIP_INDEXES;
            if (shiftedIndex < templateArgs.length) {
              return toDebugString(templateArgs[shiftedIndex]);
            }
            return match;
          });
          message += '\nhttp://errors.angularjs.org/1.4.4/' + (module ? module + '/' : '') + code;
          for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
            message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' + encodeURIComponent(toDebugString(templateArgs[i]));
          }
          return new ErrorConstructor(message);
        };
      }
      var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
      var VALIDITY_STATE_PROPERTY = 'validity';
      var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
      };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
      };
      var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
      };
      var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
      };
      if ('i' !== 'I'.toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
      }
      var msie,
          jqLite,
          jQuery,
          slice = [].slice,
          splice = [].splice,
          push = [].push,
          toString = Object.prototype.toString,
          getPrototypeOf = Object.getPrototypeOf,
          ngMinErr = minErr('ng'),
          angular = window.angular || (window.angular = {}),
          angularModule,
          uid = 0;
      msie = document.documentMode;
      function isArrayLike(obj) {
        if (obj == null || isWindow(obj)) {
          return false;
        }
        var length = "length" in Object(obj) && obj.length;
        if (obj.nodeType === NODE_TYPE_ELEMENT && length) {
          return true;
        }
        return isString(obj) || isArray(obj) || length === 0 || typeof length === 'number' && length > 0 && (length - 1) in obj;
      }
      function forEach(obj, iterator, context) {
        var key,
            length;
        if (obj) {
          if (isFunction(obj)) {
            for (key in obj) {
              if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = typeof obj !== 'object';
            for (key = 0, length = obj.length; key < length; key++) {
              if (isPrimitive || key in obj) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (obj.forEach && obj.forEach !== forEach) {
            obj.forEach(iterator, context, obj);
          } else if (isBlankObject(obj)) {
            for (key in obj) {
              iterator.call(context, obj[key], key, obj);
            }
          } else if (typeof obj.hasOwnProperty === 'function') {
            for (key in obj) {
              if (obj.hasOwnProperty(key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else {
            for (key in obj) {
              if (hasOwnProperty.call(obj, key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          }
        }
        return obj;
      }
      function forEachSorted(obj, iterator, context) {
        var keys = Object.keys(obj).sort();
        for (var i = 0; i < keys.length; i++) {
          iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
      }
      function reverseParams(iteratorFn) {
        return function(value, key) {
          iteratorFn(key, value);
        };
      }
      function nextUid() {
        return ++uid;
      }
      function setHashKey(obj, h) {
        if (h) {
          obj.$$hashKey = h;
        } else {
          delete obj.$$hashKey;
        }
      }
      function baseExtend(dst, objs, deep) {
        var h = dst.$$hashKey;
        for (var i = 0,
            ii = objs.length; i < ii; ++i) {
          var obj = objs[i];
          if (!isObject(obj) && !isFunction(obj))
            continue;
          var keys = Object.keys(obj);
          for (var j = 0,
              jj = keys.length; j < jj; j++) {
            var key = keys[j];
            var src = obj[key];
            if (deep && isObject(src)) {
              if (isDate(src)) {
                dst[key] = new Date(src.valueOf());
              } else if (isRegExp(src)) {
                dst[key] = new RegExp(src);
              } else {
                if (!isObject(dst[key]))
                  dst[key] = isArray(src) ? [] : {};
                baseExtend(dst[key], [src], true);
              }
            } else {
              dst[key] = src;
            }
          }
        }
        setHashKey(dst, h);
        return dst;
      }
      function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), false);
      }
      function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), true);
      }
      function toInt(str) {
        return parseInt(str, 10);
      }
      function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
      }
      function noop() {}
      noop.$inject = [];
      function identity($) {
        return $;
      }
      identity.$inject = [];
      function valueFn(value) {
        return function() {
          return value;
        };
      }
      function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== Object.prototype.toString;
      }
      function isUndefined(value) {
        return typeof value === 'undefined';
      }
      function isDefined(value) {
        return typeof value !== 'undefined';
      }
      function isObject(value) {
        return value !== null && typeof value === 'object';
      }
      function isBlankObject(value) {
        return value !== null && typeof value === 'object' && !getPrototypeOf(value);
      }
      function isString(value) {
        return typeof value === 'string';
      }
      function isNumber(value) {
        return typeof value === 'number';
      }
      function isDate(value) {
        return toString.call(value) === '[object Date]';
      }
      var isArray = Array.isArray;
      function isFunction(value) {
        return typeof value === 'function';
      }
      function isRegExp(value) {
        return toString.call(value) === '[object RegExp]';
      }
      function isWindow(obj) {
        return obj && obj.window === obj;
      }
      function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
      }
      function isFile(obj) {
        return toString.call(obj) === '[object File]';
      }
      function isFormData(obj) {
        return toString.call(obj) === '[object FormData]';
      }
      function isBlob(obj) {
        return toString.call(obj) === '[object Blob]';
      }
      function isBoolean(value) {
        return typeof value === 'boolean';
      }
      function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
      }
      var TYPED_ARRAY_REGEXP = /^\[object (Uint8(Clamped)?)|(Uint16)|(Uint32)|(Int8)|(Int16)|(Int32)|(Float(32)|(64))Array\]$/;
      function isTypedArray(value) {
        return TYPED_ARRAY_REGEXP.test(toString.call(value));
      }
      var trim = function(value) {
        return isString(value) ? value.trim() : value;
      };
      var escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
      };
      function isElement(node) {
        return !!(node && (node.nodeName || (node.prop && node.attr && node.find)));
      }
      function makeMap(str) {
        var obj = {},
            items = str.split(","),
            i;
        for (i = 0; i < items.length; i++) {
          obj[items[i]] = true;
        }
        return obj;
      }
      function nodeName_(element) {
        return lowercase(element.nodeName || (element[0] && element[0].nodeName));
      }
      function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) != -1;
      }
      function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) {
          array.splice(index, 1);
        }
        return index;
      }
      function copy(source, destination, stackSource, stackDest) {
        if (isWindow(source) || isScope(source)) {
          throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported.");
        }
        if (isTypedArray(destination)) {
          throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated.");
        }
        if (!destination) {
          destination = source;
          if (isObject(source)) {
            var index;
            if (stackSource && (index = stackSource.indexOf(source)) !== -1) {
              return stackDest[index];
            }
            if (isArray(source)) {
              return copy(source, [], stackSource, stackDest);
            } else if (isTypedArray(source)) {
              destination = new source.constructor(source);
            } else if (isDate(source)) {
              destination = new Date(source.getTime());
            } else if (isRegExp(source)) {
              destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
              destination.lastIndex = source.lastIndex;
            } else {
              var emptyObject = Object.create(getPrototypeOf(source));
              return copy(source, emptyObject, stackSource, stackDest);
            }
            if (stackDest) {
              stackSource.push(source);
              stackDest.push(destination);
            }
          }
        } else {
          if (source === destination)
            throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
          stackSource = stackSource || [];
          stackDest = stackDest || [];
          if (isObject(source)) {
            stackSource.push(source);
            stackDest.push(destination);
          }
          var result,
              key;
          if (isArray(source)) {
            destination.length = 0;
            for (var i = 0; i < source.length; i++) {
              destination.push(copy(source[i], null, stackSource, stackDest));
            }
          } else {
            var h = destination.$$hashKey;
            if (isArray(destination)) {
              destination.length = 0;
            } else {
              forEach(destination, function(value, key) {
                delete destination[key];
              });
            }
            if (isBlankObject(source)) {
              for (key in source) {
                destination[key] = copy(source[key], null, stackSource, stackDest);
              }
            } else if (source && typeof source.hasOwnProperty === 'function') {
              for (key in source) {
                if (source.hasOwnProperty(key)) {
                  destination[key] = copy(source[key], null, stackSource, stackDest);
                }
              }
            } else {
              for (key in source) {
                if (hasOwnProperty.call(source, key)) {
                  destination[key] = copy(source[key], null, stackSource, stackDest);
                }
              }
            }
            setHashKey(destination, h);
          }
        }
        return destination;
      }
      function shallowCopy(src, dst) {
        if (isArray(src)) {
          dst = dst || [];
          for (var i = 0,
              ii = src.length; i < ii; i++) {
            dst[i] = src[i];
          }
        } else if (isObject(src)) {
          dst = dst || {};
          for (var key in src) {
            if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
              dst[key] = src[key];
            }
          }
        }
        return dst || src;
      }
      function equals(o1, o2) {
        if (o1 === o2)
          return true;
        if (o1 === null || o2 === null)
          return false;
        if (o1 !== o1 && o2 !== o2)
          return true;
        var t1 = typeof o1,
            t2 = typeof o2,
            length,
            key,
            keySet;
        if (t1 == t2) {
          if (t1 == 'object') {
            if (isArray(o1)) {
              if (!isArray(o2))
                return false;
              if ((length = o1.length) == o2.length) {
                for (key = 0; key < length; key++) {
                  if (!equals(o1[key], o2[key]))
                    return false;
                }
                return true;
              }
            } else if (isDate(o1)) {
              if (!isDate(o2))
                return false;
              return equals(o1.getTime(), o2.getTime());
            } else if (isRegExp(o1)) {
              return isRegExp(o2) ? o1.toString() == o2.toString() : false;
            } else {
              if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
                return false;
              keySet = createMap();
              for (key in o1) {
                if (key.charAt(0) === '$' || isFunction(o1[key]))
                  continue;
                if (!equals(o1[key], o2[key]))
                  return false;
                keySet[key] = true;
              }
              for (key in o2) {
                if (!(key in keySet) && key.charAt(0) !== '$' && o2[key] !== undefined && !isFunction(o2[key]))
                  return false;
              }
              return true;
            }
          }
        }
        return false;
      }
      var csp = function() {
        if (!isDefined(csp.rules)) {
          var ngCspElement = (document.querySelector('[ng-csp]') || document.querySelector('[data-ng-csp]'));
          if (ngCspElement) {
            var ngCspAttribute = ngCspElement.getAttribute('ng-csp') || ngCspElement.getAttribute('data-ng-csp');
            csp.rules = {
              noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),
              noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)
            };
          } else {
            csp.rules = {
              noUnsafeEval: noUnsafeEval(),
              noInlineStyle: false
            };
          }
        }
        return csp.rules;
        function noUnsafeEval() {
          try {
            new Function('');
            return false;
          } catch (e) {
            return true;
          }
        }
      };
      var jq = function() {
        if (isDefined(jq.name_))
          return jq.name_;
        var el;
        var i,
            ii = ngAttrPrefixes.length,
            prefix,
            name;
        for (i = 0; i < ii; ++i) {
          prefix = ngAttrPrefixes[i];
          if (el = document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
            name = el.getAttribute(prefix + 'jq');
            break;
          }
        }
        return (jq.name_ = name);
      };
      function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
      }
      function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
      }
      function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
          return curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
          } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
          };
        } else {
          return fn;
        }
      }
      function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
          val = undefined;
        } else if (isWindow(value)) {
          val = '$WINDOW';
        } else if (value && document === value) {
          val = '$DOCUMENT';
        } else if (isScope(value)) {
          val = '$SCOPE';
        }
        return val;
      }
      function toJson(obj, pretty) {
        if (typeof obj === 'undefined')
          return undefined;
        if (!isNumber(pretty)) {
          pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
      }
      function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
      }
      function timezoneToOffset(timezone, fallback) {
        var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
      }
      function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
      }
      function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
        return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
      }
      function startingTag(element) {
        element = jqLite(element).clone();
        try {
          element.empty();
        } catch (e) {}
        var elemHtml = jqLite('<div>').append(element).html();
        try {
          return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
            return '<' + lowercase(nodeName);
          });
        } catch (e) {
          return lowercase(elemHtml);
        }
      }
      function tryDecodeURIComponent(value) {
        try {
          return decodeURIComponent(value);
        } catch (e) {}
      }
      function parseKeyValue(keyValue) {
        var obj = {};
        forEach((keyValue || "").split('&'), function(keyValue) {
          var splitPoint,
              key,
              val;
          if (keyValue) {
            key = keyValue = keyValue.replace(/\+/g, '%20');
            splitPoint = keyValue.indexOf('=');
            if (splitPoint !== -1) {
              key = keyValue.substring(0, splitPoint);
              val = keyValue.substring(splitPoint + 1);
            }
            key = tryDecodeURIComponent(key);
            if (isDefined(key)) {
              val = isDefined(val) ? tryDecodeURIComponent(val) : true;
              if (!hasOwnProperty.call(obj, key)) {
                obj[key] = val;
              } else if (isArray(obj[key])) {
                obj[key].push(val);
              } else {
                obj[key] = [obj[key], val];
              }
            }
          }
        });
        return obj;
      }
      function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
          if (isArray(value)) {
            forEach(value, function(arrayValue) {
              parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
            });
          } else {
            parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
          }
        });
        return parts.length ? parts.join('&') : '';
      }
      function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
      }
      function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
      }
      var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];
      function getNgAttribute(element, ngAttr) {
        var attr,
            i,
            ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) {
          attr = ngAttrPrefixes[i] + ngAttr;
          if (isString(attr = element.getAttribute(attr))) {
            return attr;
          }
        }
        return null;
      }
      function angularInit(element, bootstrap) {
        var appElement,
            module,
            config = {};
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
            appElement = element;
            module = element.getAttribute(name);
          }
        });
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          var candidate;
          if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
            appElement = candidate;
            module = candidate.getAttribute(name);
          }
        });
        if (appElement) {
          config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
          bootstrap(appElement, module ? [module] : [], config);
        }
      }
      function bootstrap(element, modules, config) {
        if (!isObject(config))
          config = {};
        var defaultConfig = {strictDi: false};
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
          element = jqLite(element);
          if (element.injector()) {
            var tag = (element[0] === document) ? 'document' : startingTag(element);
            throw ngMinErr('btstrpd', "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
          }
          modules = modules || [];
          modules.unshift(['$provide', function($provide) {
            $provide.value('$rootElement', element);
          }]);
          if (config.debugInfoEnabled) {
            modules.push(['$compileProvider', function($compileProvider) {
              $compileProvider.debugInfoEnabled(true);
            }]);
          }
          modules.unshift('ng');
          var injector = createInjector(modules, config.strictDi);
          injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', function bootstrapApply(scope, element, compile, injector) {
            scope.$apply(function() {
              element.data('$injector', injector);
              compile(element)(scope);
            });
          }]);
          return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
          config.debugInfoEnabled = true;
          window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
          return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
        angular.resumeBootstrap = function(extraModules) {
          forEach(extraModules, function(module) {
            modules.push(module);
          });
          return doBootstrap();
        };
        if (isFunction(angular.resumeDeferredBootstrap)) {
          angular.resumeDeferredBootstrap();
        }
      }
      function reloadWithDebugInfo() {
        window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
        window.location.reload();
      }
      function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
          throw ngMinErr('test', 'no injector found for element argument to getTestability');
        }
        return injector.get('$$testability');
      }
      var SNAKE_CASE_REGEXP = /[A-Z]/g;
      function snake_case(name, separator) {
        separator = separator || '_';
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }
      var bindJQueryFired = false;
      var skipDestroyOnNextJQueryCleanData;
      function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
          return ;
        }
        var jqName = jq();
        jQuery = window.jQuery;
        if (isDefined(jqName)) {
          jQuery = jqName === null ? undefined : window[jqName];
        }
        if (jQuery && jQuery.fn.on) {
          jqLite = jQuery;
          extend(jQuery.fn, {
            scope: JQLitePrototype.scope,
            isolateScope: JQLitePrototype.isolateScope,
            controller: JQLitePrototype.controller,
            injector: JQLitePrototype.injector,
            inheritedData: JQLitePrototype.inheritedData
          });
          originalCleanData = jQuery.cleanData;
          jQuery.cleanData = function(elems) {
            var events;
            if (!skipDestroyOnNextJQueryCleanData) {
              for (var i = 0,
                  elem; (elem = elems[i]) != null; i++) {
                events = jQuery._data(elem, "events");
                if (events && events.$destroy) {
                  jQuery(elem).triggerHandler('$destroy');
                }
              }
            } else {
              skipDestroyOnNextJQueryCleanData = false;
            }
            originalCleanData(elems);
          };
        } else {
          jqLite = JQLite;
        }
        angular.element = jqLite;
        bindJQueryFired = true;
      }
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
          arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
        return arg;
      }
      function assertNotHasOwnProperty(name, context) {
        if (name === 'hasOwnProperty') {
          throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
        }
      }
      function getter(obj, path, bindFnToScope) {
        if (!path)
          return obj;
        var keys = path.split('.');
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
          key = keys[i];
          if (obj) {
            obj = (lastInstance = obj)[key];
          }
        }
        if (!bindFnToScope && isFunction(obj)) {
          return bind(lastInstance, obj);
        }
        return obj;
      }
      function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes = [node];
        do {
          node = node.nextSibling;
          if (!node)
            break;
          blockNodes.push(node);
        } while (node !== endNode);
        return jqLite(blockNodes);
      }
      function createMap() {
        return Object.create(null);
      }
      var NODE_TYPE_ELEMENT = 1;
      var NODE_TYPE_ATTRIBUTE = 2;
      var NODE_TYPE_TEXT = 3;
      var NODE_TYPE_COMMENT = 8;
      var NODE_TYPE_DOCUMENT = 9;
      var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
      function setupModuleLoader(window) {
        var $injectorMinErr = minErr('$injector');
        var ngMinErr = minErr('ng');
        function ensure(obj, name, factory) {
          return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, 'angular', Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, 'module', function() {
          var modules = {};
          return function module(name, requires, configFn) {
            var assertNotHasOwnProperty = function(name, context) {
              if (name === 'hasOwnProperty') {
                throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
              }
            };
            assertNotHasOwnProperty(name, 'module');
            if (requires && modules.hasOwnProperty(name)) {
              modules[name] = null;
            }
            return ensure(modules, name, function() {
              if (!requires) {
                throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
              }
              var invokeQueue = [];
              var configBlocks = [];
              var runBlocks = [];
              var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
              var moduleInstance = {
                _invokeQueue: invokeQueue,
                _configBlocks: configBlocks,
                _runBlocks: runBlocks,
                requires: requires,
                name: name,
                provider: invokeLaterAndSetModuleName('$provide', 'provider'),
                factory: invokeLaterAndSetModuleName('$provide', 'factory'),
                service: invokeLaterAndSetModuleName('$provide', 'service'),
                value: invokeLater('$provide', 'value'),
                constant: invokeLater('$provide', 'constant', 'unshift'),
                decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
                animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
                filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
                controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
                directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
                config: config,
                run: function(block) {
                  runBlocks.push(block);
                  return this;
                }
              };
              if (configFn) {
                config(configFn);
              }
              return moduleInstance;
              function invokeLater(provider, method, insertMethod, queue) {
                if (!queue)
                  queue = invokeQueue;
                return function() {
                  queue[insertMethod || 'push']([provider, method, arguments]);
                  return moduleInstance;
                };
              }
              function invokeLaterAndSetModuleName(provider, method) {
                return function(recipeName, factoryFunction) {
                  if (factoryFunction && isFunction(factoryFunction))
                    factoryFunction.$$moduleName = name;
                  invokeQueue.push([provider, method, arguments]);
                  return moduleInstance;
                };
              }
            });
          };
        });
      }
      function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
          val = toJsonReplacer(key, val);
          if (isObject(val)) {
            if (seen.indexOf(val) >= 0)
              return '<<already seen>>';
            seen.push(val);
          }
          return val;
        });
      }
      function toDebugString(obj) {
        if (typeof obj === 'function') {
          return obj.toString().replace(/ \{[\s\S]*$/, '');
        } else if (typeof obj === 'undefined') {
          return 'undefined';
        } else if (typeof obj !== 'string') {
          return serializeObject(obj);
        }
        return obj;
      }
      var version = {
        full: '1.4.4',
        major: 1,
        minor: 4,
        dot: 4,
        codeName: 'pylon-requirement'
      };
      function publishExternalAPI(angular) {
        extend(angular, {
          'bootstrap': bootstrap,
          'copy': copy,
          'extend': extend,
          'merge': merge,
          'equals': equals,
          'element': jqLite,
          'forEach': forEach,
          'injector': createInjector,
          'noop': noop,
          'bind': bind,
          'toJson': toJson,
          'fromJson': fromJson,
          'identity': identity,
          'isUndefined': isUndefined,
          'isDefined': isDefined,
          'isString': isString,
          'isFunction': isFunction,
          'isObject': isObject,
          'isNumber': isNumber,
          'isElement': isElement,
          'isArray': isArray,
          'version': version,
          'isDate': isDate,
          'lowercase': lowercase,
          'uppercase': uppercase,
          'callbacks': {counter: 0},
          'getTestability': getTestability,
          '$$minErr': minErr,
          '$$csp': csp,
          'reloadWithDebugInfo': reloadWithDebugInfo
        });
        angularModule = setupModuleLoader(window);
        angularModule('ng', ['ngLocale'], ['$provide', function ngModule($provide) {
          $provide.provider({$$sanitizeUri: $$SanitizeUriProvider});
          $provide.provider('$compile', $CompileProvider).directive({
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            pattern: patternDirective,
            ngPattern: patternDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            minlength: minlengthDirective,
            ngMinlength: minlengthDirective,
            maxlength: maxlengthDirective,
            ngMaxlength: maxlengthDirective,
            ngValue: ngValueDirective,
            ngModelOptions: ngModelOptionsDirective
          }).directive({ngInclude: ngIncludeFillContentDirective}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
          $provide.provider({
            $anchorScroll: $AnchorScrollProvider,
            $animate: $AnimateProvider,
            $animateCss: $CoreAnimateCssProvider,
            $$animateQueue: $$CoreAnimateQueueProvider,
            $$AnimateRunner: $$CoreAnimateRunnerProvider,
            $browser: $BrowserProvider,
            $cacheFactory: $CacheFactoryProvider,
            $controller: $ControllerProvider,
            $document: $DocumentProvider,
            $exceptionHandler: $ExceptionHandlerProvider,
            $filter: $FilterProvider,
            $$forceReflow: $$ForceReflowProvider,
            $interpolate: $InterpolateProvider,
            $interval: $IntervalProvider,
            $http: $HttpProvider,
            $httpParamSerializer: $HttpParamSerializerProvider,
            $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
            $httpBackend: $HttpBackendProvider,
            $location: $LocationProvider,
            $log: $LogProvider,
            $parse: $ParseProvider,
            $rootScope: $RootScopeProvider,
            $q: $QProvider,
            $$q: $$QProvider,
            $sce: $SceProvider,
            $sceDelegate: $SceDelegateProvider,
            $sniffer: $SnifferProvider,
            $templateCache: $TemplateCacheProvider,
            $templateRequest: $TemplateRequestProvider,
            $$testability: $$TestabilityProvider,
            $timeout: $TimeoutProvider,
            $window: $WindowProvider,
            $$rAF: $$RAFProvider,
            $$jqLite: $$jqLiteProvider,
            $$HashMap: $$HashMapProvider,
            $$cookieReader: $$CookieReaderProvider
          });
        }]);
      }
      JQLite.expando = 'ng339';
      var jqCache = JQLite.cache = {},
          jqId = 1,
          addEventListenerFn = function(element, type, fn) {
            element.addEventListener(type, fn, false);
          },
          removeEventListenerFn = function(element, type, fn) {
            element.removeEventListener(type, fn, false);
          };
      JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
      };
      function jqNextId() {
        return ++jqId;
      }
      var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
      var MOZ_HACK_REGEXP = /^moz([A-Z])/;
      var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
      };
      var jqLiteMinErr = minErr('jqLite');
      function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
          return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, 'Moz$1');
      }
      var SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
      var HTML_REGEXP = /<|&#?\w+;/;
      var TAG_NAME_REGEXP = /<([\w:]+)/;
      var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;
      var wrapMap = {
        'option': [1, '<select multiple="multiple">', '</select>'],
        'thead': [1, '<table>', '</table>'],
        'col': [2, '<table><colgroup>', '</colgroup></table>'],
        'tr': [2, '<table><tbody>', '</tbody></table>'],
        'td': [3, '<table><tbody><tr>', '</tr></tbody></table>'],
        '_default': [0, "", ""]
      };
      wrapMap.optgroup = wrapMap.option;
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
      }
      function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
      }
      function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) {
          return true;
        }
        return false;
      }
      function jqLiteBuildFragment(html, context) {
        var tmp,
            tag,
            wrap,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i;
        if (jqLiteIsTextNode(html)) {
          nodes.push(context.createTextNode(html));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
          i = wrap[0];
          while (i--) {
            tmp = tmp.lastChild;
          }
          nodes = concat(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
          fragment.appendChild(node);
        });
        return fragment;
      }
      function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
          return [context.createElement(parsed[1])];
        }
        if ((parsed = jqLiteBuildFragment(html, context))) {
          return parsed.childNodes;
        }
        return [];
      }
      function JQLite(element) {
        if (element instanceof JQLite) {
          return element;
        }
        var argIsString;
        if (isString(element)) {
          element = trim(element);
          argIsString = true;
        }
        if (!(this instanceof JQLite)) {
          if (argIsString && element.charAt(0) != '<') {
            throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
          }
          return new JQLite(element);
        }
        if (argIsString) {
          jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else {
          jqLiteAddNodes(this, element);
        }
      }
      function jqLiteClone(element) {
        return element.cloneNode(true);
      }
      function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants)
          jqLiteRemoveData(element);
        if (element.querySelectorAll) {
          var descendants = element.querySelectorAll('*');
          for (var i = 0,
              l = descendants.length; i < l; i++) {
            jqLiteRemoveData(descendants[i]);
          }
        }
      }
      function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported))
          throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle)
          return ;
        if (!type) {
          for (type in events) {
            if (type !== '$destroy') {
              removeEventListenerFn(element, type, handle);
            }
            delete events[type];
          }
        } else {
          forEach(type.split(' '), function(type) {
            if (isDefined(fn)) {
              var listenerFns = events[type];
              arrayRemove(listenerFns || [], fn);
              if (listenerFns && listenerFns.length > 0) {
                return ;
              }
            }
            removeEventListenerFn(element, type, handle);
            delete events[type];
          });
        }
      }
      function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
          if (name) {
            delete expandoStore.data[name];
            return ;
          }
          if (expandoStore.handle) {
            if (expandoStore.events.$destroy) {
              expandoStore.handle({}, '$destroy');
            }
            jqLiteOff(element);
          }
          delete jqCache[expandoId];
          element.ng339 = undefined;
        }
      }
      function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339,
            expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
          element.ng339 = expandoId = jqNextId();
          expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: undefined
          };
        }
        return expandoStore;
      }
      function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
          var isSimpleSetter = isDefined(value);
          var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
          var massGetter = !key;
          var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
          var data = expandoStore && expandoStore.data;
          if (isSimpleSetter) {
            data[key] = value;
          } else {
            if (massGetter) {
              return data;
            } else {
              if (isSimpleGetter) {
                return data && data[key];
              } else {
                extend(data, key);
              }
            }
          }
        }
      }
      function jqLiteHasClass(element, selector) {
        if (!element.getAttribute)
          return false;
        return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1);
      }
      function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          forEach(cssClasses.split(' '), function(cssClass) {
            element.setAttribute('class', trim((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
          });
        }
      }
      function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
          forEach(cssClasses.split(' '), function(cssClass) {
            cssClass = trim(cssClass);
            if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
              existingClasses += cssClass + ' ';
            }
          });
          element.setAttribute('class', trim(existingClasses));
        }
      }
      function jqLiteAddNodes(root, elements) {
        if (elements) {
          if (elements.nodeType) {
            root[root.length++] = elements;
          } else {
            var length = elements.length;
            if (typeof length === 'number' && elements.window !== elements) {
              if (length) {
                for (var i = 0; i < length; i++) {
                  root[root.length++] = elements[i];
                }
              }
            } else {
              root[root.length++] = elements;
            }
          }
        }
      }
      function jqLiteController(element, name) {
        return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
      }
      function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == NODE_TYPE_DOCUMENT) {
          element = element.documentElement;
        }
        var names = isArray(name) ? name : [name];
        while (element) {
          for (var i = 0,
              ii = names.length; i < ii; i++) {
            if ((value = jqLite.data(element, names[i])) !== undefined)
              return value;
          }
          element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
        }
      }
      function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
      }
      function jqLiteRemove(element, keepData) {
        if (!keepData)
          jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent)
          parent.removeChild(element);
      }
      function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === 'complete') {
          win.setTimeout(action);
        } else {
          jqLite(win).on('load', action);
        }
      }
      var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
          var fired = false;
          function trigger() {
            if (fired)
              return ;
            fired = true;
            fn();
          }
          if (document.readyState === 'complete') {
            setTimeout(trigger);
          } else {
            this.on('DOMContentLoaded', trigger);
            JQLite(window).on('load', trigger);
          }
        },
        toString: function() {
          var value = [];
          forEach(this, function(e) {
            value.push('' + e);
          });
          return '[' + value.join(', ') + ']';
        },
        eq: function(index) {
          return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
      };
      var BOOLEAN_ATTR = {};
      forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
      });
      var BOOLEAN_ELEMENTS = {};
      forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
      });
      var ALIASED_ATTR = {
        'ngMinlength': 'minlength',
        'ngMaxlength': 'maxlength',
        'ngMin': 'min',
        'ngMax': 'max',
        'ngPattern': 'pattern'
      };
      function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
      }
      function getAliasedAttrName(element, name) {
        var nodeName = element.nodeName;
        return (nodeName === 'INPUT' || nodeName === 'TEXTAREA') && ALIASED_ATTR[name];
      }
      forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData
      }, function(fn, name) {
        JQLite[name] = fn;
      });
      forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
          return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
        },
        isolateScope: function(element) {
          return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
        },
        controller: jqLiteController,
        injector: function(element) {
          return jqLiteInheritedData(element, '$injector');
        },
        removeAttr: function(element, name) {
          element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
          name = camelCase(name);
          if (isDefined(value)) {
            element.style[name] = value;
          } else {
            return element.style[name];
          }
        },
        attr: function(element, name, value) {
          var nodeType = element.nodeType;
          if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
            return ;
          }
          var lowercasedName = lowercase(name);
          if (BOOLEAN_ATTR[lowercasedName]) {
            if (isDefined(value)) {
              if (!!value) {
                element[name] = true;
                element.setAttribute(name, lowercasedName);
              } else {
                element[name] = false;
                element.removeAttribute(lowercasedName);
              }
            } else {
              return (element[name] || (element.attributes.getNamedItem(name) || noop).specified) ? lowercasedName : undefined;
            }
          } else if (isDefined(value)) {
            element.setAttribute(name, value);
          } else if (element.getAttribute) {
            var ret = element.getAttribute(name, 2);
            return ret === null ? undefined : ret;
          }
        },
        prop: function(element, name, value) {
          if (isDefined(value)) {
            element[name] = value;
          } else {
            return element[name];
          }
        },
        text: (function() {
          getText.$dv = '';
          return getText;
          function getText(element, value) {
            if (isUndefined(value)) {
              var nodeType = element.nodeType;
              return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
            }
            element.textContent = value;
          }
        })(),
        val: function(element, value) {
          if (isUndefined(value)) {
            if (element.multiple && nodeName_(element) === 'select') {
              var result = [];
              forEach(element.options, function(option) {
                if (option.selected) {
                  result.push(option.value || option.text);
                }
              });
              return result.length === 0 ? null : result;
            }
            return element.value;
          }
          element.value = value;
        },
        html: function(element, value) {
          if (isUndefined(value)) {
            return element.innerHTML;
          }
          jqLiteDealoc(element, true);
          element.innerHTML = value;
        },
        empty: jqLiteEmpty
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
          var i,
              key;
          var nodeCount = this.length;
          if (fn !== jqLiteEmpty && (((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2) === undefined)) {
            if (isObject(arg1)) {
              for (i = 0; i < nodeCount; i++) {
                if (fn === jqLiteData) {
                  fn(this[i], arg1);
                } else {
                  for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                  }
                }
              }
              return this;
            } else {
              var value = fn.$dv;
              var jj = (value === undefined) ? Math.min(nodeCount, 1) : nodeCount;
              for (var j = 0; j < jj; j++) {
                var nodeValue = fn(this[j], arg1, arg2);
                value = value ? value + nodeValue : nodeValue;
              }
              return value;
            }
          } else {
            for (i = 0; i < nodeCount; i++) {
              fn(this[i], arg1, arg2);
            }
            return this;
          }
        };
      });
      function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
          event.isDefaultPrevented = function() {
            return event.defaultPrevented;
          };
          var eventFns = events[type || event.type];
          var eventFnsLength = eventFns ? eventFns.length : 0;
          if (!eventFnsLength)
            return ;
          if (isUndefined(event.immediatePropagationStopped)) {
            var originalStopImmediatePropagation = event.stopImmediatePropagation;
            event.stopImmediatePropagation = function() {
              event.immediatePropagationStopped = true;
              if (event.stopPropagation) {
                event.stopPropagation();
              }
              if (originalStopImmediatePropagation) {
                originalStopImmediatePropagation.call(event);
              }
            };
          }
          event.isImmediatePropagationStopped = function() {
            return event.immediatePropagationStopped === true;
          };
          if ((eventFnsLength > 1)) {
            eventFns = shallowCopy(eventFns);
          }
          for (var i = 0; i < eventFnsLength; i++) {
            if (!event.isImmediatePropagationStopped()) {
              eventFns[i].call(element, event);
            }
          }
        };
        eventHandler.elem = element;
        return eventHandler;
      }
      forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
          if (isDefined(unsupported))
            throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
          if (!jqLiteAcceptsData(element)) {
            return ;
          }
          var expandoStore = jqLiteExpandoStore(element, true);
          var events = expandoStore.events;
          var handle = expandoStore.handle;
          if (!handle) {
            handle = expandoStore.handle = createEventHandler(element, events);
          }
          var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
          var i = types.length;
          while (i--) {
            type = types[i];
            var eventFns = events[type];
            if (!eventFns) {
              events[type] = [];
              if (type === 'mouseenter' || type === 'mouseleave') {
                jqLiteOn(element, MOUSE_EVENT_MAP[type], function(event) {
                  var target = this,
                      related = event.relatedTarget;
                  if (!related || (related !== target && !target.contains(related))) {
                    handle(event, type);
                  }
                });
              } else {
                if (type !== '$destroy') {
                  addEventListenerFn(element, type, handle);
                }
              }
              eventFns = events[type];
            }
            eventFns.push(fn);
          }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
          element = jqLite(element);
          element.on(type, function onFn() {
            element.off(type, fn);
            element.off(type, onFn);
          });
          element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
          var index,
              parent = element.parentNode;
          jqLiteDealoc(element);
          forEach(new JQLite(replaceNode), function(node) {
            if (index) {
              parent.insertBefore(node, index.nextSibling);
            } else {
              parent.replaceChild(node, element);
            }
            index = node;
          });
        },
        children: function(element) {
          var children = [];
          forEach(element.childNodes, function(element) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
              children.push(element);
            }
          });
          return children;
        },
        contents: function(element) {
          return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
          var nodeType = element.nodeType;
          if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
            return ;
          node = new JQLite(node);
          for (var i = 0,
              ii = node.length; i < ii; i++) {
            var child = node[i];
            element.appendChild(child);
          }
        },
        prepend: function(element, node) {
          if (element.nodeType === NODE_TYPE_ELEMENT) {
            var index = element.firstChild;
            forEach(new JQLite(node), function(child) {
              element.insertBefore(child, index);
            });
          }
        },
        wrap: function(element, wrapNode) {
          wrapNode = jqLite(wrapNode).eq(0).clone()[0];
          var parent = element.parentNode;
          if (parent) {
            parent.replaceChild(wrapNode, element);
          }
          wrapNode.appendChild(element);
        },
        remove: jqLiteRemove,
        detach: function(element) {
          jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
          var index = element,
              parent = element.parentNode;
          newElement = new JQLite(newElement);
          for (var i = 0,
              ii = newElement.length; i < ii; i++) {
            var node = newElement[i];
            parent.insertBefore(node, index.nextSibling);
            index = node;
          }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
          if (selector) {
            forEach(selector.split(' '), function(className) {
              var classCondition = condition;
              if (isUndefined(classCondition)) {
                classCondition = !jqLiteHasClass(element, className);
              }
              (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
          }
        },
        parent: function(element) {
          var parent = element.parentNode;
          return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
          return element.nextElementSibling;
        },
        find: function(element, selector) {
          if (element.getElementsByTagName) {
            return element.getElementsByTagName(selector);
          } else {
            return [];
          }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
          var dummyEvent,
              eventFnsCopy,
              handlerArgs;
          var eventName = event.type || event;
          var expandoStore = jqLiteExpandoStore(element);
          var events = expandoStore && expandoStore.events;
          var eventFns = events && events[eventName];
          if (eventFns) {
            dummyEvent = {
              preventDefault: function() {
                this.defaultPrevented = true;
              },
              isDefaultPrevented: function() {
                return this.defaultPrevented === true;
              },
              stopImmediatePropagation: function() {
                this.immediatePropagationStopped = true;
              },
              isImmediatePropagationStopped: function() {
                return this.immediatePropagationStopped === true;
              },
              stopPropagation: noop,
              type: eventName,
              target: element
            };
            if (event.type) {
              dummyEvent = extend(dummyEvent, event);
            }
            eventFnsCopy = shallowCopy(eventFns);
            handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
            forEach(eventFnsCopy, function(fn) {
              if (!dummyEvent.isImmediatePropagationStopped()) {
                fn.apply(element, handlerArgs);
              }
            });
          }
        }
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
          var value;
          for (var i = 0,
              ii = this.length; i < ii; i++) {
            if (isUndefined(value)) {
              value = fn(this[i], arg1, arg2, arg3);
              if (isDefined(value)) {
                value = jqLite(value);
              }
            } else {
              jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            }
          }
          return isDefined(value) ? value : this;
        };
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
      });
      function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
          return extend(JQLite, {
            hasClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteHasClass(node, classes);
            },
            addClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteAddClass(node, classes);
            },
            removeClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteRemoveClass(node, classes);
            }
          });
        };
      }
      function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
          if (typeof key === 'function') {
            key = obj.$$hashKey();
          }
          return key;
        }
        var objType = typeof obj;
        if (objType == 'function' || (objType == 'object' && obj !== null)) {
          key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
        } else {
          key = objType + ':' + obj;
        }
        return key;
      }
      function HashMap(array, isolatedUid) {
        if (isolatedUid) {
          var uid = 0;
          this.nextUid = function() {
            return ++uid;
          };
        }
        forEach(array, this.put, this);
      }
      HashMap.prototype = {
        put: function(key, value) {
          this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
          return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
          var value = this[key = hashKey(key, this.nextUid)];
          delete this[key];
          return value;
        }
      };
      var $$HashMapProvider = [function() {
        this.$get = [function() {
          return HashMap;
        }];
      }];
      var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
      var $injectorMinErr = minErr('$injector');
      function anonFn(fn) {
        var fnText = fn.toString().replace(STRIP_COMMENTS, ''),
            args = fnText.match(FN_ARGS);
        if (args) {
          return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
        }
        return 'fn';
      }
      function annotate(fn, strictDi, name) {
        var $inject,
            fnText,
            argDecl,
            last;
        if (typeof fn === 'function') {
          if (!($inject = fn.$inject)) {
            $inject = [];
            if (fn.length) {
              if (strictDi) {
                if (!isString(name) || !name) {
                  name = fn.name || anonFn(fn);
                }
                throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
              }
              fnText = fn.toString().replace(STRIP_COMMENTS, '');
              argDecl = fnText.match(FN_ARGS);
              forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                arg.replace(FN_ARG, function(all, underscore, name) {
                  $inject.push(name);
                });
              });
            }
            fn.$inject = $inject;
          }
        } else if (isArray(fn)) {
          last = fn.length - 1;
          assertArgFn(fn[last], 'fn');
          $inject = fn.slice(0, last);
        } else {
          assertArgFn(fn, 'fn', true);
        }
        return $inject;
      }
      function createInjector(modulesToLoad, strictDi) {
        strictDi = (strictDi === true);
        var INSTANTIATING = {},
            providerSuffix = 'Provider',
            path = [],
            loadedModules = new HashMap([], true),
            providerCache = {$provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
              }},
            providerInjector = (providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
              if (angular.isString(caller)) {
                path.push(caller);
              }
              throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
            })),
            instanceCache = {},
            instanceInjector = (instanceCache.$injector = createInternalInjector(instanceCache, function(serviceName, caller) {
              var provider = providerInjector.get(serviceName + providerSuffix, caller);
              return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
            }));
        forEach(loadModules(modulesToLoad), function(fn) {
          if (fn)
            instanceInjector.invoke(fn);
        });
        return instanceInjector;
        function supportObject(delegate) {
          return function(key, value) {
            if (isObject(key)) {
              forEach(key, reverseParams(delegate));
            } else {
              return delegate(key, value);
            }
          };
        }
        function provider(name, provider_) {
          assertNotHasOwnProperty(name, 'service');
          if (isFunction(provider_) || isArray(provider_)) {
            provider_ = providerInjector.instantiate(provider_);
          }
          if (!provider_.$get) {
            throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
          }
          return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
          return function enforcedReturnValue() {
            var result = instanceInjector.invoke(factory, this);
            if (isUndefined(result)) {
              throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
            }
            return result;
          };
        }
        function factory(name, factoryFn, enforce) {
          return provider(name, {$get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn});
        }
        function service(name, constructor) {
          return factory(name, ['$injector', function($injector) {
            return $injector.instantiate(constructor);
          }]);
        }
        function value(name, val) {
          return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
          assertNotHasOwnProperty(name, 'constant');
          providerCache[name] = value;
          instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
          var origProvider = providerInjector.get(serviceName + providerSuffix),
              orig$get = origProvider.$get;
          origProvider.$get = function() {
            var origInstance = instanceInjector.invoke(orig$get, origProvider);
            return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
          };
        }
        function loadModules(modulesToLoad) {
          assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
          var runBlocks = [],
              moduleFn;
          forEach(modulesToLoad, function(module) {
            if (loadedModules.get(module))
              return ;
            loadedModules.put(module, true);
            function runInvokeQueue(queue) {
              var i,
                  ii;
              for (i = 0, ii = queue.length; i < ii; i++) {
                var invokeArgs = queue[i],
                    provider = providerInjector.get(invokeArgs[0]);
                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
              }
            }
            try {
              if (isString(module)) {
                moduleFn = angularModule(module);
                runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                runInvokeQueue(moduleFn._invokeQueue);
                runInvokeQueue(moduleFn._configBlocks);
              } else if (isFunction(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else if (isArray(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else {
                assertArgFn(module, 'module');
              }
            } catch (e) {
              if (isArray(module)) {
                module = module[module.length - 1];
              }
              if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                e = e.message + '\n' + e.stack;
              }
              throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
            }
          });
          return runBlocks;
        }
        function createInternalInjector(cache, factory) {
          function getService(serviceName, caller) {
            if (cache.hasOwnProperty(serviceName)) {
              if (cache[serviceName] === INSTANTIATING) {
                throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
              }
              return cache[serviceName];
            } else {
              try {
                path.unshift(serviceName);
                cache[serviceName] = INSTANTIATING;
                return cache[serviceName] = factory(serviceName, caller);
              } catch (err) {
                if (cache[serviceName] === INSTANTIATING) {
                  delete cache[serviceName];
                }
                throw err;
              } finally {
                path.shift();
              }
            }
          }
          function invoke(fn, self, locals, serviceName) {
            if (typeof locals === 'string') {
              serviceName = locals;
              locals = null;
            }
            var args = [],
                $inject = createInjector.$$annotate(fn, strictDi, serviceName),
                length,
                i,
                key;
            for (i = 0, length = $inject.length; i < length; i++) {
              key = $inject[i];
              if (typeof key !== 'string') {
                throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
              }
              args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
            }
            if (isArray(fn)) {
              fn = fn[length];
            }
            return fn.apply(self, args);
          }
          function instantiate(Type, locals, serviceName) {
            var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null);
            var returnedValue = invoke(Type, instance, locals, serviceName);
            return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
          }
          return {
            invoke: invoke,
            instantiate: instantiate,
            get: getService,
            annotate: createInjector.$$annotate,
            has: function(name) {
              return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
            }
          };
        }
      }
      createInjector.$$annotate = annotate;
      function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
          autoScrollingEnabled = false;
        };
        this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
          var document = $window.document;
          function getFirstAnchor(list) {
            var result = null;
            Array.prototype.some.call(list, function(element) {
              if (nodeName_(element) === 'a') {
                result = element;
                return true;
              }
            });
            return result;
          }
          function getYOffset() {
            var offset = scroll.yOffset;
            if (isFunction(offset)) {
              offset = offset();
            } else if (isElement(offset)) {
              var elem = offset[0];
              var style = $window.getComputedStyle(elem);
              if (style.position !== 'fixed') {
                offset = 0;
              } else {
                offset = elem.getBoundingClientRect().bottom;
              }
            } else if (!isNumber(offset)) {
              offset = 0;
            }
            return offset;
          }
          function scrollTo(elem) {
            if (elem) {
              elem.scrollIntoView();
              var offset = getYOffset();
              if (offset) {
                var elemTop = elem.getBoundingClientRect().top;
                $window.scrollBy(0, elemTop - offset);
              }
            } else {
              $window.scrollTo(0, 0);
            }
          }
          function scroll(hash) {
            hash = isString(hash) ? hash : $location.hash();
            var elm;
            if (!hash)
              scrollTo(null);
            else if ((elm = document.getElementById(hash)))
              scrollTo(elm);
            else if ((elm = getFirstAnchor(document.getElementsByName(hash))))
              scrollTo(elm);
            else if (hash === 'top')
              scrollTo(null);
          }
          if (autoScrollingEnabled) {
            $rootScope.$watch(function autoScrollWatch() {
              return $location.hash();
            }, function autoScrollWatchAction(newVal, oldVal) {
              if (newVal === oldVal && newVal === '')
                return ;
              jqLiteDocumentLoaded(function() {
                $rootScope.$evalAsync(scroll);
              });
            });
          }
          return scroll;
        }];
      }
      var $animateMinErr = minErr('$animate');
      var ELEMENT_NODE = 1;
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType === ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function splitClasses(classes) {
        if (isString(classes)) {
          classes = classes.split(' ');
        }
        var obj = createMap();
        forEach(classes, function(klass) {
          if (klass.length) {
            obj[klass] = true;
          }
        });
        return obj;
      }
      function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
      }
      var $$CoreAnimateRunnerProvider = function() {
        this.$get = ['$q', '$$rAF', function($q, $$rAF) {
          function AnimateRunner() {}
          AnimateRunner.all = noop;
          AnimateRunner.chain = noop;
          AnimateRunner.prototype = {
            end: noop,
            cancel: noop,
            resume: noop,
            pause: noop,
            complete: noop,
            then: function(pass, fail) {
              return $q(function(resolve) {
                $$rAF(function() {
                  resolve();
                });
              }).then(pass, fail);
            }
          };
          return AnimateRunner;
        }];
      };
      var $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new HashMap();
        var postDigestElements = [];
        this.$get = ['$$AnimateRunner', '$rootScope', function($$AnimateRunner, $rootScope) {
          return {
            enabled: noop,
            on: noop,
            off: noop,
            pin: noop,
            push: function(element, event, options, domOperation) {
              domOperation && domOperation();
              options = options || {};
              options.from && element.css(options.from);
              options.to && element.css(options.to);
              if (options.addClass || options.removeClass) {
                addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
              }
              return new $$AnimateRunner();
            }
          };
          function addRemoveClassesPostDigest(element, add, remove) {
            var classVal,
                data = postDigestQueue.get(element);
            if (!data) {
              postDigestQueue.put(element, data = {});
              postDigestElements.push(element);
            }
            var updateData = function(classes, value) {
              var changed = false;
              if (classes) {
                classes = isString(classes) ? classes.split(' ') : isArray(classes) ? classes : [];
                forEach(classes, function(className) {
                  if (className) {
                    changed = true;
                    data[className] = value;
                  }
                });
              }
              return changed;
            };
            var classesAdded = updateData(add, true);
            var classesRemoved = updateData(remove, false);
            if ((!classesAdded && !classesRemoved) || postDigestElements.length > 1)
              return ;
            $rootScope.$$postDigest(function() {
              forEach(postDigestElements, function(element) {
                var data = postDigestQueue.get(element);
                if (data) {
                  var existing = splitClasses(element.attr('class'));
                  var toAdd = '';
                  var toRemove = '';
                  forEach(data, function(status, className) {
                    var hasClass = !!existing[className];
                    if (status !== hasClass) {
                      if (status) {
                        toAdd += (toAdd.length ? ' ' : '') + className;
                      } else {
                        toRemove += (toRemove.length ? ' ' : '') + className;
                      }
                    }
                  });
                  forEach(element, function(elm) {
                    toAdd && jqLiteAddClass(elm, toAdd);
                    toRemove && jqLiteRemoveClass(elm, toRemove);
                  });
                  postDigestQueue.remove(element);
                }
              });
              postDigestElements.length = 0;
            });
          }
        }];
      };
      var $AnimateProvider = ['$provide', function($provide) {
        var provider = this;
        this.$$registeredAnimations = Object.create(null);
        this.register = function(name, factory) {
          if (name && name.charAt(0) !== '.') {
            throw $animateMinErr('notcsel', "Expecting class selector starting with '.' got '{0}'.", name);
          }
          var key = name + '-animation';
          provider.$$registeredAnimations[name.substr(1)] = key;
          $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
          if (arguments.length === 1) {
            this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
            if (this.$$classNameFilter) {
              var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
              if (reservedRegex.test(this.$$classNameFilter.toString())) {
                throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
              }
            }
          }
          return this.$$classNameFilter;
        };
        this.$get = ['$$animateQueue', function($$animateQueue) {
          function domInsert(element, parentElement, afterElement) {
            if (afterElement) {
              var afterNode = extractElementNode(afterElement);
              if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                afterElement = null;
              }
            }
            afterElement ? afterElement.after(element) : parentElement.prepend(element);
          }
          return {
            on: $$animateQueue.on,
            off: $$animateQueue.off,
            pin: $$animateQueue.pin,
            enabled: $$animateQueue.enabled,
            cancel: function(runner) {
              runner.end && runner.end();
            },
            enter: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
            },
            move: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
            },
            leave: function(element, options) {
              return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function() {
                element.remove();
              });
            },
            addClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addclass, className);
              return $$animateQueue.push(element, 'addClass', options);
            },
            removeClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.removeClass = mergeClasses(options.removeClass, className);
              return $$animateQueue.push(element, 'removeClass', options);
            },
            setClass: function(element, add, remove, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addClass, add);
              options.removeClass = mergeClasses(options.removeClass, remove);
              return $$animateQueue.push(element, 'setClass', options);
            },
            animate: function(element, from, to, className, options) {
              options = prepareAnimateOptions(options);
              options.from = options.from ? extend(options.from, from) : from;
              options.to = options.to ? extend(options.to, to) : to;
              className = className || 'ng-inline-animate';
              options.tempClasses = mergeClasses(options.tempClasses, className);
              return $$animateQueue.push(element, 'animate', options);
            }
          };
        }];
      }];
      var $CoreAnimateCssProvider = function() {
        this.$get = ['$$rAF', '$q', function($$rAF, $q) {
          var RAFPromise = function() {};
          RAFPromise.prototype = {
            done: function(cancel) {
              this.defer && this.defer[cancel === true ? 'reject' : 'resolve']();
            },
            end: function() {
              this.done();
            },
            cancel: function() {
              this.done(true);
            },
            getPromise: function() {
              if (!this.defer) {
                this.defer = $q.defer();
              }
              return this.defer.promise;
            },
            then: function(f1, f2) {
              return this.getPromise().then(f1, f2);
            },
            'catch': function(f1) {
              return this.getPromise().catch(f1);
            },
            'finally': function(f1) {
              return this.getPromise().finally(f1);
            }
          };
          return function(element, options) {
            if (options.from) {
              element.css(options.from);
              options.from = null;
            }
            var closed,
                runner = new RAFPromise();
            return {
              start: run,
              end: run
            };
            function run() {
              $$rAF(function() {
                close();
                if (!closed) {
                  runner.done();
                }
                closed = true;
              });
              return runner;
            }
            function close() {
              if (options.addClass) {
                element.addClass(options.addClass);
                options.addClass = null;
              }
              if (options.removeClass) {
                element.removeClass(options.removeClass);
                options.removeClass = null;
              }
              if (options.to) {
                element.css(options.to);
                options.to = null;
              }
            }
          };
        }];
      };
      function Browser(window, document, $log, $sniffer) {
        var self = this,
            rawDocument = document[0],
            location = window.location,
            history = window.history,
            setTimeout = window.setTimeout,
            clearTimeout = window.clearTimeout,
            pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
          outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
          try {
            fn.apply(null, sliceArgs(arguments, 1));
          } finally {
            outstandingRequestCount--;
            if (outstandingRequestCount === 0) {
              while (outstandingRequestCallbacks.length) {
                try {
                  outstandingRequestCallbacks.pop()();
                } catch (e) {
                  $log.error(e);
                }
              }
            }
          }
        }
        function getHash(url) {
          var index = url.indexOf('#');
          return index === -1 ? '' : url.substr(index);
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
          if (outstandingRequestCount === 0) {
            callback();
          } else {
            outstandingRequestCallbacks.push(callback);
          }
        };
        var cachedState,
            lastHistoryState,
            lastBrowserUrl = location.href,
            baseElement = document.find('base'),
            reloadLocation = null;
        cacheState();
        lastHistoryState = cachedState;
        self.url = function(url, replace, state) {
          if (isUndefined(state)) {
            state = null;
          }
          if (location !== window.location)
            location = window.location;
          if (history !== window.history)
            history = window.history;
          if (url) {
            var sameState = lastHistoryState === state;
            if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
              return self;
            }
            var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
            lastBrowserUrl = url;
            lastHistoryState = state;
            if ($sniffer.history && (!sameBase || !sameState)) {
              history[replace ? 'replaceState' : 'pushState'](state, '', url);
              cacheState();
              lastHistoryState = cachedState;
            } else {
              if (!sameBase || reloadLocation) {
                reloadLocation = url;
              }
              if (replace) {
                location.replace(url);
              } else if (!sameBase) {
                location.href = url;
              } else {
                location.hash = getHash(url);
              }
            }
            return self;
          } else {
            return reloadLocation || location.href.replace(/%27/g, "'");
          }
        };
        self.state = function() {
          return cachedState;
        };
        var urlChangeListeners = [],
            urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
          cacheState();
          fireUrlChange();
        }
        function getCurrentState() {
          try {
            return history.state;
          } catch (e) {}
        }
        var lastCachedState = null;
        function cacheState() {
          cachedState = getCurrentState();
          cachedState = isUndefined(cachedState) ? null : cachedState;
          if (equals(cachedState, lastCachedState)) {
            cachedState = lastCachedState;
          }
          lastCachedState = cachedState;
        }
        function fireUrlChange() {
          if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
            return ;
          }
          lastBrowserUrl = self.url();
          lastHistoryState = cachedState;
          forEach(urlChangeListeners, function(listener) {
            listener(self.url(), cachedState);
          });
        }
        self.onUrlChange = function(callback) {
          if (!urlChangeInit) {
            if ($sniffer.history)
              jqLite(window).on('popstate', cacheStateAndFireUrlChange);
            jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
            urlChangeInit = true;
          }
          urlChangeListeners.push(callback);
          return callback;
        };
        self.$$applicationDestroyed = function() {
          jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
          var href = baseElement.attr('href');
          return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
        };
        self.defer = function(fn, delay) {
          var timeoutId;
          outstandingRequestCount++;
          timeoutId = setTimeout(function() {
            delete pendingDeferIds[timeoutId];
            completeOutstandingRequest(fn);
          }, delay || 0);
          pendingDeferIds[timeoutId] = true;
          return timeoutId;
        };
        self.defer.cancel = function(deferId) {
          if (pendingDeferIds[deferId]) {
            delete pendingDeferIds[deferId];
            clearTimeout(deferId);
            completeOutstandingRequest(noop);
            return true;
          }
          return false;
        };
      }
      function $BrowserProvider() {
        this.$get = ['$window', '$log', '$sniffer', '$document', function($window, $log, $sniffer, $document) {
          return new Browser($window, $document, $log, $sniffer);
        }];
      }
      function $CacheFactoryProvider() {
        this.$get = function() {
          var caches = {};
          function cacheFactory(cacheId, options) {
            if (cacheId in caches) {
              throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
            }
            var size = 0,
                stats = extend({}, options, {id: cacheId}),
                data = {},
                capacity = (options && options.capacity) || Number.MAX_VALUE,
                lruHash = {},
                freshEnd = null,
                staleEnd = null;
            return caches[cacheId] = {
              put: function(key, value) {
                if (isUndefined(value))
                  return ;
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
                  refresh(lruEntry);
                }
                if (!(key in data))
                  size++;
                data[key] = value;
                if (size > capacity) {
                  this.remove(staleEnd.key);
                }
                return value;
              },
              get: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return ;
                  refresh(lruEntry);
                }
                return data[key];
              },
              remove: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return ;
                  if (lruEntry == freshEnd)
                    freshEnd = lruEntry.p;
                  if (lruEntry == staleEnd)
                    staleEnd = lruEntry.n;
                  link(lruEntry.n, lruEntry.p);
                  delete lruHash[key];
                }
                delete data[key];
                size--;
              },
              removeAll: function() {
                data = {};
                size = 0;
                lruHash = {};
                freshEnd = staleEnd = null;
              },
              destroy: function() {
                data = null;
                stats = null;
                lruHash = null;
                delete caches[cacheId];
              },
              info: function() {
                return extend({}, stats, {size: size});
              }
            };
            function refresh(entry) {
              if (entry != freshEnd) {
                if (!staleEnd) {
                  staleEnd = entry;
                } else if (staleEnd == entry) {
                  staleEnd = entry.n;
                }
                link(entry.n, entry.p);
                link(entry, freshEnd);
                freshEnd = entry;
                freshEnd.n = null;
              }
            }
            function link(nextEntry, prevEntry) {
              if (nextEntry != prevEntry) {
                if (nextEntry)
                  nextEntry.p = prevEntry;
                if (prevEntry)
                  prevEntry.n = nextEntry;
              }
            }
          }
          cacheFactory.info = function() {
            var info = {};
            forEach(caches, function(cache, cacheId) {
              info[cacheId] = cache.info();
            });
            return info;
          };
          cacheFactory.get = function(cacheId) {
            return caches[cacheId];
          };
          return cacheFactory;
        };
      }
      function $TemplateCacheProvider() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
          return $cacheFactory('templates');
        }];
      }
      var $compileMinErr = minErr('$compile');
      $CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
      function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {},
            Suffix = 'Directive',
            COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
            CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
            ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
            REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        function parseIsolateBindings(scope, directiveName, isController) {
          var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/;
          var bindings = {};
          forEach(scope, function(definition, scopeName) {
            var match = definition.match(LOCAL_REGEXP);
            if (!match) {
              throw $compileMinErr('iscp', "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, (isController ? "controller bindings definition" : "isolate scope definition"));
            }
            bindings[scopeName] = {
              mode: match[1][0],
              collection: match[2] === '*',
              optional: match[3] === '?',
              attrName: match[4] || scopeName
            };
          });
          return bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
          var bindings = {
            isolateScope: null,
            bindToController: null
          };
          if (isObject(directive.scope)) {
            if (directive.bindToController === true) {
              bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
              bindings.isolateScope = {};
            } else {
              bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
            }
          }
          if (isObject(directive.bindToController)) {
            bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
          }
          if (isObject(bindings.bindToController)) {
            var controller = directive.controller;
            var controllerAs = directive.controllerAs;
            if (!controller) {
              throw $compileMinErr('noctrl', "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            } else if (!identifierForController(controller, controllerAs)) {
              throw $compileMinErr('noident', "Cannot bind to controller without identifier for directive '{0}'.", directiveName);
            }
          }
          return bindings;
        }
        function assertValidDirectiveName(name) {
          var letter = name.charAt(0);
          if (!letter || letter !== lowercase(letter)) {
            throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The first character must be a lowercase letter", name);
          }
          if (name !== name.trim()) {
            throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
          }
        }
        this.directive = function registerDirective(name, directiveFactory) {
          assertNotHasOwnProperty(name, 'directive');
          if (isString(name)) {
            assertValidDirectiveName(name);
            assertArg(directiveFactory, 'directiveFactory');
            if (!hasDirectives.hasOwnProperty(name)) {
              hasDirectives[name] = [];
              $provide.factory(name + Suffix, ['$injector', '$exceptionHandler', function($injector, $exceptionHandler) {
                var directives = [];
                forEach(hasDirectives[name], function(directiveFactory, index) {
                  try {
                    var directive = $injector.invoke(directiveFactory);
                    if (isFunction(directive)) {
                      directive = {compile: valueFn(directive)};
                    } else if (!directive.compile && directive.link) {
                      directive.compile = valueFn(directive.link);
                    }
                    directive.priority = directive.priority || 0;
                    directive.index = index;
                    directive.name = directive.name || name;
                    directive.require = directive.require || (directive.controller && directive.name);
                    directive.restrict = directive.restrict || 'EA';
                    var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                    if (isObject(bindings.isolateScope)) {
                      directive.$$isolateBindings = bindings.isolateScope;
                    }
                    directive.$$moduleName = directiveFactory.$$moduleName;
                    directives.push(directive);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                });
                return directives;
              }]);
            }
            hasDirectives[name].push(directiveFactory);
          } else {
            forEach(name, reverseParams(registerDirective));
          }
          return this;
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
          }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
          }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
          if (isDefined(enabled)) {
            debugInfoEnabled = enabled;
            return this;
          }
          return debugInfoEnabled;
        };
        this.$get = ['$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse', '$controller', '$rootScope', '$document', '$sce', '$animate', '$$sanitizeUri', function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
          var Attributes = function(element, attributesToCopy) {
            if (attributesToCopy) {
              var keys = Object.keys(attributesToCopy);
              var i,
                  l,
                  key;
              for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                this[key] = attributesToCopy[key];
              }
            } else {
              this.$attr = {};
            }
            this.$$element = element;
          };
          Attributes.prototype = {
            $normalize: directiveNormalize,
            $addClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.addClass(this.$$element, classVal);
              }
            },
            $removeClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.removeClass(this.$$element, classVal);
              }
            },
            $updateClass: function(newClasses, oldClasses) {
              var toAdd = tokenDifference(newClasses, oldClasses);
              if (toAdd && toAdd.length) {
                $animate.addClass(this.$$element, toAdd);
              }
              var toRemove = tokenDifference(oldClasses, newClasses);
              if (toRemove && toRemove.length) {
                $animate.removeClass(this.$$element, toRemove);
              }
            },
            $set: function(key, value, writeAttr, attrName) {
              var node = this.$$element[0],
                  booleanKey = getBooleanAttrName(node, key),
                  aliasedKey = getAliasedAttrName(node, key),
                  observer = key,
                  nodeName;
              if (booleanKey) {
                this.$$element.prop(key, value);
                attrName = booleanKey;
              } else if (aliasedKey) {
                this[aliasedKey] = value;
                observer = aliasedKey;
              }
              this[key] = value;
              if (attrName) {
                this.$attr[key] = attrName;
              } else {
                attrName = this.$attr[key];
                if (!attrName) {
                  this.$attr[key] = attrName = snake_case(key, '-');
                }
              }
              nodeName = nodeName_(this.$$element);
              if ((nodeName === 'a' && key === 'href') || (nodeName === 'img' && key === 'src')) {
                this[key] = value = $$sanitizeUri(value, key === 'src');
              } else if (nodeName === 'img' && key === 'srcset') {
                var result = "";
                var trimmedSrcset = trim(value);
                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                var rawUris = trimmedSrcset.split(pattern);
                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                for (var i = 0; i < nbrUrisWith2parts; i++) {
                  var innerIdx = i * 2;
                  result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                  result += (" " + trim(rawUris[innerIdx + 1]));
                }
                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                result += $$sanitizeUri(trim(lastTuple[0]), true);
                if (lastTuple.length === 2) {
                  result += (" " + trim(lastTuple[1]));
                }
                this[key] = value = result;
              }
              if (writeAttr !== false) {
                if (value === null || value === undefined) {
                  this.$$element.removeAttr(attrName);
                } else {
                  this.$$element.attr(attrName, value);
                }
              }
              var $$observers = this.$$observers;
              $$observers && forEach($$observers[observer], function(fn) {
                try {
                  fn(value);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
            },
            $observe: function(key, fn) {
              var attrs = this,
                  $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
                  listeners = ($$observers[key] || ($$observers[key] = []));
              listeners.push(fn);
              $rootScope.$evalAsync(function() {
                if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                  fn(attrs[key]);
                }
              });
              return function() {
                arrayRemove(listeners, fn);
              };
            }
          };
          function safeAddClass($element, className) {
            try {
              $element.addClass(className);
            } catch (e) {}
          }
          var startSymbol = $interpolate.startSymbol(),
              endSymbol = $interpolate.endSymbol(),
              denormalizeTemplate = (startSymbol == '{{' || endSymbol == '}}') ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              },
              NG_ATTR_BINDING = /^ngAttr[A-Z]/;
          compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
            var bindings = $element.data('$binding') || [];
            if (isArray(binding)) {
              bindings = bindings.concat(binding);
            } else {
              bindings.push(binding);
            }
            $element.data('$binding', bindings);
          } : noop;
          compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
            safeAddClass($element, 'ng-binding');
          } : noop;
          compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
            var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
            $element.data(dataName, scope);
          } : noop;
          compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
            safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
          } : noop;
          return compile;
          function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            if (!($compileNodes instanceof jqLite)) {
              $compileNodes = jqLite($compileNodes);
            }
            forEach($compileNodes, function(node, index) {
              if (node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/)) {
                $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];
              }
            });
            var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
            compile.$$addScopeClass($compileNodes);
            var namespace = null;
            return function publicLinkFn(scope, cloneConnectFn, options) {
              assertArg(scope, 'scope');
              options = options || {};
              var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
                  transcludeControllers = options.transcludeControllers,
                  futureParentElement = options.futureParentElement;
              if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
              }
              if (!namespace) {
                namespace = detectNamespaceForChildElements(futureParentElement);
              }
              var $linkNode;
              if (namespace !== 'html') {
                $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
              } else if (cloneConnectFn) {
                $linkNode = JQLitePrototype.clone.call($compileNodes);
              } else {
                $linkNode = $compileNodes;
              }
              if (transcludeControllers) {
                for (var controllerName in transcludeControllers) {
                  $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
                }
              }
              compile.$$addScopeInfo($linkNode, scope);
              if (cloneConnectFn)
                cloneConnectFn($linkNode, scope);
              if (compositeLinkFn)
                compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
              return $linkNode;
            };
          }
          function detectNamespaceForChildElements(parentElement) {
            var node = parentElement && parentElement[0];
            if (!node) {
              return 'html';
            } else {
              return nodeName_(node) !== 'foreignobject' && node.toString().match(/SVG/) ? 'svg' : 'html';
            }
          }
          function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
            var linkFns = [],
                attrs,
                directives,
                nodeLinkFn,
                childNodes,
                childLinkFn,
                linkFnFound,
                nodeLinkFnFound;
            for (var i = 0; i < nodeList.length; i++) {
              attrs = new Attributes();
              directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
              nodeLinkFn = (directives.length) ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
              if (nodeLinkFn && nodeLinkFn.scope) {
                compile.$$addScopeClass(attrs.$$element);
              }
              childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length) ? null : compileNodes(childNodes, nodeLinkFn ? ((nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude) : transcludeFn);
              if (nodeLinkFn || childLinkFn) {
                linkFns.push(i, nodeLinkFn, childLinkFn);
                linkFnFound = true;
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
              }
              previousCompileContext = null;
            }
            return linkFnFound ? compositeLinkFn : null;
            function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
              var nodeLinkFn,
                  childLinkFn,
                  node,
                  childScope,
                  i,
                  ii,
                  idx,
                  childBoundTranscludeFn;
              var stableNodeList;
              if (nodeLinkFnFound) {
                var nodeListLength = nodeList.length;
                stableNodeList = new Array(nodeListLength);
                for (i = 0; i < linkFns.length; i += 3) {
                  idx = linkFns[i];
                  stableNodeList[idx] = nodeList[idx];
                }
              } else {
                stableNodeList = nodeList;
              }
              for (i = 0, ii = linkFns.length; i < ii; ) {
                node = stableNodeList[linkFns[i++]];
                nodeLinkFn = linkFns[i++];
                childLinkFn = linkFns[i++];
                if (nodeLinkFn) {
                  if (nodeLinkFn.scope) {
                    childScope = scope.$new();
                    compile.$$addScopeInfo(jqLite(node), childScope);
                    var destroyBindings = nodeLinkFn.$$destroyBindings;
                    if (destroyBindings) {
                      nodeLinkFn.$$destroyBindings = null;
                      childScope.$on('$destroyed', destroyBindings);
                    }
                  } else {
                    childScope = scope;
                  }
                  if (nodeLinkFn.transcludeOnThisElement) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                  } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                    childBoundTranscludeFn = parentBoundTranscludeFn;
                  } else if (!parentBoundTranscludeFn && transcludeFn) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                  } else {
                    childBoundTranscludeFn = null;
                  }
                  nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn, nodeLinkFn);
                } else if (childLinkFn) {
                  childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                }
              }
            }
          }
          function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
            var boundTranscludeFn = function(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
              if (!transcludedScope) {
                transcludedScope = scope.$new(false, containingScope);
                transcludedScope.$$transcluded = true;
              }
              return transcludeFn(transcludedScope, cloneFn, {
                parentBoundTranscludeFn: previousBoundTranscludeFn,
                transcludeControllers: controllers,
                futureParentElement: futureParentElement
              });
            };
            return boundTranscludeFn;
          }
          function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
            var nodeType = node.nodeType,
                attrsMap = attrs.$attr,
                match,
                className;
            switch (nodeType) {
              case NODE_TYPE_ELEMENT:
                addDirective(directives, directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
                for (var attr,
                    name,
                    nName,
                    ngAttrName,
                    value,
                    isNgAttr,
                    nAttrs = node.attributes,
                    j = 0,
                    jj = nAttrs && nAttrs.length; j < jj; j++) {
                  var attrStartName = false;
                  var attrEndName = false;
                  attr = nAttrs[j];
                  name = attr.name;
                  value = trim(attr.value);
                  ngAttrName = directiveNormalize(name);
                  if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                    name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function(match, letter) {
                      return letter.toUpperCase();
                    });
                  }
                  var directiveNName = ngAttrName.replace(/(Start|End)$/, '');
                  if (directiveIsMultiElement(directiveNName)) {
                    if (ngAttrName === directiveNName + 'Start') {
                      attrStartName = name;
                      attrEndName = name.substr(0, name.length - 5) + 'end';
                      name = name.substr(0, name.length - 6);
                    }
                  }
                  nName = directiveNormalize(name.toLowerCase());
                  attrsMap[nName] = name;
                  if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                    attrs[nName] = value;
                    if (getBooleanAttrName(node, nName)) {
                      attrs[nName] = true;
                    }
                  }
                  addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                  addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                }
                className = node.className;
                if (isObject(className)) {
                  className = className.animVal;
                }
                if (isString(className) && className !== '') {
                  while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                    nName = directiveNormalize(match[2]);
                    if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[3]);
                    }
                    className = className.substr(match.index + match[0].length);
                  }
                }
                break;
              case NODE_TYPE_TEXT:
                if (msie === 11) {
                  while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                    node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                    node.parentNode.removeChild(node.nextSibling);
                  }
                }
                addTextInterpolateDirective(directives, node.nodeValue);
                break;
              case NODE_TYPE_COMMENT:
                try {
                  match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                  if (match) {
                    nName = directiveNormalize(match[1]);
                    if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[2]);
                    }
                  }
                } catch (e) {}
                break;
            }
            directives.sort(byPriority);
            return directives;
          }
          function groupScan(node, attrStart, attrEnd) {
            var nodes = [];
            var depth = 0;
            if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
              do {
                if (!node) {
                  throw $compileMinErr('uterdir', "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                }
                if (node.nodeType == NODE_TYPE_ELEMENT) {
                  if (node.hasAttribute(attrStart))
                    depth++;
                  if (node.hasAttribute(attrEnd))
                    depth--;
                }
                nodes.push(node);
                node = node.nextSibling;
              } while (depth > 0);
            } else {
              nodes.push(node);
            }
            return jqLite(nodes);
          }
          function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
            return function(scope, element, attrs, controllers, transcludeFn) {
              element = groupScan(element[0], attrStart, attrEnd);
              return linkFn(scope, element, attrs, controllers, transcludeFn);
            };
          }
          function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
            previousCompileContext = previousCompileContext || {};
            var terminalPriority = -Number.MAX_VALUE,
                newScopeDirective = previousCompileContext.newScopeDirective,
                controllerDirectives = previousCompileContext.controllerDirectives,
                newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
                templateDirective = previousCompileContext.templateDirective,
                nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
                hasTranscludeDirective = false,
                hasTemplate = false,
                hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
                $compileNode = templateAttrs.$$element = jqLite(compileNode),
                directive,
                directiveName,
                $template,
                replaceDirective = originalReplaceDirective,
                childTranscludeFn = transcludeFn,
                linkFn,
                directiveValue;
            for (var i = 0,
                ii = directives.length; i < ii; i++) {
              directive = directives[i];
              var attrStart = directive.$$start;
              var attrEnd = directive.$$end;
              if (attrStart) {
                $compileNode = groupScan(compileNode, attrStart, attrEnd);
              }
              $template = undefined;
              if (terminalPriority > directive.priority) {
                break;
              }
              if (directiveValue = directive.scope) {
                if (!directive.templateUrl) {
                  if (isObject(directiveValue)) {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                    newIsolateScopeDirective = directive;
                  } else {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                  }
                }
                newScopeDirective = newScopeDirective || directive;
              }
              directiveName = directive.name;
              if (!directive.templateUrl && directive.controller) {
                directiveValue = directive.controller;
                controllerDirectives = controllerDirectives || createMap();
                assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                controllerDirectives[directiveName] = directive;
              }
              if (directiveValue = directive.transclude) {
                hasTranscludeDirective = true;
                if (!directive.$$tlb) {
                  assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                  nonTlbTranscludeDirective = directive;
                }
                if (directiveValue == 'element') {
                  hasElementTranscludeDirective = true;
                  terminalPriority = directive.priority;
                  $template = $compileNode;
                  $compileNode = templateAttrs.$$element = jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));
                  compileNode = $compileNode[0];
                  replaceWith(jqCollection, sliceArgs($template), compileNode);
                  childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {nonTlbTranscludeDirective: nonTlbTranscludeDirective});
                } else {
                  $template = jqLite(jqLiteClone(compileNode)).contents();
                  $compileNode.empty();
                  childTranscludeFn = compile($template, transcludeFn);
                }
              }
              if (directive.template) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                directiveValue = (isFunction(directive.template)) ? directive.template($compileNode, templateAttrs) : directive.template;
                directiveValue = denormalizeTemplate(directiveValue);
                if (directive.replace) {
                  replaceDirective = directive;
                  if (jqLiteIsTextNode(directiveValue)) {
                    $template = [];
                  } else {
                    $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                  }
                  compileNode = $template[0];
                  if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                    throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", directiveName, '');
                  }
                  replaceWith(jqCollection, $compileNode, compileNode);
                  var newTemplateAttrs = {$attr: {}};
                  var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                  var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                  if (newIsolateScopeDirective) {
                    markDirectivesAsIsolate(templateDirectives);
                  }
                  directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                  mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                  ii = directives.length;
                } else {
                  $compileNode.html(directiveValue);
                }
              }
              if (directive.templateUrl) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                if (directive.replace) {
                  replaceDirective = directive;
                }
                nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                  controllerDirectives: controllerDirectives,
                  newScopeDirective: (newScopeDirective !== directive) && newScopeDirective,
                  newIsolateScopeDirective: newIsolateScopeDirective,
                  templateDirective: templateDirective,
                  nonTlbTranscludeDirective: nonTlbTranscludeDirective
                });
                ii = directives.length;
              } else if (directive.compile) {
                try {
                  linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                  if (isFunction(linkFn)) {
                    addLinkFns(null, linkFn, attrStart, attrEnd);
                  } else if (linkFn) {
                    addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                  }
                } catch (e) {
                  $exceptionHandler(e, startingTag($compileNode));
                }
              }
              if (directive.terminal) {
                nodeLinkFn.terminal = true;
                terminalPriority = Math.max(terminalPriority, directive.priority);
              }
            }
            nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
            nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
            nodeLinkFn.templateOnThisElement = hasTemplate;
            nodeLinkFn.transclude = childTranscludeFn;
            previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
            return nodeLinkFn;
            function addLinkFns(pre, post, attrStart, attrEnd) {
              if (pre) {
                if (attrStart)
                  pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                pre.require = directive.require;
                pre.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  pre = cloneAndAnnotateFn(pre, {isolateScope: true});
                }
                preLinkFns.push(pre);
              }
              if (post) {
                if (attrStart)
                  post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                post.require = directive.require;
                post.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  post = cloneAndAnnotateFn(post, {isolateScope: true});
                }
                postLinkFns.push(post);
              }
            }
            function getControllers(directiveName, require, $element, elementControllers) {
              var value;
              if (isString(require)) {
                var match = require.match(REQUIRE_PREFIX_REGEXP);
                var name = require.substring(match[0].length);
                var inheritType = match[1] || match[3];
                var optional = match[2] === '?';
                if (inheritType === '^^') {
                  $element = $element.parent();
                } else {
                  value = elementControllers && elementControllers[name];
                  value = value && value.instance;
                }
                if (!value) {
                  var dataName = '$' + name + 'Controller';
                  value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                }
                if (!value && !optional) {
                  throw $compileMinErr('ctreq', "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                }
              } else if (isArray(require)) {
                value = [];
                for (var i = 0,
                    ii = require.length; i < ii; i++) {
                  value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                }
              }
              return value || null;
            }
            function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope) {
              var elementControllers = createMap();
              for (var controllerKey in controllerDirectives) {
                var directive = controllerDirectives[controllerKey];
                var locals = {
                  $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                  $element: $element,
                  $attrs: attrs,
                  $transclude: transcludeFn
                };
                var controller = directive.controller;
                if (controller == '@') {
                  controller = attrs[directive.name];
                }
                var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                elementControllers[directive.name] = controllerInstance;
                if (!hasElementTranscludeDirective) {
                  $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
                }
              }
              return elementControllers;
            }
            function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn, thisLinkFn) {
              var i,
                  ii,
                  linkFn,
                  controller,
                  isolateScope,
                  elementControllers,
                  transcludeFn,
                  $element,
                  attrs;
              if (compileNode === linkNode) {
                attrs = templateAttrs;
                $element = templateAttrs.$$element;
              } else {
                $element = jqLite(linkNode);
                attrs = new Attributes($element, templateAttrs);
              }
              if (newIsolateScopeDirective) {
                isolateScope = scope.$new(true);
              }
              if (boundTranscludeFn) {
                transcludeFn = controllersBoundTransclude;
                transcludeFn.$$boundTransclude = boundTranscludeFn;
              }
              if (controllerDirectives) {
                elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope);
              }
              if (newIsolateScopeDirective) {
                compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                compile.$$addScopeClass($element, true);
                isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective, isolateScope);
              }
              if (elementControllers) {
                var scopeDirective = newIsolateScopeDirective || newScopeDirective;
                var bindings;
                var controllerForBindings;
                if (scopeDirective && elementControllers[scopeDirective.name]) {
                  bindings = scopeDirective.$$bindings.bindToController;
                  controller = elementControllers[scopeDirective.name];
                  if (controller && controller.identifier && bindings) {
                    controllerForBindings = controller;
                    thisLinkFn.$$destroyBindings = initializeDirectiveBindings(scope, attrs, controller.instance, bindings, scopeDirective);
                  }
                }
                for (i in elementControllers) {
                  controller = elementControllers[i];
                  var controllerResult = controller();
                  if (controllerResult !== controller.instance) {
                    controller.instance = controllerResult;
                    $element.data('$' + i + 'Controller', controllerResult);
                    if (controller === controllerForBindings) {
                      thisLinkFn.$$destroyBindings();
                      thisLinkFn.$$destroyBindings = initializeDirectiveBindings(scope, attrs, controllerResult, bindings, scopeDirective);
                    }
                  }
                }
              }
              for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                linkFn = preLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              var scopeToChild = scope;
              if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                scopeToChild = isolateScope;
              }
              childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
              for (i = postLinkFns.length - 1; i >= 0; i--) {
                linkFn = postLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
                var transcludeControllers;
                if (!isScope(scope)) {
                  futureParentElement = cloneAttachFn;
                  cloneAttachFn = scope;
                  scope = undefined;
                }
                if (hasElementTranscludeDirective) {
                  transcludeControllers = elementControllers;
                }
                if (!futureParentElement) {
                  futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                }
                return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
              }
            }
          }
          function markDirectivesAsIsolate(directives) {
            for (var j = 0,
                jj = directives.length; j < jj; j++) {
              directives[j] = inherit(directives[j], {$$isolateScope: true});
            }
          }
          function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
            if (name === ignoreDirective)
              return null;
            var match = null;
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                try {
                  directive = directives[i];
                  if ((maxPriority === undefined || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                    if (startAttrName) {
                      directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                      });
                    }
                    tDirectives.push(directive);
                    match = directive;
                  }
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            }
            return match;
          }
          function directiveIsMultiElement(name) {
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                directive = directives[i];
                if (directive.multiElement) {
                  return true;
                }
              }
            }
            return false;
          }
          function mergeTemplateAttributes(dst, src) {
            var srcAttr = src.$attr,
                dstAttr = dst.$attr,
                $element = dst.$$element;
            forEach(dst, function(value, key) {
              if (key.charAt(0) != '$') {
                if (src[key] && src[key] !== value) {
                  value += (key === 'style' ? ';' : ' ') + src[key];
                }
                dst.$set(key, value, true, srcAttr[key]);
              }
            });
            forEach(src, function(value, key) {
              if (key == 'class') {
                safeAddClass($element, value);
                dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
              } else if (key == 'style') {
                $element.attr('style', $element.attr('style') + ';' + value);
                dst['style'] = (dst['style'] ? dst['style'] + ';' : '') + value;
              } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
                dst[key] = value;
                dstAttr[key] = srcAttr[key];
              }
            });
          }
          function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
            var linkQueue = [],
                afterTemplateNodeLinkFn,
                afterTemplateChildLinkFn,
                beforeTemplateCompileNode = $compileNode[0],
                origAsyncDirective = directives.shift(),
                derivedSyncDirective = inherit(origAsyncDirective, {
                  templateUrl: null,
                  transclude: null,
                  replace: null,
                  $$originalDirective: origAsyncDirective
                }),
                templateUrl = (isFunction(origAsyncDirective.templateUrl)) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl,
                templateNamespace = origAsyncDirective.templateNamespace;
            $compileNode.empty();
            $templateRequest(templateUrl).then(function(content) {
              var compileNode,
                  tempTemplateAttrs,
                  $template,
                  childBoundTranscludeFn;
              content = denormalizeTemplate(content);
              if (origAsyncDirective.replace) {
                if (jqLiteIsTextNode(content)) {
                  $template = [];
                } else {
                  $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                }
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                  throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                }
                tempTemplateAttrs = {$attr: {}};
                replaceWith($rootElement, $compileNode, compileNode);
                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                if (isObject(origAsyncDirective.scope)) {
                  markDirectivesAsIsolate(templateDirectives);
                }
                directives = templateDirectives.concat(directives);
                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
              } else {
                compileNode = beforeTemplateCompileNode;
                $compileNode.html(content);
              }
              directives.unshift(derivedSyncDirective);
              afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
              forEach($rootElement, function(node, i) {
                if (node == compileNode) {
                  $rootElement[i] = $compileNode[0];
                }
              });
              afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
              while (linkQueue.length) {
                var scope = linkQueue.shift(),
                    beforeTemplateLinkNode = linkQueue.shift(),
                    linkRootElement = linkQueue.shift(),
                    boundTranscludeFn = linkQueue.shift(),
                    linkNode = $compileNode[0];
                if (scope.$$destroyed)
                  continue;
                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                  var oldClasses = beforeTemplateLinkNode.className;
                  if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                    linkNode = jqLiteClone(compileNode);
                  }
                  replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                  safeAddClass(jqLite(linkNode), oldClasses);
                }
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                } else {
                  childBoundTranscludeFn = boundTranscludeFn;
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn, afterTemplateNodeLinkFn);
              }
              linkQueue = null;
            });
            return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
              var childBoundTranscludeFn = boundTranscludeFn;
              if (scope.$$destroyed)
                return ;
              if (linkQueue) {
                linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
              } else {
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn, afterTemplateNodeLinkFn);
              }
            };
          }
          function byPriority(a, b) {
            var diff = b.priority - a.priority;
            if (diff !== 0)
              return diff;
            if (a.name !== b.name)
              return (a.name < b.name) ? -1 : 1;
            return a.index - b.index;
          }
          function assertNoDuplicate(what, previousDirective, directive, element) {
            function wrapModuleNameIfDefined(moduleName) {
              return moduleName ? (' (module: ' + moduleName + ')') : '';
            }
            if (previousDirective) {
              throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
          }
          function addTextInterpolateDirective(directives, text) {
            var interpolateFn = $interpolate(text, true);
            if (interpolateFn) {
              directives.push({
                priority: 0,
                compile: function textInterpolateCompileFn(templateNode) {
                  var templateNodeParent = templateNode.parent(),
                      hasCompileParent = !!templateNodeParent.length;
                  if (hasCompileParent)
                    compile.$$addBindingClass(templateNodeParent);
                  return function textInterpolateLinkFn(scope, node) {
                    var parent = node.parent();
                    if (!hasCompileParent)
                      compile.$$addBindingClass(parent);
                    compile.$$addBindingInfo(parent, interpolateFn.expressions);
                    scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                      node[0].nodeValue = value;
                    });
                  };
                }
              });
            }
          }
          function wrapTemplate(type, template) {
            type = lowercase(type || 'html');
            switch (type) {
              case 'svg':
              case 'math':
                var wrapper = document.createElement('div');
                wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
                return wrapper.childNodes[0].childNodes;
              default:
                return template;
            }
          }
          function getTrustedContext(node, attrNormalizedName) {
            if (attrNormalizedName == "srcdoc") {
              return $sce.HTML;
            }
            var tag = nodeName_(node);
            if (attrNormalizedName == "xlinkHref" || (tag == "form" && attrNormalizedName == "action") || (tag != "img" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc"))) {
              return $sce.RESOURCE_URL;
            }
          }
          function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
            var trustedContext = getTrustedContext(node, name);
            allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
            var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
            if (!interpolateFn)
              return ;
            if (name === "multiple" && nodeName_(node) === "select") {
              throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
            }
            directives.push({
              priority: 100,
              compile: function() {
                return {pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                    var $$observers = (attr.$$observers || (attr.$$observers = {}));
                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                      throw $compileMinErr('nodomevents', "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                    }
                    var newValue = attr[name];
                    if (newValue !== value) {
                      interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                      value = newValue;
                    }
                    if (!interpolateFn)
                      return ;
                    attr[name] = interpolateFn(scope);
                    ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                      if (name === 'class' && newValue != oldValue) {
                        attr.$updateClass(newValue, oldValue);
                      } else {
                        attr.$set(name, newValue);
                      }
                    });
                  }};
              }
            });
          }
          function replaceWith($rootElement, elementsToRemove, newNode) {
            var firstElementToRemove = elementsToRemove[0],
                removeCount = elementsToRemove.length,
                parent = firstElementToRemove.parentNode,
                i,
                ii;
            if ($rootElement) {
              for (i = 0, ii = $rootElement.length; i < ii; i++) {
                if ($rootElement[i] == firstElementToRemove) {
                  $rootElement[i++] = newNode;
                  for (var j = i,
                      j2 = j + removeCount - 1,
                      jj = $rootElement.length; j < jj; j++, j2++) {
                    if (j2 < jj) {
                      $rootElement[j] = $rootElement[j2];
                    } else {
                      delete $rootElement[j];
                    }
                  }
                  $rootElement.length -= removeCount - 1;
                  if ($rootElement.context === firstElementToRemove) {
                    $rootElement.context = newNode;
                  }
                  break;
                }
              }
            }
            if (parent) {
              parent.replaceChild(newNode, firstElementToRemove);
            }
            var fragment = document.createDocumentFragment();
            fragment.appendChild(firstElementToRemove);
            if (jqLite.hasData(firstElementToRemove)) {
              jqLite(newNode).data(jqLite(firstElementToRemove).data());
              if (!jQuery) {
                delete jqLite.cache[firstElementToRemove[jqLite.expando]];
              } else {
                skipDestroyOnNextJQueryCleanData = true;
                jQuery.cleanData([firstElementToRemove]);
              }
            }
            for (var k = 1,
                kk = elementsToRemove.length; k < kk; k++) {
              var element = elementsToRemove[k];
              jqLite(element).remove();
              fragment.appendChild(element);
              delete elementsToRemove[k];
            }
            elementsToRemove[0] = newNode;
            elementsToRemove.length = 1;
          }
          function cloneAndAnnotateFn(fn, annotation) {
            return extend(function() {
              return fn.apply(null, arguments);
            }, fn, annotation);
          }
          function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
            try {
              linkFn(scope, $element, attrs, controllers, transcludeFn);
            } catch (e) {
              $exceptionHandler(e, startingTag($element));
            }
          }
          function initializeDirectiveBindings(scope, attrs, destination, bindings, directive, newScope) {
            var onNewScopeDestroyed;
            forEach(bindings, function(definition, scopeName) {
              var attrName = definition.attrName,
                  optional = definition.optional,
                  mode = definition.mode,
                  lastValue,
                  parentGet,
                  parentSet,
                  compare;
              switch (mode) {
                case '@':
                  if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                    destination[scopeName] = attrs[attrName] = void 0;
                  }
                  attrs.$observe(attrName, function(value) {
                    if (isString(value)) {
                      destination[scopeName] = value;
                    }
                  });
                  attrs.$$observers[attrName].$$scope = scope;
                  if (isString(attrs[attrName])) {
                    destination[scopeName] = $interpolate(attrs[attrName])(scope);
                  }
                  break;
                case '=':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  if (parentGet.literal) {
                    compare = equals;
                  } else {
                    compare = function(a, b) {
                      return a === b || (a !== a && b !== b);
                    };
                  }
                  parentSet = parentGet.assign || function() {
                    lastValue = destination[scopeName] = parentGet(scope);
                    throw $compileMinErr('nonassign', "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], directive.name);
                  };
                  lastValue = destination[scopeName] = parentGet(scope);
                  var parentValueWatch = function parentValueWatch(parentValue) {
                    if (!compare(parentValue, destination[scopeName])) {
                      if (!compare(parentValue, lastValue)) {
                        destination[scopeName] = parentValue;
                      } else {
                        parentSet(scope, parentValue = destination[scopeName]);
                      }
                    }
                    return lastValue = parentValue;
                  };
                  parentValueWatch.$stateful = true;
                  var unwatch;
                  if (definition.collection) {
                    unwatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                  } else {
                    unwatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                  }
                  onNewScopeDestroyed = (onNewScopeDestroyed || []);
                  onNewScopeDestroyed.push(unwatch);
                  break;
                case '&':
                  parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                  if (parentGet === noop && optional)
                    break;
                  destination[scopeName] = function(locals) {
                    return parentGet(scope, locals);
                  };
                  break;
              }
            });
            var destroyBindings = onNewScopeDestroyed ? function destroyBindings() {
              for (var i = 0,
                  ii = onNewScopeDestroyed.length; i < ii; ++i) {
                onNewScopeDestroyed[i]();
              }
            } : noop;
            if (newScope && destroyBindings !== noop) {
              newScope.$on('$destroy', destroyBindings);
              return noop;
            }
            return destroyBindings;
          }
        }];
      }
      var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
      function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ''));
      }
      function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
      function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
      function tokenDifference(str1, str2) {
        var values = '',
            tokens1 = str1.split(/\s+/),
            tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
          var token = tokens1[i];
          for (var j = 0; j < tokens2.length; j++) {
            if (token == tokens2[j])
              continue outer;
          }
          values += (values.length > 0 ? ' ' : '') + token;
        }
        return values;
      }
      function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
          return jqNodes;
        }
        while (i--) {
          var node = jqNodes[i];
          if (node.nodeType === NODE_TYPE_COMMENT) {
            splice.call(jqNodes, i, 1);
          }
        }
        return jqNodes;
      }
      var $controllerMinErr = minErr('$controller');
      var CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
      function identifierForController(controller, ident) {
        if (ident && isString(ident))
          return ident;
        if (isString(controller)) {
          var match = CNTRL_REG.exec(controller);
          if (match)
            return match[3];
        }
      }
      function $ControllerProvider() {
        var controllers = {},
            globals = false;
        this.register = function(name, constructor) {
          assertNotHasOwnProperty(name, 'controller');
          if (isObject(name)) {
            extend(controllers, name);
          } else {
            controllers[name] = constructor;
          }
        };
        this.allowGlobals = function() {
          globals = true;
        };
        this.$get = ['$injector', '$window', function($injector, $window) {
          return function(expression, locals, later, ident) {
            var instance,
                match,
                constructor,
                identifier;
            later = later === true;
            if (ident && isString(ident)) {
              identifier = ident;
            }
            if (isString(expression)) {
              match = expression.match(CNTRL_REG);
              if (!match) {
                throw $controllerMinErr('ctrlfmt', "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
              }
              constructor = match[1], identifier = identifier || match[3];
              expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
              assertArgFn(expression, constructor, true);
            }
            if (later) {
              var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
              instance = Object.create(controllerPrototype || null);
              if (identifier) {
                addIdentifier(locals, identifier, instance, constructor || expression.name);
              }
              var instantiate;
              return instantiate = extend(function() {
                var result = $injector.invoke(expression, instance, locals, constructor);
                if (result !== instance && (isObject(result) || isFunction(result))) {
                  instance = result;
                  if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                  }
                }
                return instance;
              }, {
                instance: instance,
                identifier: identifier
              });
            }
            instance = $injector.instantiate(expression, locals, constructor);
            if (identifier) {
              addIdentifier(locals, identifier, instance, constructor || expression.name);
            }
            return instance;
          };
          function addIdentifier(locals, identifier, instance, name) {
            if (!(locals && isObject(locals.$scope))) {
              throw minErr('$controller')('noscp', "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
            }
            locals.$scope[identifier] = instance;
          }
        }];
      }
      function $DocumentProvider() {
        this.$get = ['$window', function(window) {
          return jqLite(window.document);
        }];
      }
      function $ExceptionHandlerProvider() {
        this.$get = ['$log', function($log) {
          return function(exception, cause) {
            $log.error.apply($log, arguments);
          };
        }];
      }
      var $$ForceReflowProvider = function() {
        this.$get = ['$document', function($document) {
          return function(domNode) {
            if (domNode) {
              if (!domNode.nodeType && domNode instanceof jqLite) {
                domNode = domNode[0];
              }
            } else {
              domNode = $document[0].body;
            }
            return domNode.offsetWidth + 1;
          };
        }];
      };
      var APPLICATION_JSON = 'application/json';
      var CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': APPLICATION_JSON + ';charset=utf-8'};
      var JSON_START = /^\[|^\{(?!\{)/;
      var JSON_ENDS = {
        '[': /]$/,
        '{': /}$/
      };
      var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
      var $httpMinErr = minErr('$http');
      var $httpMinErrLegacyFn = function(method) {
        return function() {
          throw $httpMinErr('legacy', 'The method `{0}` on the promise returned from `$http` has been disabled.', method);
        };
      };
      function serializeValue(v) {
        if (isObject(v)) {
          return isDate(v) ? v.toISOString() : toJson(v);
        }
        return v;
      }
      function $HttpParamSerializerProvider() {
        this.$get = function() {
          return function ngParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            forEachSorted(params, function(value, key) {
              if (value === null || isUndefined(value))
                return ;
              if (isArray(value)) {
                forEach(value, function(v, k) {
                  parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
                });
              } else {
                parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
              }
            });
            return parts.join('&');
          };
        };
      }
      function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
          return function jQueryLikeParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            serialize(params, '', true);
            return parts.join('&');
            function serialize(toSerialize, prefix, topLevel) {
              if (toSerialize === null || isUndefined(toSerialize))
                return ;
              if (isArray(toSerialize)) {
                forEach(toSerialize, function(value, index) {
                  serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
                });
              } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                forEachSorted(toSerialize, function(value, key) {
                  serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
                });
              } else {
                parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
              }
            }
          };
        };
      }
      function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
          var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
          if (tempData) {
            var contentType = headers('Content-Type');
            if ((contentType && (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {
              data = fromJson(tempData);
            }
          }
        }
        return data;
      }
      function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
      }
      function parseHeaders(headers) {
        var parsed = createMap(),
            i;
        function fillInParsed(key, val) {
          if (key) {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
        if (isString(headers)) {
          forEach(headers.split('\n'), function(line) {
            i = line.indexOf(':');
            fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
          });
        } else if (isObject(headers)) {
          forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
          });
        }
        return parsed;
      }
      function headersGetter(headers) {
        var headersObj;
        return function(name) {
          if (!headersObj)
            headersObj = parseHeaders(headers);
          if (name) {
            var value = headersObj[lowercase(name)];
            if (value === void 0) {
              value = null;
            }
            return value;
          }
          return headersObj;
        };
      }
      function transformData(data, headers, status, fns) {
        if (isFunction(fns)) {
          return fns(data, headers, status);
        }
        forEach(fns, function(fn) {
          data = fn(data, headers, status);
        });
        return data;
      }
      function isSuccess(status) {
        return 200 <= status && status < 300;
      }
      function $HttpProvider() {
        var defaults = this.defaults = {
          transformResponse: [defaultHttpResponseTransform],
          transformRequest: [function(d) {
            return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
          }],
          headers: {
            common: {'Accept': 'application/json, text/plain, */*'},
            post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
          },
          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',
          paramSerializer: '$httpParamSerializer'
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
          if (isDefined(value)) {
            useApplyAsync = !!value;
            return this;
          }
          return useApplyAsync;
        };
        var useLegacyPromise = true;
        this.useLegacyPromiseExtensions = function(value) {
          if (isDefined(value)) {
            useLegacyPromise = !!value;
            return this;
          }
          return useLegacyPromise;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector', function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
          var defaultCache = $cacheFactory('$http');
          defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
          var reversedInterceptors = [];
          forEach(interceptorFactories, function(interceptorFactory) {
            reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
          });
          function $http(requestConfig) {
            if (!angular.isObject(requestConfig)) {
              throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
            }
            var config = extend({
              method: 'get',
              transformRequest: defaults.transformRequest,
              transformResponse: defaults.transformResponse,
              paramSerializer: defaults.paramSerializer
            }, requestConfig);
            config.headers = mergeHeaders(requestConfig);
            config.method = uppercase(config.method);
            config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
            var serverRequest = function(config) {
              var headers = config.headers;
              var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
              if (isUndefined(reqData)) {
                forEach(headers, function(value, header) {
                  if (lowercase(header) === 'content-type') {
                    delete headers[header];
                  }
                });
              }
              if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                config.withCredentials = defaults.withCredentials;
              }
              return sendReq(config, reqData).then(transformResponse, transformResponse);
            };
            var chain = [serverRequest, undefined];
            var promise = $q.when(config);
            forEach(reversedInterceptors, function(interceptor) {
              if (interceptor.request || interceptor.requestError) {
                chain.unshift(interceptor.request, interceptor.requestError);
              }
              if (interceptor.response || interceptor.responseError) {
                chain.push(interceptor.response, interceptor.responseError);
              }
            });
            while (chain.length) {
              var thenFn = chain.shift();
              var rejectFn = chain.shift();
              promise = promise.then(thenFn, rejectFn);
            }
            if (useLegacyPromise) {
              promise.success = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
              promise.error = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(null, function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
            } else {
              promise.success = $httpMinErrLegacyFn('success');
              promise.error = $httpMinErrLegacyFn('error');
            }
            return promise;
            function transformResponse(response) {
              var resp = extend({}, response);
              if (!response.data) {
                resp.data = response.data;
              } else {
                resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
              }
              return (isSuccess(response.status)) ? resp : $q.reject(resp);
            }
            function executeHeaderFns(headers, config) {
              var headerContent,
                  processedHeaders = {};
              forEach(headers, function(headerFn, header) {
                if (isFunction(headerFn)) {
                  headerContent = headerFn(config);
                  if (headerContent != null) {
                    processedHeaders[header] = headerContent;
                  }
                } else {
                  processedHeaders[header] = headerFn;
                }
              });
              return processedHeaders;
            }
            function mergeHeaders(config) {
              var defHeaders = defaults.headers,
                  reqHeaders = extend({}, config.headers),
                  defHeaderName,
                  lowercaseDefHeaderName,
                  reqHeaderName;
              defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
              defaultHeadersIteration: for (defHeaderName in defHeaders) {
                lowercaseDefHeaderName = lowercase(defHeaderName);
                for (reqHeaderName in reqHeaders) {
                  if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                    continue defaultHeadersIteration;
                  }
                }
                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
              }
              return executeHeaderFns(reqHeaders, shallowCopy(config));
            }
          }
          $http.pendingRequests = [];
          createShortMethods('get', 'delete', 'head', 'jsonp');
          createShortMethodsWithData('post', 'put', 'patch');
          $http.defaults = defaults;
          return $http;
          function createShortMethods(names) {
            forEach(arguments, function(name) {
              $http[name] = function(url, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url
                }));
              };
            });
          }
          function createShortMethodsWithData(name) {
            forEach(arguments, function(name) {
              $http[name] = function(url, data, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url,
                  data: data
                }));
              };
            });
          }
          function sendReq(config, reqData) {
            var deferred = $q.defer(),
                promise = deferred.promise,
                cache,
                cachedResp,
                reqHeaders = config.headers,
                url = buildUrl(config.url, config.paramSerializer(config.params));
            $http.pendingRequests.push(config);
            promise.then(removePendingReq, removePendingReq);
            if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
              cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
            }
            if (cache) {
              cachedResp = cache.get(url);
              if (isDefined(cachedResp)) {
                if (isPromiseLike(cachedResp)) {
                  cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                } else {
                  if (isArray(cachedResp)) {
                    resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                  } else {
                    resolvePromise(cachedResp, 200, {}, 'OK');
                  }
                }
              } else {
                cache.put(url, promise);
              }
            }
            if (isUndefined(cachedResp)) {
              var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
              if (xsrfValue) {
                reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
              }
              $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
            }
            return promise;
            function done(status, response, headersString, statusText) {
              if (cache) {
                if (isSuccess(status)) {
                  cache.put(url, [status, response, parseHeaders(headersString), statusText]);
                } else {
                  cache.remove(url);
                }
              }
              function resolveHttpPromise() {
                resolvePromise(response, status, headersString, statusText);
              }
              if (useApplyAsync) {
                $rootScope.$applyAsync(resolveHttpPromise);
              } else {
                resolveHttpPromise();
                if (!$rootScope.$$phase)
                  $rootScope.$apply();
              }
            }
            function resolvePromise(response, status, headers, statusText) {
              status = Math.max(status, 0);
              (isSuccess(status) ? deferred.resolve : deferred.reject)({
                data: response,
                status: status,
                headers: headersGetter(headers),
                config: config,
                statusText: statusText
              });
            }
            function resolvePromiseWithResult(result) {
              resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
            }
            function removePendingReq() {
              var idx = $http.pendingRequests.indexOf(config);
              if (idx !== -1)
                $http.pendingRequests.splice(idx, 1);
            }
          }
          function buildUrl(url, serializedParams) {
            if (serializedParams.length > 0) {
              url += ((url.indexOf('?') == -1) ? '?' : '&') + serializedParams;
            }
            return url;
          }
        }];
      }
      function createXhr() {
        return new window.XMLHttpRequest();
      }
      function $HttpBackendProvider() {
        this.$get = ['$browser', '$window', '$document', function($browser, $window, $document) {
          return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);
        }];
      }
      function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
          $browser.$$incOutstandingRequestCount();
          url = url || $browser.url();
          if (lowercase(method) == 'jsonp') {
            var callbackId = '_' + (callbacks.counter++).toString(36);
            callbacks[callbackId] = function(data) {
              callbacks[callbackId].data = data;
              callbacks[callbackId].called = true;
            };
            var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), callbackId, function(status, text) {
              completeRequest(callback, status, callbacks[callbackId].data, "", text);
              callbacks[callbackId] = noop;
            });
          } else {
            var xhr = createXhr();
            xhr.open(method, url, true);
            forEach(headers, function(value, key) {
              if (isDefined(value)) {
                xhr.setRequestHeader(key, value);
              }
            });
            xhr.onload = function requestLoaded() {
              var statusText = xhr.statusText || '';
              var response = ('response' in xhr) ? xhr.response : xhr.responseText;
              var status = xhr.status === 1223 ? 204 : xhr.status;
              if (status === 0) {
                status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
              }
              completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
            };
            var requestError = function() {
              completeRequest(callback, -1, null, null, '');
            };
            xhr.onerror = requestError;
            xhr.onabort = requestError;
            if (withCredentials) {
              xhr.withCredentials = true;
            }
            if (responseType) {
              try {
                xhr.responseType = responseType;
              } catch (e) {
                if (responseType !== 'json') {
                  throw e;
                }
              }
            }
            xhr.send(post);
          }
          if (timeout > 0) {
            var timeoutId = $browserDefer(timeoutRequest, timeout);
          } else if (isPromiseLike(timeout)) {
            timeout.then(timeoutRequest);
          }
          function timeoutRequest() {
            jsonpDone && jsonpDone();
            xhr && xhr.abort();
          }
          function completeRequest(callback, status, response, headersString, statusText) {
            if (timeoutId !== undefined) {
              $browserDefer.cancel(timeoutId);
            }
            jsonpDone = xhr = null;
            callback(status, response, headersString, statusText);
            $browser.$$completeOutstandingRequest(noop);
          }
        };
        function jsonpReq(url, callbackId, done) {
          var script = rawDocument.createElement('script'),
              callback = null;
          script.type = "text/javascript";
          script.src = url;
          script.async = true;
          callback = function(event) {
            removeEventListenerFn(script, "load", callback);
            removeEventListenerFn(script, "error", callback);
            rawDocument.body.removeChild(script);
            script = null;
            var status = -1;
            var text = "unknown";
            if (event) {
              if (event.type === "load" && !callbacks[callbackId].called) {
                event = {type: "error"};
              }
              text = event.type;
              status = event.type === "error" ? 404 : 200;
            }
            if (done) {
              done(status, text);
            }
          };
          addEventListenerFn(script, "load", callback);
          addEventListenerFn(script, "error", callback);
          rawDocument.body.appendChild(script);
          return callback;
        }
      }
      var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
      $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr('noconcat', "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
      };
      $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
      };
      function $InterpolateProvider() {
        var startSymbol = '{{';
        var endSymbol = '}}';
        this.startSymbol = function(value) {
          if (value) {
            startSymbol = value;
            return this;
          } else {
            return startSymbol;
          }
        };
        this.endSymbol = function(value) {
          if (value) {
            endSymbol = value;
            return this;
          } else {
            return endSymbol;
          }
        };
        this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
          var startSymbolLength = startSymbol.length,
              endSymbolLength = endSymbol.length,
              escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
              escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
          function escape(ch) {
            return '\\\\\\' + ch;
          }
          function unescapeText(text) {
            return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
          }
          function stringify(value) {
            if (value == null) {
              return '';
            }
            switch (typeof value) {
              case 'string':
                break;
              case 'number':
                value = '' + value;
                break;
              default:
                value = toJson(value);
            }
            return value;
          }
          function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
            allOrNothing = !!allOrNothing;
            var startIndex,
                endIndex,
                index = 0,
                expressions = [],
                parseFns = [],
                textLength = text.length,
                exp,
                concat = [],
                expressionPositions = [];
            while (index < textLength) {
              if (((startIndex = text.indexOf(startSymbol, index)) != -1) && ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
                if (index !== startIndex) {
                  concat.push(unescapeText(text.substring(index, startIndex)));
                }
                exp = text.substring(startIndex + startSymbolLength, endIndex);
                expressions.push(exp);
                parseFns.push($parse(exp, parseStringifyInterceptor));
                index = endIndex + endSymbolLength;
                expressionPositions.push(concat.length);
                concat.push('');
              } else {
                if (index !== textLength) {
                  concat.push(unescapeText(text.substring(index)));
                }
                break;
              }
            }
            if (trustedContext && concat.length > 1) {
              $interpolateMinErr.throwNoconcat(text);
            }
            if (!mustHaveExpression || expressions.length) {
              var compute = function(values) {
                for (var i = 0,
                    ii = expressions.length; i < ii; i++) {
                  if (allOrNothing && isUndefined(values[i]))
                    return ;
                  concat[expressionPositions[i]] = values[i];
                }
                return concat.join('');
              };
              var getValue = function(value) {
                return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
              };
              return extend(function interpolationFn(context) {
                var i = 0;
                var ii = expressions.length;
                var values = new Array(ii);
                try {
                  for (; i < ii; i++) {
                    values[i] = parseFns[i](context);
                  }
                  return compute(values);
                } catch (err) {
                  $exceptionHandler($interpolateMinErr.interr(text, err));
                }
              }, {
                exp: text,
                expressions: expressions,
                $$watchDelegate: function(scope, listener) {
                  var lastValue;
                  return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                    var currValue = compute(values);
                    if (isFunction(listener)) {
                      listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                    }
                    lastValue = currValue;
                  });
                }
              });
            }
            function parseStringifyInterceptor(value) {
              try {
                value = getValue(value);
                return allOrNothing && !isDefined(value) ? value : stringify(value);
              } catch (err) {
                $exceptionHandler($interpolateMinErr.interr(text, err));
              }
            }
          }
          $interpolate.startSymbol = function() {
            return startSymbol;
          };
          $interpolate.endSymbol = function() {
            return endSymbol;
          };
          return $interpolate;
        }];
      }
      function $IntervalProvider() {
        this.$get = ['$rootScope', '$window', '$q', '$$q', function($rootScope, $window, $q, $$q) {
          var intervals = {};
          function interval(fn, delay, count, invokeApply) {
            var hasParams = arguments.length > 4,
                args = hasParams ? sliceArgs(arguments, 4) : [],
                setInterval = $window.setInterval,
                clearInterval = $window.clearInterval,
                iteration = 0,
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise;
            count = isDefined(count) ? count : 0;
            promise.then(null, null, (!hasParams) ? fn : function() {
              fn.apply(null, args);
            });
            promise.$$intervalId = setInterval(function tick() {
              deferred.notify(iteration++);
              if (count > 0 && iteration >= count) {
                deferred.resolve(iteration);
                clearInterval(promise.$$intervalId);
                delete intervals[promise.$$intervalId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            intervals[promise.$$intervalId] = deferred;
            return promise;
          }
          interval.cancel = function(promise) {
            if (promise && promise.$$intervalId in intervals) {
              intervals[promise.$$intervalId].reject('canceled');
              $window.clearInterval(promise.$$intervalId);
              delete intervals[promise.$$intervalId];
              return true;
            }
            return false;
          };
          return interval;
        }];
      }
      var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
          DEFAULT_PORTS = {
            'http': 80,
            'https': 443,
            'ftp': 21
          };
      var $locationMinErr = minErr('$location');
      function encodePath(path) {
        var segments = path.split('/'),
            i = segments.length;
        while (i--) {
          segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join('/');
      }
      function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
      }
      function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = (relativeUrl.charAt(0) !== '/');
        if (prefixed) {
          relativeUrl = '/' + relativeUrl;
        }
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
          locationObj.$$path = '/' + locationObj.$$path;
        }
      }
      function beginsWith(begin, whole) {
        if (whole.indexOf(begin) === 0) {
          return whole.substr(begin.length);
        }
      }
      function stripHash(url) {
        var index = url.indexOf('#');
        return index == -1 ? url : url.substr(0, index);
      }
      function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, '$1');
      }
      function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
      }
      function serverBase(url) {
        return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
      }
      function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || '';
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var pathUrl = beginsWith(appBaseNoFile, url);
          if (!isString(pathUrl)) {
            throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
          }
          parseAppUrl(pathUrl, this);
          if (!this.$$path) {
            this.$$path = '/';
          }
          this.$$compose();
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var appUrl,
              prevAppUrl;
          var rewrittenUrl;
          if ((appUrl = beginsWith(appBase, url)) !== undefined) {
            prevAppUrl = appUrl;
            if ((appUrl = beginsWith(basePrefix, appUrl)) !== undefined) {
              rewrittenUrl = appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
            } else {
              rewrittenUrl = appBase + prevAppUrl;
            }
          } else if ((appUrl = beginsWith(appBaseNoFile, url)) !== undefined) {
            rewrittenUrl = appBaseNoFile + appUrl;
          } else if (appBaseNoFile == url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
      }
      function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
          var withoutHashUrl;
          if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
            withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
            if (isUndefined(withoutHashUrl)) {
              withoutHashUrl = withoutBaseUrl;
            }
          } else {
            if (this.$$html5) {
              withoutHashUrl = withoutBaseUrl;
            } else {
              withoutHashUrl = '';
              if (isUndefined(withoutBaseUrl)) {
                appBase = url;
                this.replace();
              }
            }
          }
          parseAppUrl(withoutHashUrl, this);
          this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
          this.$$compose();
          function removeWindowsDriveName(path, url, base) {
            var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
            var firstPathSegmentMatch;
            if (url.indexOf(base) === 0) {
              url = url.replace(base, '');
            }
            if (windowsFilePathExp.exec(url)) {
              return path;
            }
            firstPathSegmentMatch = windowsFilePathExp.exec(path);
            return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
          }
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (stripHash(appBase) == stripHash(url)) {
            this.$$parse(url);
            return true;
          }
          return false;
        };
      }
      function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var rewrittenUrl;
          var appUrl;
          if (appBase == stripHash(url)) {
            rewrittenUrl = url;
          } else if ((appUrl = beginsWith(appBaseNoFile, url))) {
            rewrittenUrl = appBase + hashPrefix + appUrl;
          } else if (appBaseNoFile === url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
      }
      var locationPrototype = {
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter('$$absUrl'),
        url: function(url) {
          if (isUndefined(url)) {
            return this.$$url;
          }
          var match = PATH_MATCH.exec(url);
          if (match[1] || url === '')
            this.path(decodeURIComponent(match[1]));
          if (match[2] || match[1] || url === '')
            this.search(match[3] || '');
          this.hash(match[5] || '');
          return this;
        },
        protocol: locationGetter('$$protocol'),
        host: locationGetter('$$host'),
        port: locationGetter('$$port'),
        path: locationGetterSetter('$$path', function(path) {
          path = path !== null ? path.toString() : '';
          return path.charAt(0) == '/' ? path : '/' + path;
        }),
        search: function(search, paramValue) {
          switch (arguments.length) {
            case 0:
              return this.$$search;
            case 1:
              if (isString(search) || isNumber(search)) {
                search = search.toString();
                this.$$search = parseKeyValue(search);
              } else if (isObject(search)) {
                search = copy(search, {});
                forEach(search, function(value, key) {
                  if (value == null)
                    delete search[key];
                });
                this.$$search = search;
              } else {
                throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
              }
              break;
            default:
              if (isUndefined(paramValue) || paramValue === null) {
                delete this.$$search[search];
              } else {
                this.$$search[search] = paramValue;
              }
          }
          this.$$compose();
          return this;
        },
        hash: locationGetterSetter('$$hash', function(hash) {
          return hash !== null ? hash.toString() : '';
        }),
        replace: function() {
          this.$$replace = true;
          return this;
        }
      };
      forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
          if (!arguments.length) {
            return this.$$state;
          }
          if (Location !== LocationHtml5Url || !this.$$html5) {
            throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
          }
          this.$$state = isUndefined(state) ? null : state;
          return this;
        };
      });
      function locationGetter(property) {
        return function() {
          return this[property];
        };
      }
      function locationGetterSetter(property, preprocess) {
        return function(value) {
          if (isUndefined(value)) {
            return this[property];
          }
          this[property] = preprocess(value);
          this.$$compose();
          return this;
        };
      }
      function $LocationProvider() {
        var hashPrefix = '',
            html5Mode = {
              enabled: false,
              requireBase: true,
              rewriteLinks: true
            };
        this.hashPrefix = function(prefix) {
          if (isDefined(prefix)) {
            hashPrefix = prefix;
            return this;
          } else {
            return hashPrefix;
          }
        };
        this.html5Mode = function(mode) {
          if (isBoolean(mode)) {
            html5Mode.enabled = mode;
            return this;
          } else if (isObject(mode)) {
            if (isBoolean(mode.enabled)) {
              html5Mode.enabled = mode.enabled;
            }
            if (isBoolean(mode.requireBase)) {
              html5Mode.requireBase = mode.requireBase;
            }
            if (isBoolean(mode.rewriteLinks)) {
              html5Mode.rewriteLinks = mode.rewriteLinks;
            }
            return this;
          } else {
            return html5Mode;
          }
        };
        this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement', '$window', function($rootScope, $browser, $sniffer, $rootElement, $window) {
          var $location,
              LocationMode,
              baseHref = $browser.baseHref(),
              initialUrl = $browser.url(),
              appBase;
          if (html5Mode.enabled) {
            if (!baseHref && html5Mode.requireBase) {
              throw $locationMinErr('nobase', "$location in HTML5 mode requires a <base> tag to be present!");
            }
            appBase = serverBase(initialUrl) + (baseHref || '/');
            LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
          } else {
            appBase = stripHash(initialUrl);
            LocationMode = LocationHashbangUrl;
          }
          var appBaseNoFile = stripFile(appBase);
          $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
          $location.$$parseLinkUrl(initialUrl, initialUrl);
          $location.$$state = $browser.state();
          var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
          function setBrowserUrlWithFallback(url, replace, state) {
            var oldUrl = $location.url();
            var oldState = $location.$$state;
            try {
              $browser.url(url, replace, state);
              $location.$$state = $browser.state();
            } catch (e) {
              $location.url(oldUrl);
              $location.$$state = oldState;
              throw e;
            }
          }
          $rootElement.on('click', function(event) {
            if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2)
              return ;
            var elm = jqLite(event.target);
            while (nodeName_(elm[0]) !== 'a') {
              if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                return ;
            }
            var absHref = elm.prop('href');
            var relHref = elm.attr('href') || elm.attr('xlink:href');
            if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
              absHref = urlResolve(absHref.animVal).href;
            }
            if (IGNORE_URI_REGEXP.test(absHref))
              return ;
            if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
              if ($location.$$parseLinkUrl(absHref, relHref)) {
                event.preventDefault();
                if ($location.absUrl() != $browser.url()) {
                  $rootScope.$apply();
                  $window.angular['ff-684208-preventDefault'] = true;
                }
              }
            }
          });
          if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
            $browser.url($location.absUrl(), true);
          }
          var initializing = true;
          $browser.onUrlChange(function(newUrl, newState) {
            if (isUndefined(beginsWith(appBaseNoFile, newUrl))) {
              $window.location.href = newUrl;
              return ;
            }
            $rootScope.$evalAsync(function() {
              var oldUrl = $location.absUrl();
              var oldState = $location.$$state;
              var defaultPrevented;
              $location.$$parse(newUrl);
              $location.$$state = newState;
              defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
              if ($location.absUrl() !== newUrl)
                return ;
              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
                setBrowserUrlWithFallback(oldUrl, false, oldState);
              } else {
                initializing = false;
                afterLocationChange(oldUrl, oldState);
              }
            });
            if (!$rootScope.$$phase)
              $rootScope.$digest();
          });
          $rootScope.$watch(function $locationWatch() {
            var oldUrl = trimEmptyHash($browser.url());
            var newUrl = trimEmptyHash($location.absUrl());
            var oldState = $browser.state();
            var currentReplace = $location.$$replace;
            var urlOrStateChanged = oldUrl !== newUrl || ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
            if (initializing || urlOrStateChanged) {
              initializing = false;
              $rootScope.$evalAsync(function() {
                var newUrl = $location.absUrl();
                var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                if ($location.absUrl() !== newUrl)
                  return ;
                if (defaultPrevented) {
                  $location.$$parse(oldUrl);
                  $location.$$state = oldState;
                } else {
                  if (urlOrStateChanged) {
                    setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                  }
                  afterLocationChange(oldUrl, oldState);
                }
              });
            }
            $location.$$replace = false;
          });
          return $location;
          function afterLocationChange(oldUrl, oldState) {
            $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
          }
        }];
      }
      function $LogProvider() {
        var debug = true,
            self = this;
        this.debugEnabled = function(flag) {
          if (isDefined(flag)) {
            debug = flag;
            return this;
          } else {
            return debug;
          }
        };
        this.$get = ['$window', function($window) {
          return {
            log: consoleLog('log'),
            info: consoleLog('info'),
            warn: consoleLog('warn'),
            error: consoleLog('error'),
            debug: (function() {
              var fn = consoleLog('debug');
              return function() {
                if (debug) {
                  fn.apply(self, arguments);
                }
              };
            }())
          };
          function formatError(arg) {
            if (arg instanceof Error) {
              if (arg.stack) {
                arg = (arg.message && arg.stack.indexOf(arg.message) === -1) ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
              } else if (arg.sourceURL) {
                arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
              }
            }
            return arg;
          }
          function consoleLog(type) {
            var console = $window.console || {},
                logFn = console[type] || console.log || noop,
                hasApply = false;
            try {
              hasApply = !!logFn.apply;
            } catch (e) {}
            if (hasApply) {
              return function() {
                var args = [];
                forEach(arguments, function(arg) {
                  args.push(formatError(arg));
                });
                return logFn.apply(console, args);
              };
            }
            return function(arg1, arg2) {
              logFn(arg1, arg2 == null ? '' : arg2);
            };
          }
        }];
      }
      var $parseMinErr = minErr('$parse');
      function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
          throw $parseMinErr('isecfld', 'Attempting to access a disallowed field in Angular expressions! ' + 'Expression: {0}', fullExpression);
        }
        return name;
      }
      function ensureSafeObject(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.window === obj) {
            throw $parseMinErr('isecwindow', 'Referencing the Window in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {
            throw $parseMinErr('isecdom', 'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === Object) {
            throw $parseMinErr('isecobj', 'Referencing Object in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
        return obj;
      }
      var CALL = Function.prototype.call;
      var APPLY = Function.prototype.apply;
      var BIND = Function.prototype.bind;
      function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === CALL || obj === APPLY || obj === BIND) {
            throw $parseMinErr('isecff', 'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      var OPERATORS = createMap();
      forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function(operator) {
        OPERATORS[operator] = true;
      });
      var ESCAPE = {
        "n": "\n",
        "f": "\f",
        "r": "\r",
        "t": "\t",
        "v": "\v",
        "'": "'",
        '"': '"'
      };
      var Lexer = function(options) {
        this.options = options;
      };
      Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
          this.text = text;
          this.index = 0;
          this.tokens = [];
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (ch === '"' || ch === "'") {
              this.readString(ch);
            } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
              this.readNumber();
            } else if (this.isIdent(ch)) {
              this.readIdent();
            } else if (this.is(ch, '(){}[].,;:?')) {
              this.tokens.push({
                index: this.index,
                text: ch
              });
              this.index++;
            } else if (this.isWhitespace(ch)) {
              this.index++;
            } else {
              var ch2 = ch + this.peek();
              var ch3 = ch2 + this.peek(2);
              var op1 = OPERATORS[ch];
              var op2 = OPERATORS[ch2];
              var op3 = OPERATORS[ch3];
              if (op1 || op2 || op3) {
                var token = op3 ? ch3 : (op2 ? ch2 : ch);
                this.tokens.push({
                  index: this.index,
                  text: token,
                  operator: true
                });
                this.index += token.length;
              } else {
                this.throwError('Unexpected next character ', this.index, this.index + 1);
              }
            }
          }
          return this.tokens;
        },
        is: function(ch, chars) {
          return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
          var num = i || 1;
          return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
          return ('0' <= ch && ch <= '9') && typeof ch === "string";
        },
        isWhitespace: function(ch) {
          return (ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\v' || ch === '\u00A0');
        },
        isIdent: function(ch) {
          return ('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$');
        },
        isExpOperator: function(ch) {
          return (ch === '-' || ch === '+' || this.isNumber(ch));
        },
        throwError: function(error, start, end) {
          end = end || this.index;
          var colStr = (isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end);
          throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);
        },
        readNumber: function() {
          var number = '';
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = lowercase(this.text.charAt(this.index));
            if (ch == '.' || this.isNumber(ch)) {
              number += ch;
            } else {
              var peekCh = this.peek();
              if (ch == 'e' && this.isExpOperator(peekCh)) {
                number += ch;
              } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
                number += ch;
              } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
                this.throwError('Invalid exponent');
              } else {
                break;
              }
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: number,
            constant: true,
            value: Number(number)
          });
        },
        readIdent: function() {
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (!(this.isIdent(ch) || this.isNumber(ch))) {
              break;
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: this.text.slice(start, this.index),
            identifier: true
          });
        },
        readString: function(quote) {
          var start = this.index;
          this.index++;
          var string = '';
          var rawString = quote;
          var escape = false;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            rawString += ch;
            if (escape) {
              if (ch === 'u') {
                var hex = this.text.substring(this.index + 1, this.index + 5);
                if (!hex.match(/[\da-f]{4}/i)) {
                  this.throwError('Invalid unicode escape [\\u' + hex + ']');
                }
                this.index += 4;
                string += String.fromCharCode(parseInt(hex, 16));
              } else {
                var rep = ESCAPE[ch];
                string = string + (rep || ch);
              }
              escape = false;
            } else if (ch === '\\') {
              escape = true;
            } else if (ch === quote) {
              this.index++;
              this.tokens.push({
                index: start,
                text: rawString,
                constant: true,
                value: string
              });
              return ;
            } else {
              string += ch;
            }
            this.index++;
          }
          this.throwError('Unterminated quote', start);
        }
      };
      var AST = function(lexer, options) {
        this.lexer = lexer;
        this.options = options;
      };
      AST.Program = 'Program';
      AST.ExpressionStatement = 'ExpressionStatement';
      AST.AssignmentExpression = 'AssignmentExpression';
      AST.ConditionalExpression = 'ConditionalExpression';
      AST.LogicalExpression = 'LogicalExpression';
      AST.BinaryExpression = 'BinaryExpression';
      AST.UnaryExpression = 'UnaryExpression';
      AST.CallExpression = 'CallExpression';
      AST.MemberExpression = 'MemberExpression';
      AST.Identifier = 'Identifier';
      AST.Literal = 'Literal';
      AST.ArrayExpression = 'ArrayExpression';
      AST.Property = 'Property';
      AST.ObjectExpression = 'ObjectExpression';
      AST.ThisExpression = 'ThisExpression';
      AST.NGValueParameter = 'NGValueParameter';
      AST.prototype = {
        ast: function(text) {
          this.text = text;
          this.tokens = this.lexer.lex(text);
          var value = this.program();
          if (this.tokens.length !== 0) {
            this.throwError('is an unexpected token', this.tokens[0]);
          }
          return value;
        },
        program: function() {
          var body = [];
          while (true) {
            if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
              body.push(this.expressionStatement());
            if (!this.expect(';')) {
              return {
                type: AST.Program,
                body: body
              };
            }
          }
        },
        expressionStatement: function() {
          return {
            type: AST.ExpressionStatement,
            expression: this.filterChain()
          };
        },
        filterChain: function() {
          var left = this.expression();
          var token;
          while ((token = this.expect('|'))) {
            left = this.filter(left);
          }
          return left;
        },
        expression: function() {
          return this.assignment();
        },
        assignment: function() {
          var result = this.ternary();
          if (this.expect('=')) {
            result = {
              type: AST.AssignmentExpression,
              left: result,
              right: this.assignment(),
              operator: '='
            };
          }
          return result;
        },
        ternary: function() {
          var test = this.logicalOR();
          var alternate;
          var consequent;
          if (this.expect('?')) {
            alternate = this.expression();
            if (this.consume(':')) {
              consequent = this.expression();
              return {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
              };
            }
          }
          return test;
        },
        logicalOR: function() {
          var left = this.logicalAND();
          while (this.expect('||')) {
            left = {
              type: AST.LogicalExpression,
              operator: '||',
              left: left,
              right: this.logicalAND()
            };
          }
          return left;
        },
        logicalAND: function() {
          var left = this.equality();
          while (this.expect('&&')) {
            left = {
              type: AST.LogicalExpression,
              operator: '&&',
              left: left,
              right: this.equality()
            };
          }
          return left;
        },
        equality: function() {
          var left = this.relational();
          var token;
          while ((token = this.expect('==', '!=', '===', '!=='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.relational()
            };
          }
          return left;
        },
        relational: function() {
          var left = this.additive();
          var token;
          while ((token = this.expect('<', '>', '<=', '>='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.additive()
            };
          }
          return left;
        },
        additive: function() {
          var left = this.multiplicative();
          var token;
          while ((token = this.expect('+', '-'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.multiplicative()
            };
          }
          return left;
        },
        multiplicative: function() {
          var left = this.unary();
          var token;
          while ((token = this.expect('*', '/', '%'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.unary()
            };
          }
          return left;
        },
        unary: function() {
          var token;
          if ((token = this.expect('+', '-', '!'))) {
            return {
              type: AST.UnaryExpression,
              operator: token.text,
              prefix: true,
              argument: this.unary()
            };
          } else {
            return this.primary();
          }
        },
        primary: function() {
          var primary;
          if (this.expect('(')) {
            primary = this.filterChain();
            this.consume(')');
          } else if (this.expect('[')) {
            primary = this.arrayDeclaration();
          } else if (this.expect('{')) {
            primary = this.object();
          } else if (this.constants.hasOwnProperty(this.peek().text)) {
            primary = copy(this.constants[this.consume().text]);
          } else if (this.peek().identifier) {
            primary = this.identifier();
          } else if (this.peek().constant) {
            primary = this.constant();
          } else {
            this.throwError('not a primary expression', this.peek());
          }
          var next;
          while ((next = this.expect('(', '[', '.'))) {
            if (next.text === '(') {
              primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
              };
              this.consume(')');
            } else if (next.text === '[') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: true
              };
              this.consume(']');
            } else if (next.text === '.') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: false
              };
            } else {
              this.throwError('IMPOSSIBLE');
            }
          }
          return primary;
        },
        filter: function(baseExpression) {
          var args = [baseExpression];
          var result = {
            type: AST.CallExpression,
            callee: this.identifier(),
            arguments: args,
            filter: true
          };
          while (this.expect(':')) {
            args.push(this.expression());
          }
          return result;
        },
        parseArguments: function() {
          var args = [];
          if (this.peekToken().text !== ')') {
            do {
              args.push(this.expression());
            } while (this.expect(','));
          }
          return args;
        },
        identifier: function() {
          var token = this.consume();
          if (!token.identifier) {
            this.throwError('is not a valid identifier', token);
          }
          return {
            type: AST.Identifier,
            name: token.text
          };
        },
        constant: function() {
          return {
            type: AST.Literal,
            value: this.consume().value
          };
        },
        arrayDeclaration: function() {
          var elements = [];
          if (this.peekToken().text !== ']') {
            do {
              if (this.peek(']')) {
                break;
              }
              elements.push(this.expression());
            } while (this.expect(','));
          }
          this.consume(']');
          return {
            type: AST.ArrayExpression,
            elements: elements
          };
        },
        object: function() {
          var properties = [],
              property;
          if (this.peekToken().text !== '}') {
            do {
              if (this.peek('}')) {
                break;
              }
              property = {
                type: AST.Property,
                kind: 'init'
              };
              if (this.peek().constant) {
                property.key = this.constant();
              } else if (this.peek().identifier) {
                property.key = this.identifier();
              } else {
                this.throwError("invalid key", this.peek());
              }
              this.consume(':');
              property.value = this.expression();
              properties.push(property);
            } while (this.expect(','));
          }
          this.consume('}');
          return {
            type: AST.ObjectExpression,
            properties: properties
          };
        },
        throwError: function(msg, token) {
          throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          var token = this.expect(e1);
          if (!token) {
            this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
          }
          return token;
        },
        peekToken: function() {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
          return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
          if (this.tokens.length > i) {
            var token = this.tokens[i];
            var t = token.text;
            if (t === e1 || t === e2 || t === e3 || t === e4 || (!e1 && !e2 && !e3 && !e4)) {
              return token;
            }
          }
          return false;
        },
        expect: function(e1, e2, e3, e4) {
          var token = this.peek(e1, e2, e3, e4);
          if (token) {
            this.tokens.shift();
            return token;
          }
          return false;
        },
        constants: {
          'true': {
            type: AST.Literal,
            value: true
          },
          'false': {
            type: AST.Literal,
            value: false
          },
          'null': {
            type: AST.Literal,
            value: null
          },
          'undefined': {
            type: AST.Literal,
            value: undefined
          },
          'this': {type: AST.ThisExpression}
        }
      };
      function ifDefined(v, d) {
        return typeof v !== 'undefined' ? v : d;
      }
      function plusFn(l, r) {
        if (typeof l === 'undefined')
          return r;
        if (typeof r === 'undefined')
          return l;
        return l + r;
      }
      function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
      }
      function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants;
        var argsToWatch;
        switch (ast.type) {
          case AST.Program:
            allConstants = true;
            forEach(ast.body, function(expr) {
              findConstantAndWatchExpressions(expr.expression, $filter);
              allConstants = allConstants && expr.expression.constant;
            });
            ast.constant = allConstants;
            break;
          case AST.Literal:
            ast.constant = true;
            ast.toWatch = [];
            break;
          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter);
            ast.constant = ast.argument.constant;
            ast.toWatch = ast.argument.toWatch;
            break;
          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;
          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter);
            findConstantAndWatchExpressions(ast.alternate, $filter);
            findConstantAndWatchExpressions(ast.consequent, $filter);
            ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.Identifier:
            ast.constant = false;
            ast.toWatch = [ast];
            break;
          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter);
            if (ast.computed) {
              findConstantAndWatchExpressions(ast.property, $filter);
            }
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
            ast.toWatch = [ast];
            break;
          case AST.CallExpression:
            allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
            argsToWatch = [];
            forEach(ast.arguments, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
            break;
          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = [ast];
            break;
          case AST.ArrayExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.elements, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ObjectExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.properties, function(property) {
              findConstantAndWatchExpressions(property.value, $filter);
              allConstants = allConstants && property.value.constant;
              if (!property.value.constant) {
                argsToWatch.push.apply(argsToWatch, property.value.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ThisExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
        }
      }
      function getInputs(body) {
        if (body.length != 1)
          return ;
        var lastExpression = body[0].expression;
        var candidate = lastExpression.toWatch;
        if (candidate.length !== 1)
          return candidate;
        return candidate[0] !== lastExpression ? candidate : undefined;
      }
      function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
      }
      function assignableAST(ast) {
        if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
          return {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {type: AST.NGValueParameter},
            operator: '='
          };
        }
      }
      function isLiteral(ast) {
        return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
      }
      function isConstant(ast) {
        return ast.constant;
      }
      function ASTCompiler(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTCompiler.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.state = {
            nextId: 0,
            filters: {},
            expensiveChecks: expensiveChecks,
            fn: {
              vars: [],
              body: [],
              own: {}
            },
            assign: {
              vars: [],
              body: [],
              own: {}
            },
            inputs: []
          };
          findConstantAndWatchExpressions(ast, self.$filter);
          var extra = '';
          var assignable;
          this.stage = 'assign';
          if ((assignable = assignableAST(ast))) {
            this.state.computing = 'assign';
            var result = this.nextId();
            this.recurse(assignable, result);
            extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
          }
          var toWatch = getInputs(ast.body);
          self.stage = 'inputs';
          forEach(toWatch, function(watch, key) {
            var fnKey = 'fn' + key;
            self.state[fnKey] = {
              vars: [],
              body: [],
              own: {}
            };
            self.state.computing = fnKey;
            var intoId = self.nextId();
            self.recurse(watch, intoId);
            self.return_(intoId);
            self.state.inputs.push(fnKey);
            watch.watchId = key;
          });
          this.state.computing = 'fn';
          this.stage = 'main';
          this.recurse(ast);
          var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
          var fn = (new Function('$filter', 'ensureSafeMemberName', 'ensureSafeObject', 'ensureSafeFunction', 'ifDefined', 'plus', 'text', fnString))(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, ifDefined, plusFn, expression);
          this.state = this.stage = undefined;
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        USE: 'use',
        STRICT: 'strict',
        watchFns: function() {
          var result = [];
          var fns = this.state.inputs;
          var self = this;
          forEach(fns, function(name) {
            result.push('var ' + name + '=' + self.generateFunction(name, 's'));
          });
          if (fns.length) {
            result.push('fn.inputs=[' + fns.join(',') + '];');
          }
          return result.join('');
        },
        generateFunction: function(name, params) {
          return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';
        },
        filterPrefix: function() {
          var parts = [];
          var self = this;
          forEach(this.state.filters, function(id, filter) {
            parts.push(id + '=$filter(' + self.escape(filter) + ')');
          });
          if (parts.length)
            return 'var ' + parts.join(',') + ';';
          return '';
        },
        varsPrefix: function(section) {
          return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
        },
        body: function(section) {
          return this.state[section].body.join('');
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var left,
              right,
              self = this,
              args,
              expression;
          recursionFn = recursionFn || noop;
          if (!skipWatchIdCheck && isDefined(ast.watchId)) {
            intoId = intoId || this.nextId();
            this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
            return ;
          }
          switch (ast.type) {
            case AST.Program:
              forEach(ast.body, function(expression, pos) {
                self.recurse(expression.expression, undefined, undefined, function(expr) {
                  right = expr;
                });
                if (pos !== ast.body.length - 1) {
                  self.current().body.push(right, ';');
                } else {
                  self.return_(right);
                }
              });
              break;
            case AST.Literal:
              expression = this.escape(ast.value);
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.UnaryExpression:
              this.recurse(ast.argument, undefined, undefined, function(expr) {
                right = expr;
              });
              expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.BinaryExpression:
              this.recurse(ast.left, undefined, undefined, function(expr) {
                left = expr;
              });
              this.recurse(ast.right, undefined, undefined, function(expr) {
                right = expr;
              });
              if (ast.operator === '+') {
                expression = this.plus(left, right);
              } else if (ast.operator === '-') {
                expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
              } else {
                expression = '(' + left + ')' + ast.operator + '(' + right + ')';
              }
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.LogicalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.left, intoId);
              self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
              recursionFn(intoId);
              break;
            case AST.ConditionalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.test, intoId);
              self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
              recursionFn(intoId);
              break;
            case AST.Identifier:
              intoId = intoId || this.nextId();
              if (nameId) {
                nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
                nameId.computed = false;
                nameId.name = ast.name;
              }
              ensureSafeMemberName(ast.name);
              self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function() {
                self.if_(self.stage === 'inputs' || 's', function() {
                  if (create && create !== 1) {
                    self.if_(self.not(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                  }
                  self.assign(intoId, self.nonComputedMember('s', ast.name));
                });
              }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
              if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
                self.addEnsureSafeObject(intoId);
              }
              recursionFn(intoId);
              break;
            case AST.MemberExpression:
              left = nameId && (nameId.context = this.nextId()) || this.nextId();
              intoId = intoId || this.nextId();
              self.recurse(ast.object, left, undefined, function() {
                self.if_(self.notNull(left), function() {
                  if (ast.computed) {
                    right = self.nextId();
                    self.recurse(ast.property, right);
                    self.addEnsureSafeMemberName(right);
                    if (create && create !== 1) {
                      self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                    }
                    expression = self.ensureSafeObject(self.computedMember(left, right));
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = true;
                      nameId.name = right;
                    }
                  } else {
                    ensureSafeMemberName(ast.property.name);
                    if (create && create !== 1) {
                      self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                    }
                    expression = self.nonComputedMember(left, ast.property.name);
                    if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                      expression = self.ensureSafeObject(expression);
                    }
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = false;
                      nameId.name = ast.property.name;
                    }
                  }
                }, function() {
                  self.assign(intoId, 'undefined');
                });
                recursionFn(intoId);
              }, !!create);
              break;
            case AST.CallExpression:
              intoId = intoId || this.nextId();
              if (ast.filter) {
                right = self.filter(ast.callee.name);
                args = [];
                forEach(ast.arguments, function(expr) {
                  var argument = self.nextId();
                  self.recurse(expr, argument);
                  args.push(argument);
                });
                expression = right + '(' + args.join(',') + ')';
                self.assign(intoId, expression);
                recursionFn(intoId);
              } else {
                right = self.nextId();
                left = {};
                args = [];
                self.recurse(ast.callee, right, left, function() {
                  self.if_(self.notNull(right), function() {
                    self.addEnsureSafeFunction(right);
                    forEach(ast.arguments, function(expr) {
                      self.recurse(expr, self.nextId(), undefined, function(argument) {
                        args.push(self.ensureSafeObject(argument));
                      });
                    });
                    if (left.name) {
                      if (!self.state.expensiveChecks) {
                        self.addEnsureSafeObject(left.context);
                      }
                      expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                    } else {
                      expression = right + '(' + args.join(',') + ')';
                    }
                    expression = self.ensureSafeObject(expression);
                    self.assign(intoId, expression);
                  }, function() {
                    self.assign(intoId, 'undefined');
                  });
                  recursionFn(intoId);
                });
              }
              break;
            case AST.AssignmentExpression:
              right = this.nextId();
              left = {};
              if (!isAssignable(ast.left)) {
                throw $parseMinErr('lval', 'Trying to assing a value to a non l-value');
              }
              this.recurse(ast.left, undefined, left, function() {
                self.if_(self.notNull(left.context), function() {
                  self.recurse(ast.right, right);
                  self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                  expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                  self.assign(intoId, expression);
                  recursionFn(intoId || expression);
                });
              }, 1);
              break;
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                self.recurse(expr, self.nextId(), undefined, function(argument) {
                  args.push(argument);
                });
              });
              expression = '[' + args.join(',') + ']';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                self.recurse(property.value, self.nextId(), undefined, function(expr) {
                  args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value)) + ':' + expr);
                });
              });
              expression = '{' + args.join(',') + '}';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ThisExpression:
              this.assign(intoId, 's');
              recursionFn('s');
              break;
            case AST.NGValueParameter:
              this.assign(intoId, 'v');
              recursionFn('v');
              break;
          }
        },
        getHasOwnProperty: function(element, property) {
          var key = element + '.' + property;
          var own = this.current().own;
          if (!own.hasOwnProperty(key)) {
            own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
          }
          return own[key];
        },
        assign: function(id, value) {
          if (!id)
            return ;
          this.current().body.push(id, '=', value, ';');
          return id;
        },
        filter: function(filterName) {
          if (!this.state.filters.hasOwnProperty(filterName)) {
            this.state.filters[filterName] = this.nextId(true);
          }
          return this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
          return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
        },
        plus: function(left, right) {
          return 'plus(' + left + ',' + right + ')';
        },
        return_: function(id) {
          this.current().body.push('return ', id, ';');
        },
        if_: function(test, alternate, consequent) {
          if (test === true) {
            alternate();
          } else {
            var body = this.current().body;
            body.push('if(', test, '){');
            alternate();
            body.push('}');
            if (consequent) {
              body.push('else{');
              consequent();
              body.push('}');
            }
          }
        },
        not: function(expression) {
          return '!(' + expression + ')';
        },
        notNull: function(expression) {
          return expression + '!=null';
        },
        nonComputedMember: function(left, right) {
          return left + '.' + right;
        },
        computedMember: function(left, right) {
          return left + '[' + right + ']';
        },
        member: function(left, right, computed) {
          if (computed)
            return this.computedMember(left, right);
          return this.nonComputedMember(left, right);
        },
        addEnsureSafeObject: function(item) {
          this.current().body.push(this.ensureSafeObject(item), ';');
        },
        addEnsureSafeMemberName: function(item) {
          this.current().body.push(this.ensureSafeMemberName(item), ';');
        },
        addEnsureSafeFunction: function(item) {
          this.current().body.push(this.ensureSafeFunction(item), ';');
        },
        ensureSafeObject: function(item) {
          return 'ensureSafeObject(' + item + ',text)';
        },
        ensureSafeMemberName: function(item) {
          return 'ensureSafeMemberName(' + item + ',text)';
        },
        ensureSafeFunction: function(item) {
          return 'ensureSafeFunction(' + item + ',text)';
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var self = this;
          return function() {
            self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
          };
        },
        lazyAssign: function(id, value) {
          var self = this;
          return function() {
            self.assign(id, value);
          };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
          return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
          if (isString(value))
            return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
          if (isNumber(value))
            return value.toString();
          if (value === true)
            return 'true';
          if (value === false)
            return 'false';
          if (value === null)
            return 'null';
          if (typeof value === 'undefined')
            return 'undefined';
          throw $parseMinErr('esc', 'IMPOSSIBLE');
        },
        nextId: function(skip, init) {
          var id = 'v' + (this.state.nextId++);
          if (!skip) {
            this.current().vars.push(id + (init ? '=' + init : ''));
          }
          return id;
        },
        current: function() {
          return this.state[this.state.computing];
        }
      };
      function ASTInterpreter(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTInterpreter.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.expression = expression;
          this.expensiveChecks = expensiveChecks;
          findConstantAndWatchExpressions(ast, self.$filter);
          var assignable;
          var assign;
          if ((assignable = assignableAST(ast))) {
            assign = this.recurse(assignable);
          }
          var toWatch = getInputs(ast.body);
          var inputs;
          if (toWatch) {
            inputs = [];
            forEach(toWatch, function(watch, key) {
              var input = self.recurse(watch);
              watch.input = input;
              inputs.push(input);
              watch.watchId = key;
            });
          }
          var expressions = [];
          forEach(ast.body, function(expression) {
            expressions.push(self.recurse(expression.expression));
          });
          var fn = ast.body.length === 0 ? function() {} : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
            var lastValue;
            forEach(expressions, function(exp) {
              lastValue = exp(scope, locals);
            });
            return lastValue;
          };
          if (assign) {
            fn.assign = function(scope, value, locals) {
              return assign(scope, locals, value);
            };
          }
          if (inputs) {
            fn.inputs = inputs;
          }
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        recurse: function(ast, context, create) {
          var left,
              right,
              self = this,
              args,
              expression;
          if (ast.input) {
            return this.inputs(ast.input, ast.watchId);
          }
          switch (ast.type) {
            case AST.Literal:
              return this.value(ast.value, context);
            case AST.UnaryExpression:
              right = this.recurse(ast.argument);
              return this['unary' + ast.operator](right, context);
            case AST.BinaryExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.LogicalExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.ConditionalExpression:
              return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
            case AST.Identifier:
              ensureSafeMemberName(ast.name, self.expression);
              return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);
            case AST.MemberExpression:
              left = this.recurse(ast.object, false, !!create);
              if (!ast.computed) {
                ensureSafeMemberName(ast.property.name, self.expression);
                right = ast.property.name;
              }
              if (ast.computed)
                right = this.recurse(ast.property);
              return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
            case AST.CallExpression:
              args = [];
              forEach(ast.arguments, function(expr) {
                args.push(self.recurse(expr));
              });
              if (ast.filter)
                right = this.$filter(ast.callee.name);
              if (!ast.filter)
                right = this.recurse(ast.callee, true);
              return ast.filter ? function(scope, locals, assign, inputs) {
                var values = [];
                for (var i = 0; i < args.length; ++i) {
                  values.push(args[i](scope, locals, assign, inputs));
                }
                var value = right.apply(undefined, values, inputs);
                return context ? {
                  context: undefined,
                  name: undefined,
                  value: value
                } : value;
              } : function(scope, locals, assign, inputs) {
                var rhs = right(scope, locals, assign, inputs);
                var value;
                if (rhs.value != null) {
                  ensureSafeObject(rhs.context, self.expression);
                  ensureSafeFunction(rhs.value, self.expression);
                  var values = [];
                  for (var i = 0; i < args.length; ++i) {
                    values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                  }
                  value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                }
                return context ? {value: value} : value;
              };
            case AST.AssignmentExpression:
              left = this.recurse(ast.left, true, 1);
              right = this.recurse(ast.right);
              return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                ensureSafeObject(lhs.value, self.expression);
                lhs.context[lhs.name] = rhs;
                return context ? {value: rhs} : rhs;
              };
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                args.push(self.recurse(expr));
              });
              return function(scope, locals, assign, inputs) {
                var value = [];
                for (var i = 0; i < args.length; ++i) {
                  value.push(args[i](scope, locals, assign, inputs));
                }
                return context ? {value: value} : value;
              };
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                args.push({
                  key: property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value),
                  value: self.recurse(property.value)
                });
              });
              return function(scope, locals, assign, inputs) {
                var value = {};
                for (var i = 0; i < args.length; ++i) {
                  value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                }
                return context ? {value: value} : value;
              };
            case AST.ThisExpression:
              return function(scope) {
                return context ? {value: scope} : scope;
              };
            case AST.NGValueParameter:
              return function(scope, locals, assign, inputs) {
                return context ? {value: assign} : assign;
              };
          }
        },
        'unary+': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = +arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary-': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = -arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary!': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = !argument(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary+': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = plusFn(lhs, rhs);
            return context ? {value: arg} : arg;
          };
        },
        'binary-': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
            return context ? {value: arg} : arg;
          };
        },
        'binary*': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary/': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary%': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary===': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary&&': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary||': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'ternary?:': function(test, alternate, consequent, context) {
          return function(scope, locals, assign, inputs) {
            var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        value: function(value, context) {
          return function() {
            return context ? {
              context: undefined,
              name: undefined,
              value: value
            } : value;
          };
        },
        identifier: function(name, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var base = locals && (name in locals) ? locals : scope;
            if (create && create !== 1 && base && !(base[name])) {
              base[name] = {};
            }
            var value = base ? base[name] : undefined;
            if (expensiveChecks) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: base,
                name: name,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        computedMember: function(left, right, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs;
            var value;
            if (lhs != null) {
              rhs = right(scope, locals, assign, inputs);
              ensureSafeMemberName(rhs, expression);
              if (create && create !== 1 && lhs && !(lhs[rhs])) {
                lhs[rhs] = {};
              }
              value = lhs[rhs];
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: rhs,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            if (create && create !== 1 && lhs && !(lhs[right])) {
              lhs[right] = {};
            }
            var value = lhs != null ? lhs[right] : undefined;
            if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: right,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        inputs: function(input, watchId) {
          return function(scope, value, locals, inputs) {
            if (inputs)
              return inputs[watchId];
            return input(scope, value, locals);
          };
        }
      };
      var Parser = function(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
        this.ast = new AST(this.lexer);
        this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
      };
      Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
          return this.astCompiler.compile(text, this.options.expensiveChecks);
        }
      };
      var getterFnCacheDefault = createMap();
      var getterFnCacheExpensive = createMap();
      function isPossiblyDangerousMemberName(name) {
        return name == 'constructor';
      }
      var objectValueOf = Object.prototype.valueOf;
      function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
      }
      function $ParseProvider() {
        var cacheDefault = createMap();
        var cacheExpensive = createMap();
        this.$get = ['$filter', function($filter) {
          var noUnsafeEval = csp().noUnsafeEval;
          var $parseOptions = {
            csp: noUnsafeEval,
            expensiveChecks: false
          },
              $parseOptionsExpensive = {
                csp: noUnsafeEval,
                expensiveChecks: true
              };
          return function $parse(exp, interceptorFn, expensiveChecks) {
            var parsedExpression,
                oneTime,
                cacheKey;
            switch (typeof exp) {
              case 'string':
                exp = exp.trim();
                cacheKey = exp;
                var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
                parsedExpression = cache[cacheKey];
                if (!parsedExpression) {
                  if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                    oneTime = true;
                    exp = exp.substring(2);
                  }
                  var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                  var lexer = new Lexer(parseOptions);
                  var parser = new Parser(lexer, $filter, parseOptions);
                  parsedExpression = parser.parse(exp);
                  if (parsedExpression.constant) {
                    parsedExpression.$$watchDelegate = constantWatchDelegate;
                  } else if (oneTime) {
                    parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                  } else if (parsedExpression.inputs) {
                    parsedExpression.$$watchDelegate = inputsWatchDelegate;
                  }
                  cache[cacheKey] = parsedExpression;
                }
                return addInterceptor(parsedExpression, interceptorFn);
              case 'function':
                return addInterceptor(exp, interceptorFn);
              default:
                return noop;
            }
          };
          function expressionInputDirtyCheck(newValue, oldValueOfValue) {
            if (newValue == null || oldValueOfValue == null) {
              return newValue === oldValueOfValue;
            }
            if (typeof newValue === 'object') {
              newValue = getValueOf(newValue);
              if (typeof newValue === 'object') {
                return false;
              }
            }
            return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
          }
          function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
            var inputExpressions = parsedExpression.inputs;
            var lastResult;
            if (inputExpressions.length === 1) {
              var oldInputValueOf = expressionInputDirtyCheck;
              inputExpressions = inputExpressions[0];
              return scope.$watch(function expressionInputWatch(scope) {
                var newInputValue = inputExpressions(scope);
                if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                  lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                  oldInputValueOf = newInputValue && getValueOf(newInputValue);
                }
                return lastResult;
              }, listener, objectEquality, prettyPrintExpression);
            }
            var oldInputValueOfValues = [];
            var oldInputValues = [];
            for (var i = 0,
                ii = inputExpressions.length; i < ii; i++) {
              oldInputValueOfValues[i] = expressionInputDirtyCheck;
              oldInputValues[i] = null;
            }
            return scope.$watch(function expressionInputsWatch(scope) {
              var changed = false;
              for (var i = 0,
                  ii = inputExpressions.length; i < ii; i++) {
                var newInputValue = inputExpressions[i](scope);
                if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                  oldInputValues[i] = newInputValue;
                  oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                }
              }
              if (changed) {
                lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
              }
              return lastResult;
            }, listener, objectEquality, prettyPrintExpression);
          }
          function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              if (isDefined(value)) {
                scope.$$postDigest(function() {
                  if (isDefined(lastValue)) {
                    unwatch();
                  }
                });
              }
            }, objectEquality);
          }
          function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.call(this, value, old, scope);
              }
              if (isAllDefined(value)) {
                scope.$$postDigest(function() {
                  if (isAllDefined(lastValue))
                    unwatch();
                });
              }
            }, objectEquality);
            function isAllDefined(value) {
              var allDefined = true;
              forEach(value, function(val) {
                if (!isDefined(val))
                  allDefined = false;
              });
              return allDefined;
            }
          }
          function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch;
            return unwatch = scope.$watch(function constantWatch(scope) {
              return parsedExpression(scope);
            }, function constantListener(value, old, scope) {
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              unwatch();
            }, objectEquality);
          }
          function addInterceptor(parsedExpression, interceptorFn) {
            if (!interceptorFn)
              return parsedExpression;
            var watchDelegate = parsedExpression.$$watchDelegate;
            var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
            var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              return interceptorFn(value, scope, locals);
            } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              var result = interceptorFn(value, scope, locals);
              return isDefined(value) ? result : value;
            };
            if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
              fn.$$watchDelegate = parsedExpression.$$watchDelegate;
            } else if (!interceptorFn.$stateful) {
              fn.$$watchDelegate = inputsWatchDelegate;
              fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
            }
            return fn;
          }
        }];
      }
      function $QProvider() {
        this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
          return qFactory(function(callback) {
            $rootScope.$evalAsync(callback);
          }, $exceptionHandler);
        }];
      }
      function $$QProvider() {
        this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
          return qFactory(function(callback) {
            $browser.defer(callback);
          }, $exceptionHandler);
        }];
      }
      function qFactory(nextTick, exceptionHandler) {
        var $qMinErr = minErr('$q', TypeError);
        function callOnce(self, resolveFn, rejectFn) {
          var called = false;
          function wrap(fn) {
            return function(value) {
              if (called)
                return ;
              called = true;
              fn.call(self, value);
            };
          }
          return [wrap(resolveFn), wrap(rejectFn)];
        }
        var defer = function() {
          return new Deferred();
        };
        function Promise() {
          this.$$state = {status: 0};
        }
        extend(Promise.prototype, {
          then: function(onFulfilled, onRejected, progressBack) {
            if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
              return this;
            }
            var result = new Deferred();
            this.$$state.pending = this.$$state.pending || [];
            this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
            if (this.$$state.status > 0)
              scheduleProcessQueue(this.$$state);
            return result.promise;
          },
          "catch": function(callback) {
            return this.then(null, callback);
          },
          "finally": function(callback, progressBack) {
            return this.then(function(value) {
              return handleCallback(value, true, callback);
            }, function(error) {
              return handleCallback(error, false, callback);
            }, progressBack);
          }
        });
        function simpleBind(context, fn) {
          return function(value) {
            fn.call(context, value);
          };
        }
        function processQueue(state) {
          var fn,
              deferred,
              pending;
          pending = state.pending;
          state.processScheduled = false;
          state.pending = undefined;
          for (var i = 0,
              ii = pending.length; i < ii; ++i) {
            deferred = pending[i][0];
            fn = pending[i][state.status];
            try {
              if (isFunction(fn)) {
                deferred.resolve(fn(state.value));
              } else if (state.status === 1) {
                deferred.resolve(state.value);
              } else {
                deferred.reject(state.value);
              }
            } catch (e) {
              deferred.reject(e);
              exceptionHandler(e);
            }
          }
        }
        function scheduleProcessQueue(state) {
          if (state.processScheduled || !state.pending)
            return ;
          state.processScheduled = true;
          nextTick(function() {
            processQueue(state);
          });
        }
        function Deferred() {
          this.promise = new Promise();
          this.resolve = simpleBind(this, this.resolve);
          this.reject = simpleBind(this, this.reject);
          this.notify = simpleBind(this, this.notify);
        }
        extend(Deferred.prototype, {
          resolve: function(val) {
            if (this.promise.$$state.status)
              return ;
            if (val === this.promise) {
              this.$$reject($qMinErr('qcycle', "Expected promise to be resolved with value other than itself '{0}'", val));
            } else {
              this.$$resolve(val);
            }
          },
          $$resolve: function(val) {
            var then,
                fns;
            fns = callOnce(this, this.$$resolve, this.$$reject);
            try {
              if ((isObject(val) || isFunction(val)))
                then = val && val.then;
              if (isFunction(then)) {
                this.promise.$$state.status = -1;
                then.call(val, fns[0], fns[1], this.notify);
              } else {
                this.promise.$$state.value = val;
                this.promise.$$state.status = 1;
                scheduleProcessQueue(this.promise.$$state);
              }
            } catch (e) {
              fns[1](e);
              exceptionHandler(e);
            }
          },
          reject: function(reason) {
            if (this.promise.$$state.status)
              return ;
            this.$$reject(reason);
          },
          $$reject: function(reason) {
            this.promise.$$state.value = reason;
            this.promise.$$state.status = 2;
            scheduleProcessQueue(this.promise.$$state);
          },
          notify: function(progress) {
            var callbacks = this.promise.$$state.pending;
            if ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) {
              nextTick(function() {
                var callback,
                    result;
                for (var i = 0,
                    ii = callbacks.length; i < ii; i++) {
                  result = callbacks[i][0];
                  callback = callbacks[i][3];
                  try {
                    result.notify(isFunction(callback) ? callback(progress) : progress);
                  } catch (e) {
                    exceptionHandler(e);
                  }
                }
              });
            }
          }
        });
        var reject = function(reason) {
          var result = new Deferred();
          result.reject(reason);
          return result.promise;
        };
        var makePromise = function makePromise(value, resolved) {
          var result = new Deferred();
          if (resolved) {
            result.resolve(value);
          } else {
            result.reject(value);
          }
          return result.promise;
        };
        var handleCallback = function handleCallback(value, isResolved, callback) {
          var callbackOutput = null;
          try {
            if (isFunction(callback))
              callbackOutput = callback();
          } catch (e) {
            return makePromise(e, false);
          }
          if (isPromiseLike(callbackOutput)) {
            return callbackOutput.then(function() {
              return makePromise(value, isResolved);
            }, function(error) {
              return makePromise(error, false);
            });
          } else {
            return makePromise(value, isResolved);
          }
        };
        var when = function(value, callback, errback, progressBack) {
          var result = new Deferred();
          result.resolve(value);
          return result.promise.then(callback, errback, progressBack);
        };
        var resolve = when;
        function all(promises) {
          var deferred = new Deferred(),
              counter = 0,
              results = isArray(promises) ? [] : {};
          forEach(promises, function(promise, key) {
            counter++;
            when(promise).then(function(value) {
              if (results.hasOwnProperty(key))
                return ;
              results[key] = value;
              if (!(--counter))
                deferred.resolve(results);
            }, function(reason) {
              if (results.hasOwnProperty(key))
                return ;
              deferred.reject(reason);
            });
          });
          if (counter === 0) {
            deferred.resolve(results);
          }
          return deferred.promise;
        }
        var $Q = function Q(resolver) {
          if (!isFunction(resolver)) {
            throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
          }
          if (!(this instanceof Q)) {
            return new Q(resolver);
          }
          var deferred = new Deferred();
          function resolveFn(value) {
            deferred.resolve(value);
          }
          function rejectFn(reason) {
            deferred.reject(reason);
          }
          resolver(resolveFn, rejectFn);
          return deferred.promise;
        };
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.resolve = resolve;
        $Q.all = all;
        return $Q;
      }
      function $$RAFProvider() {
        this.$get = ['$window', '$timeout', function($window, $timeout) {
          var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
          var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
          var rafSupported = !!requestAnimationFrame;
          var rafFn = rafSupported ? function(fn) {
            var id = requestAnimationFrame(fn);
            return function() {
              cancelAnimationFrame(id);
            };
          } : function(fn) {
            var timer = $timeout(fn, 16.66, false);
            return function() {
              $timeout.cancel(timer);
            };
          };
          queueFn.supported = rafSupported;
          var cancelLastRAF;
          var taskCount = 0;
          var taskQueue = [];
          return queueFn;
          function flush() {
            for (var i = 0; i < taskQueue.length; i++) {
              var task = taskQueue[i];
              if (task) {
                taskQueue[i] = null;
                task();
              }
            }
            taskCount = taskQueue.length = 0;
          }
          function queueFn(asyncFn) {
            var index = taskQueue.length;
            taskCount++;
            taskQueue.push(asyncFn);
            if (index === 0) {
              cancelLastRAF = rafFn(flush);
            }
            return function cancelQueueFn() {
              if (index >= 0) {
                taskQueue[index] = null;
                index = null;
                if (--taskCount === 0 && cancelLastRAF) {
                  cancelLastRAF();
                  cancelLastRAF = null;
                  taskQueue.length = 0;
                }
              }
            };
          }
        }];
      }
      function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr('$rootScope');
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
          if (arguments.length) {
            TTL = value;
          }
          return TTL;
        };
        function createChildScopeClass(parent) {
          function ChildScope() {
            this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$id = nextUid();
            this.$$ChildScope = null;
          }
          ChildScope.prototype = parent;
          return ChildScope;
        }
        this.$get = ['$injector', '$exceptionHandler', '$parse', '$browser', function($injector, $exceptionHandler, $parse, $browser) {
          function destroyChildScope($event) {
            $event.currentScope.$$destroyed = true;
          }
          function Scope() {
            this.$id = nextUid();
            this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
            this.$root = this;
            this.$$destroyed = false;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$$isolateBindings = null;
          }
          Scope.prototype = {
            constructor: Scope,
            $new: function(isolate, parent) {
              var child;
              parent = parent || this;
              if (isolate) {
                child = new Scope();
                child.$root = this.$root;
              } else {
                if (!this.$$ChildScope) {
                  this.$$ChildScope = createChildScopeClass(this);
                }
                child = new this.$$ChildScope();
              }
              child.$parent = parent;
              child.$$prevSibling = parent.$$childTail;
              if (parent.$$childHead) {
                parent.$$childTail.$$nextSibling = child;
                parent.$$childTail = child;
              } else {
                parent.$$childHead = parent.$$childTail = child;
              }
              if (isolate || parent != this)
                child.$on('$destroy', destroyChildScope);
              return child;
            },
            $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
              var get = $parse(watchExp);
              if (get.$$watchDelegate) {
                return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
              }
              var scope = this,
                  array = scope.$$watchers,
                  watcher = {
                    fn: listener,
                    last: initWatchVal,
                    get: get,
                    exp: prettyPrintExpression || watchExp,
                    eq: !!objectEquality
                  };
              lastDirtyWatch = null;
              if (!isFunction(listener)) {
                watcher.fn = noop;
              }
              if (!array) {
                array = scope.$$watchers = [];
              }
              array.unshift(watcher);
              incrementWatchersCount(this, 1);
              return function deregisterWatch() {
                if (arrayRemove(array, watcher) >= 0) {
                  incrementWatchersCount(scope, -1);
                }
                lastDirtyWatch = null;
              };
            },
            $watchGroup: function(watchExpressions, listener) {
              var oldValues = new Array(watchExpressions.length);
              var newValues = new Array(watchExpressions.length);
              var deregisterFns = [];
              var self = this;
              var changeReactionScheduled = false;
              var firstRun = true;
              if (!watchExpressions.length) {
                var shouldCall = true;
                self.$evalAsync(function() {
                  if (shouldCall)
                    listener(newValues, newValues, self);
                });
                return function deregisterWatchGroup() {
                  shouldCall = false;
                };
              }
              if (watchExpressions.length === 1) {
                return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                  newValues[0] = value;
                  oldValues[0] = oldValue;
                  listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
                });
              }
              forEach(watchExpressions, function(expr, i) {
                var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                  newValues[i] = value;
                  oldValues[i] = oldValue;
                  if (!changeReactionScheduled) {
                    changeReactionScheduled = true;
                    self.$evalAsync(watchGroupAction);
                  }
                });
                deregisterFns.push(unwatchFn);
              });
              function watchGroupAction() {
                changeReactionScheduled = false;
                if (firstRun) {
                  firstRun = false;
                  listener(newValues, newValues, self);
                } else {
                  listener(newValues, oldValues, self);
                }
              }
              return function deregisterWatchGroup() {
                while (deregisterFns.length) {
                  deregisterFns.shift()();
                }
              };
            },
            $watchCollection: function(obj, listener) {
              $watchCollectionInterceptor.$stateful = true;
              var self = this;
              var newValue;
              var oldValue;
              var veryOldValue;
              var trackVeryOldValue = (listener.length > 1);
              var changeDetected = 0;
              var changeDetector = $parse(obj, $watchCollectionInterceptor);
              var internalArray = [];
              var internalObject = {};
              var initRun = true;
              var oldLength = 0;
              function $watchCollectionInterceptor(_value) {
                newValue = _value;
                var newLength,
                    key,
                    bothNaN,
                    newItem,
                    oldItem;
                if (isUndefined(newValue))
                  return ;
                if (!isObject(newValue)) {
                  if (oldValue !== newValue) {
                    oldValue = newValue;
                    changeDetected++;
                  }
                } else if (isArrayLike(newValue)) {
                  if (oldValue !== internalArray) {
                    oldValue = internalArray;
                    oldLength = oldValue.length = 0;
                    changeDetected++;
                  }
                  newLength = newValue.length;
                  if (oldLength !== newLength) {
                    changeDetected++;
                    oldValue.length = oldLength = newLength;
                  }
                  for (var i = 0; i < newLength; i++) {
                    oldItem = oldValue[i];
                    newItem = newValue[i];
                    bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                    if (!bothNaN && (oldItem !== newItem)) {
                      changeDetected++;
                      oldValue[i] = newItem;
                    }
                  }
                } else {
                  if (oldValue !== internalObject) {
                    oldValue = internalObject = {};
                    oldLength = 0;
                    changeDetected++;
                  }
                  newLength = 0;
                  for (key in newValue) {
                    if (newValue.hasOwnProperty(key)) {
                      newLength++;
                      newItem = newValue[key];
                      oldItem = oldValue[key];
                      if (key in oldValue) {
                        bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                        if (!bothNaN && (oldItem !== newItem)) {
                          changeDetected++;
                          oldValue[key] = newItem;
                        }
                      } else {
                        oldLength++;
                        oldValue[key] = newItem;
                        changeDetected++;
                      }
                    }
                  }
                  if (oldLength > newLength) {
                    changeDetected++;
                    for (key in oldValue) {
                      if (!newValue.hasOwnProperty(key)) {
                        oldLength--;
                        delete oldValue[key];
                      }
                    }
                  }
                }
                return changeDetected;
              }
              function $watchCollectionAction() {
                if (initRun) {
                  initRun = false;
                  listener(newValue, newValue, self);
                } else {
                  listener(newValue, veryOldValue, self);
                }
                if (trackVeryOldValue) {
                  if (!isObject(newValue)) {
                    veryOldValue = newValue;
                  } else if (isArrayLike(newValue)) {
                    veryOldValue = new Array(newValue.length);
                    for (var i = 0; i < newValue.length; i++) {
                      veryOldValue[i] = newValue[i];
                    }
                  } else {
                    veryOldValue = {};
                    for (var key in newValue) {
                      if (hasOwnProperty.call(newValue, key)) {
                        veryOldValue[key] = newValue[key];
                      }
                    }
                  }
                }
              }
              return this.$watch(changeDetector, $watchCollectionAction);
            },
            $digest: function() {
              var watch,
                  value,
                  last,
                  watchers,
                  length,
                  dirty,
                  ttl = TTL,
                  next,
                  current,
                  target = this,
                  watchLog = [],
                  logIdx,
                  logMsg,
                  asyncTask;
              beginPhase('$digest');
              $browser.$$checkUrlChange();
              if (this === $rootScope && applyAsyncId !== null) {
                $browser.defer.cancel(applyAsyncId);
                flushApplyAsync();
              }
              lastDirtyWatch = null;
              do {
                dirty = false;
                current = target;
                while (asyncQueue.length) {
                  try {
                    asyncTask = asyncQueue.shift();
                    asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                  lastDirtyWatch = null;
                }
                traverseScopesLoop: do {
                  if ((watchers = current.$$watchers)) {
                    length = watchers.length;
                    while (length--) {
                      try {
                        watch = watchers[length];
                        if (watch) {
                          if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : (typeof value === 'number' && typeof last === 'number' && isNaN(value) && isNaN(last)))) {
                            dirty = true;
                            lastDirtyWatch = watch;
                            watch.last = watch.eq ? copy(value, null) : value;
                            watch.fn(value, ((last === initWatchVal) ? value : last), current);
                            if (ttl < 5) {
                              logIdx = 4 - ttl;
                              if (!watchLog[logIdx])
                                watchLog[logIdx] = [];
                              watchLog[logIdx].push({
                                msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                newVal: value,
                                oldVal: last
                              });
                            }
                          } else if (watch === lastDirtyWatch) {
                            dirty = false;
                            break traverseScopesLoop;
                          }
                        }
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                  }
                  if (!(next = ((current.$$watchersCount && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                    while (current !== target && !(next = current.$$nextSibling)) {
                      current = current.$parent;
                    }
                  }
                } while ((current = next));
                if ((dirty || asyncQueue.length) && !(ttl--)) {
                  clearPhase();
                  throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
                }
              } while (dirty || asyncQueue.length);
              clearPhase();
              while (postDigestQueue.length) {
                try {
                  postDigestQueue.shift()();
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            },
            $destroy: function() {
              if (this.$$destroyed)
                return ;
              var parent = this.$parent;
              this.$broadcast('$destroy');
              this.$$destroyed = true;
              if (this === $rootScope) {
                $browser.$$applicationDestroyed();
              }
              incrementWatchersCount(this, -this.$$watchersCount);
              for (var eventName in this.$$listenerCount) {
                decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
              }
              if (parent && parent.$$childHead == this)
                parent.$$childHead = this.$$nextSibling;
              if (parent && parent.$$childTail == this)
                parent.$$childTail = this.$$prevSibling;
              if (this.$$prevSibling)
                this.$$prevSibling.$$nextSibling = this.$$nextSibling;
              if (this.$$nextSibling)
                this.$$nextSibling.$$prevSibling = this.$$prevSibling;
              this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
              this.$on = this.$watch = this.$watchGroup = function() {
                return noop;
              };
              this.$$listeners = {};
              this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = this.$$watchers = null;
            },
            $eval: function(expr, locals) {
              return $parse(expr)(this, locals);
            },
            $evalAsync: function(expr, locals) {
              if (!$rootScope.$$phase && !asyncQueue.length) {
                $browser.defer(function() {
                  if (asyncQueue.length) {
                    $rootScope.$digest();
                  }
                });
              }
              asyncQueue.push({
                scope: this,
                expression: expr,
                locals: locals
              });
            },
            $$postDigest: function(fn) {
              postDigestQueue.push(fn);
            },
            $apply: function(expr) {
              try {
                beginPhase('$apply');
                try {
                  return this.$eval(expr);
                } finally {
                  clearPhase();
                }
              } catch (e) {
                $exceptionHandler(e);
              } finally {
                try {
                  $rootScope.$digest();
                } catch (e) {
                  $exceptionHandler(e);
                  throw e;
                }
              }
            },
            $applyAsync: function(expr) {
              var scope = this;
              expr && applyAsyncQueue.push($applyAsyncExpression);
              scheduleApplyAsync();
              function $applyAsyncExpression() {
                scope.$eval(expr);
              }
            },
            $on: function(name, listener) {
              var namedListeners = this.$$listeners[name];
              if (!namedListeners) {
                this.$$listeners[name] = namedListeners = [];
              }
              namedListeners.push(listener);
              var current = this;
              do {
                if (!current.$$listenerCount[name]) {
                  current.$$listenerCount[name] = 0;
                }
                current.$$listenerCount[name]++;
              } while ((current = current.$parent));
              var self = this;
              return function() {
                var indexOfListener = namedListeners.indexOf(listener);
                if (indexOfListener !== -1) {
                  namedListeners[indexOfListener] = null;
                  decrementListenerCount(self, 1, name);
                }
              };
            },
            $emit: function(name, args) {
              var empty = [],
                  namedListeners,
                  scope = this,
                  stopPropagation = false,
                  event = {
                    name: name,
                    targetScope: scope,
                    stopPropagation: function() {
                      stopPropagation = true;
                    },
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  },
                  listenerArgs = concat([event], arguments, 1),
                  i,
                  length;
              do {
                namedListeners = scope.$$listeners[name] || empty;
                event.currentScope = scope;
                for (i = 0, length = namedListeners.length; i < length; i++) {
                  if (!namedListeners[i]) {
                    namedListeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    namedListeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (stopPropagation) {
                  event.currentScope = null;
                  return event;
                }
                scope = scope.$parent;
              } while (scope);
              event.currentScope = null;
              return event;
            },
            $broadcast: function(name, args) {
              var target = this,
                  current = target,
                  next = target,
                  event = {
                    name: name,
                    targetScope: target,
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  };
              if (!target.$$listenerCount[name])
                return event;
              var listenerArgs = concat([event], arguments, 1),
                  listeners,
                  i,
                  length;
              while ((current = next)) {
                event.currentScope = current;
                listeners = current.$$listeners[name] || [];
                for (i = 0, length = listeners.length; i < length; i++) {
                  if (!listeners[i]) {
                    listeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    listeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (!(next = ((current.$$listenerCount[name] && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              }
              event.currentScope = null;
              return event;
            }
          };
          var $rootScope = new Scope();
          var asyncQueue = $rootScope.$$asyncQueue = [];
          var postDigestQueue = $rootScope.$$postDigestQueue = [];
          var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
          return $rootScope;
          function beginPhase(phase) {
            if ($rootScope.$$phase) {
              throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
            }
            $rootScope.$$phase = phase;
          }
          function clearPhase() {
            $rootScope.$$phase = null;
          }
          function incrementWatchersCount(current, count) {
            do {
              current.$$watchersCount += count;
            } while ((current = current.$parent));
          }
          function decrementListenerCount(current, count, name) {
            do {
              current.$$listenerCount[name] -= count;
              if (current.$$listenerCount[name] === 0) {
                delete current.$$listenerCount[name];
              }
            } while ((current = current.$parent));
          }
          function initWatchVal() {}
          function flushApplyAsync() {
            while (applyAsyncQueue.length) {
              try {
                applyAsyncQueue.shift()();
              } catch (e) {
                $exceptionHandler(e);
              }
            }
            applyAsyncId = null;
          }
          function scheduleApplyAsync() {
            if (applyAsyncId === null) {
              applyAsyncId = $browser.defer(function() {
                $rootScope.$apply(flushApplyAsync);
              });
            }
          }
        }];
      }
      function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
            imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            aHrefSanitizationWhitelist = regexp;
            return this;
          }
          return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            imgSrcSanitizationWhitelist = regexp;
            return this;
          }
          return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
          return function sanitizeUri(uri, isImage) {
            var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
            var normalizedVal;
            normalizedVal = urlResolve(uri).href;
            if (normalizedVal !== '' && !normalizedVal.match(regex)) {
              return 'unsafe:' + normalizedVal;
            }
            return uri;
          };
        };
      }
      var $sceMinErr = minErr('$sce');
      var SCE_CONTEXTS = {
        HTML: 'html',
        CSS: 'css',
        URL: 'url',
        RESOURCE_URL: 'resourceUrl',
        JS: 'js'
      };
      function adjustMatcher(matcher) {
        if (matcher === 'self') {
          return matcher;
        } else if (isString(matcher)) {
          if (matcher.indexOf('***') > -1) {
            throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
          }
          matcher = escapeForRegexp(matcher).replace('\\*\\*', '.*').replace('\\*', '[^:/.?&;]*');
          return new RegExp('^' + matcher + '$');
        } else if (isRegExp(matcher)) {
          return new RegExp('^' + matcher.source + '$');
        } else {
          throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
        }
      }
      function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
          forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
          });
        }
        return adjustedMatchers;
      }
      function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = ['self'],
            resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
          if (arguments.length) {
            resourceUrlWhitelist = adjustMatchers(value);
          }
          return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
          if (arguments.length) {
            resourceUrlBlacklist = adjustMatchers(value);
          }
          return resourceUrlBlacklist;
        };
        this.$get = ['$injector', function($injector) {
          var htmlSanitizer = function htmlSanitizer(html) {
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          };
          if ($injector.has('$sanitize')) {
            htmlSanitizer = $injector.get('$sanitize');
          }
          function matchUrl(matcher, parsedUrl) {
            if (matcher === 'self') {
              return urlIsSameOrigin(parsedUrl);
            } else {
              return !!matcher.exec(parsedUrl.href);
            }
          }
          function isResourceUrlAllowedByPolicy(url) {
            var parsedUrl = urlResolve(url.toString());
            var i,
                n,
                allowed = false;
            for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
              if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                allowed = true;
                break;
              }
            }
            if (allowed) {
              for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                  allowed = false;
                  break;
                }
              }
            }
            return allowed;
          }
          function generateHolderType(Base) {
            var holderType = function TrustedValueHolderType(trustedValue) {
              this.$$unwrapTrustedValue = function() {
                return trustedValue;
              };
            };
            if (Base) {
              holderType.prototype = new Base();
            }
            holderType.prototype.valueOf = function sceValueOf() {
              return this.$$unwrapTrustedValue();
            };
            holderType.prototype.toString = function sceToString() {
              return this.$$unwrapTrustedValue().toString();
            };
            return holderType;
          }
          var trustedValueHolderBase = generateHolderType(),
              byType = {};
          byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
          function trustAs(type, trustedValue) {
            var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (!Constructor) {
              throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
            }
            if (trustedValue === null || trustedValue === undefined || trustedValue === '') {
              return trustedValue;
            }
            if (typeof trustedValue !== 'string') {
              throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
            }
            return new Constructor(trustedValue);
          }
          function valueOf(maybeTrusted) {
            if (maybeTrusted instanceof trustedValueHolderBase) {
              return maybeTrusted.$$unwrapTrustedValue();
            } else {
              return maybeTrusted;
            }
          }
          function getTrusted(type, maybeTrusted) {
            if (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === '') {
              return maybeTrusted;
            }
            var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (constructor && maybeTrusted instanceof constructor) {
              return maybeTrusted.$$unwrapTrustedValue();
            }
            if (type === SCE_CONTEXTS.RESOURCE_URL) {
              if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                return maybeTrusted;
              } else {
                throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
              }
            } else if (type === SCE_CONTEXTS.HTML) {
              return htmlSanitizer(maybeTrusted);
            }
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          }
          return {
            trustAs: trustAs,
            getTrusted: getTrusted,
            valueOf: valueOf
          };
        }];
      }
      function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
          if (arguments.length) {
            enabled = !!value;
          }
          return enabled;
        };
        this.$get = ['$parse', '$sceDelegate', function($parse, $sceDelegate) {
          if (enabled && msie < 8) {
            throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
          }
          var sce = shallowCopy(SCE_CONTEXTS);
          sce.isEnabled = function() {
            return enabled;
          };
          sce.trustAs = $sceDelegate.trustAs;
          sce.getTrusted = $sceDelegate.getTrusted;
          sce.valueOf = $sceDelegate.valueOf;
          if (!enabled) {
            sce.trustAs = sce.getTrusted = function(type, value) {
              return value;
            };
            sce.valueOf = identity;
          }
          sce.parseAs = function sceParseAs(type, expr) {
            var parsed = $parse(expr);
            if (parsed.literal && parsed.constant) {
              return parsed;
            } else {
              return $parse(expr, function(value) {
                return sce.getTrusted(type, value);
              });
            }
          };
          var parse = sce.parseAs,
              getTrusted = sce.getTrusted,
              trustAs = sce.trustAs;
          forEach(SCE_CONTEXTS, function(enumValue, name) {
            var lName = lowercase(name);
            sce[camelCase("parse_as_" + lName)] = function(expr) {
              return parse(enumValue, expr);
            };
            sce[camelCase("get_trusted_" + lName)] = function(value) {
              return getTrusted(enumValue, value);
            };
            sce[camelCase("trust_as_" + lName)] = function(value) {
              return trustAs(enumValue, value);
            };
          });
          return sce;
        }];
      }
      function $SnifferProvider() {
        this.$get = ['$window', '$document', function($window, $document) {
          var eventSupport = {},
              android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
              boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
              document = $document[0] || {},
              vendorPrefix,
              vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
              bodyStyle = document.body && document.body.style,
              transitions = false,
              animations = false,
              match;
          if (bodyStyle) {
            for (var prop in bodyStyle) {
              if (match = vendorRegex.exec(prop)) {
                vendorPrefix = match[0];
                vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                break;
              }
            }
            if (!vendorPrefix) {
              vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
            }
            transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
            animations = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
            if (android && (!transitions || !animations)) {
              transitions = isString(bodyStyle.webkitTransition);
              animations = isString(bodyStyle.webkitAnimation);
            }
          }
          return {
            history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
            hasEvent: function(event) {
              if (event === 'input' && msie <= 11)
                return false;
              if (isUndefined(eventSupport[event])) {
                var divElm = document.createElement('div');
                eventSupport[event] = 'on' + event in divElm;
              }
              return eventSupport[event];
            },
            csp: csp(),
            vendorPrefix: vendorPrefix,
            transitions: transitions,
            animations: animations,
            android: android
          };
        }];
      }
      var $compileMinErr = minErr('$compile');
      function $TemplateRequestProvider() {
        this.$get = ['$templateCache', '$http', '$q', '$sce', function($templateCache, $http, $q, $sce) {
          function handleRequestFn(tpl, ignoreRequestError) {
            handleRequestFn.totalPendingRequests++;
            if (!isString(tpl) || !$templateCache.get(tpl)) {
              tpl = $sce.getTrustedResourceUrl(tpl);
            }
            var transformResponse = $http.defaults && $http.defaults.transformResponse;
            if (isArray(transformResponse)) {
              transformResponse = transformResponse.filter(function(transformer) {
                return transformer !== defaultHttpResponseTransform;
              });
            } else if (transformResponse === defaultHttpResponseTransform) {
              transformResponse = null;
            }
            var httpOptions = {
              cache: $templateCache,
              transformResponse: transformResponse
            };
            return $http.get(tpl, httpOptions)['finally'](function() {
              handleRequestFn.totalPendingRequests--;
            }).then(function(response) {
              $templateCache.put(tpl, response.data);
              return response.data;
            }, handleError);
            function handleError(resp) {
              if (!ignoreRequestError) {
                throw $compileMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
              }
              return $q.reject(resp);
            }
          }
          handleRequestFn.totalPendingRequests = 0;
          return handleRequestFn;
        }];
      }
      function $$TestabilityProvider() {
        this.$get = ['$rootScope', '$browser', '$location', function($rootScope, $browser, $location) {
          var testability = {};
          testability.findBindings = function(element, expression, opt_exactMatch) {
            var bindings = element.getElementsByClassName('ng-binding');
            var matches = [];
            forEach(bindings, function(binding) {
              var dataBinding = angular.element(binding).data('$binding');
              if (dataBinding) {
                forEach(dataBinding, function(bindingName) {
                  if (opt_exactMatch) {
                    var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                    if (matcher.test(bindingName)) {
                      matches.push(binding);
                    }
                  } else {
                    if (bindingName.indexOf(expression) != -1) {
                      matches.push(binding);
                    }
                  }
                });
              }
            });
            return matches;
          };
          testability.findModels = function(element, expression, opt_exactMatch) {
            var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
            for (var p = 0; p < prefixes.length; ++p) {
              var attributeEquals = opt_exactMatch ? '=' : '*=';
              var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
              var elements = element.querySelectorAll(selector);
              if (elements.length) {
                return elements;
              }
            }
          };
          testability.getLocation = function() {
            return $location.url();
          };
          testability.setLocation = function(url) {
            if (url !== $location.url()) {
              $location.url(url);
              $rootScope.$digest();
            }
          };
          testability.whenStable = function(callback) {
            $browser.notifyWhenNoOutstandingRequests(callback);
          };
          return testability;
        }];
      }
      function $TimeoutProvider() {
        this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler', function($rootScope, $browser, $q, $$q, $exceptionHandler) {
          var deferreds = {};
          function timeout(fn, delay, invokeApply) {
            if (!isFunction(fn)) {
              invokeApply = delay;
              delay = fn;
              fn = noop;
            }
            var args = sliceArgs(arguments, 3),
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise,
                timeoutId;
            timeoutId = $browser.defer(function() {
              try {
                deferred.resolve(fn.apply(null, args));
              } catch (e) {
                deferred.reject(e);
                $exceptionHandler(e);
              } finally {
                delete deferreds[promise.$$timeoutId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            promise.$$timeoutId = timeoutId;
            deferreds[timeoutId] = deferred;
            return promise;
          }
          timeout.cancel = function(promise) {
            if (promise && promise.$$timeoutId in deferreds) {
              deferreds[promise.$$timeoutId].reject('canceled');
              delete deferreds[promise.$$timeoutId];
              return $browser.defer.cancel(promise.$$timeoutId);
            }
            return false;
          };
          return timeout;
        }];
      }
      var urlParsingNode = document.createElement("a");
      var originUrl = urlResolve(window.location.href);
      function urlResolve(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute('href', href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
        };
      }
      function urlIsSameOrigin(requestUrl) {
        var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
        return (parsed.protocol === originUrl.protocol && parsed.host === originUrl.host);
      }
      function $WindowProvider() {
        this.$get = valueFn(window);
      }
      function $$CookieReader($document) {
        var rawDocument = $document[0] || {};
        var lastCookies = {};
        var lastCookieString = '';
        function safeDecodeURIComponent(str) {
          try {
            return decodeURIComponent(str);
          } catch (e) {
            return str;
          }
        }
        return function() {
          var cookieArray,
              cookie,
              i,
              index,
              name;
          var currentCookieString = rawDocument.cookie || '';
          if (currentCookieString !== lastCookieString) {
            lastCookieString = currentCookieString;
            cookieArray = lastCookieString.split('; ');
            lastCookies = {};
            for (i = 0; i < cookieArray.length; i++) {
              cookie = cookieArray[i];
              index = cookie.indexOf('=');
              if (index > 0) {
                name = safeDecodeURIComponent(cookie.substring(0, index));
                if (lastCookies[name] === undefined) {
                  lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                }
              }
            }
          }
          return lastCookies;
        };
      }
      $$CookieReader.$inject = ['$document'];
      function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
      }
      $FilterProvider.$inject = ['$provide'];
      function $FilterProvider($provide) {
        var suffix = 'Filter';
        function register(name, factory) {
          if (isObject(name)) {
            var filters = {};
            forEach(name, function(filter, key) {
              filters[key] = register(key, filter);
            });
            return filters;
          } else {
            return $provide.factory(name + suffix, factory);
          }
        }
        this.register = register;
        this.$get = ['$injector', function($injector) {
          return function(name) {
            return $injector.get(name + suffix);
          };
        }];
        register('currency', currencyFilter);
        register('date', dateFilter);
        register('filter', filterFilter);
        register('json', jsonFilter);
        register('limitTo', limitToFilter);
        register('lowercase', lowercaseFilter);
        register('number', numberFilter);
        register('orderBy', orderByFilter);
        register('uppercase', uppercaseFilter);
      }
      function filterFilter() {
        return function(array, expression, comparator) {
          if (!isArrayLike(array)) {
            if (array == null) {
              return array;
            } else {
              throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
            }
          }
          var expressionType = getTypeForFilter(expression);
          var predicateFn;
          var matchAgainstAnyProp;
          switch (expressionType) {
            case 'function':
              predicateFn = expression;
              break;
            case 'boolean':
            case 'null':
            case 'number':
            case 'string':
              matchAgainstAnyProp = true;
            case 'object':
              predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
              break;
            default:
              return array;
          }
          return Array.prototype.filter.call(array, predicateFn);
        };
      }
      function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && ('$' in expression);
        var predicateFn;
        if (comparator === true) {
          comparator = equals;
        } else if (!isFunction(comparator)) {
          comparator = function(actual, expected) {
            if (isUndefined(actual)) {
              return false;
            }
            if ((actual === null) || (expected === null)) {
              return actual === expected;
            }
            if (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) {
              return false;
            }
            actual = lowercase('' + actual);
            expected = lowercase('' + expected);
            return actual.indexOf(expected) !== -1;
          };
        }
        predicateFn = function(item) {
          if (shouldMatchPrimitives && !isObject(item)) {
            return deepCompare(item, expression.$, comparator, false);
          }
          return deepCompare(item, expression, comparator, matchAgainstAnyProp);
        };
        return predicateFn;
      }
      function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual);
        var expectedType = getTypeForFilter(expected);
        if ((expectedType === 'string') && (expected.charAt(0) === '!')) {
          return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        } else if (isArray(actual)) {
          return actual.some(function(item) {
            return deepCompare(item, expected, comparator, matchAgainstAnyProp);
          });
        }
        switch (actualType) {
          case 'object':
            var key;
            if (matchAgainstAnyProp) {
              for (key in actual) {
                if ((key.charAt(0) !== '$') && deepCompare(actual[key], expected, comparator, true)) {
                  return true;
                }
              }
              return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
            } else if (expectedType === 'object') {
              for (key in expected) {
                var expectedVal = expected[key];
                if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                  continue;
                }
                var matchAnyProperty = key === '$';
                var actualVal = matchAnyProperty ? actual : actual[key];
                if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                  return false;
                }
              }
              return true;
            } else {
              return comparator(actual, expected);
            }
            break;
          case 'function':
            return false;
          default:
            return comparator(actual, expected);
        }
      }
      function getTypeForFilter(val) {
        return (val === null) ? 'null' : typeof val;
      }
      currencyFilter.$inject = ['$locale'];
      function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
          if (isUndefined(currencySymbol)) {
            currencySymbol = formats.CURRENCY_SYM;
          }
          if (isUndefined(fractionSize)) {
            fractionSize = formats.PATTERNS[1].maxFrac;
          }
          return (amount == null) ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
      }
      numberFilter.$inject = ['$locale'];
      function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
          return (number == null) ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
      }
      var DECIMAL_SEP = '.';
      function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (isObject(number))
          return '';
        var isNegative = number < 0;
        number = Math.abs(number);
        var isInfinity = number === Infinity;
        if (!isInfinity && !isFinite(number))
          return '';
        var numStr = number + '',
            formatedText = '',
            hasExponent = false,
            parts = [];
        if (isInfinity)
          formatedText = '\u221e';
        if (!isInfinity && numStr.indexOf('e') !== -1) {
          var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
          if (match && match[2] == '-' && match[3] > fractionSize + 1) {
            number = 0;
          } else {
            formatedText = numStr;
            hasExponent = true;
          }
        }
        if (!isInfinity && !hasExponent) {
          var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;
          if (isUndefined(fractionSize)) {
            fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
          }
          number = +(Math.round(+(number.toString() + 'e' + fractionSize)).toString() + 'e' + -fractionSize);
          var fraction = ('' + number).split(DECIMAL_SEP);
          var whole = fraction[0];
          fraction = fraction[1] || '';
          var i,
              pos = 0,
              lgroup = pattern.lgSize,
              group = pattern.gSize;
          if (whole.length >= (lgroup + group)) {
            pos = whole.length - lgroup;
            for (i = 0; i < pos; i++) {
              if ((pos - i) % group === 0 && i !== 0) {
                formatedText += groupSep;
              }
              formatedText += whole.charAt(i);
            }
          }
          for (i = pos; i < whole.length; i++) {
            if ((whole.length - i) % lgroup === 0 && i !== 0) {
              formatedText += groupSep;
            }
            formatedText += whole.charAt(i);
          }
          while (fraction.length < fractionSize) {
            fraction += '0';
          }
          if (fractionSize && fractionSize !== "0")
            formatedText += decimalSep + fraction.substr(0, fractionSize);
        } else {
          if (fractionSize > 0 && number < 1) {
            formatedText = number.toFixed(fractionSize);
            number = parseFloat(formatedText);
          }
        }
        if (number === 0) {
          isNegative = false;
        }
        parts.push(isNegative ? pattern.negPre : pattern.posPre, formatedText, isNegative ? pattern.negSuf : pattern.posSuf);
        return parts.join('');
      }
      function padNumber(num, digits, trim) {
        var neg = '';
        if (num < 0) {
          neg = '-';
          num = -num;
        }
        num = '' + num;
        while (num.length < digits)
          num = '0' + num;
        if (trim) {
          num = num.substr(num.length - digits);
        }
        return neg + num;
      }
      function dateGetter(name, size, offset, trim) {
        offset = offset || 0;
        return function(date) {
          var value = date['get' + name]();
          if (offset > 0 || value > -offset) {
            value += offset;
          }
          if (value === 0 && offset == -12)
            value = 12;
          return padNumber(value, size, trim);
        };
      }
      function dateStrGetter(name, shortForm) {
        return function(date, formats) {
          var value = date['get' + name]();
          var get = uppercase(shortForm ? ('SHORT' + name) : name);
          return formats[get][value];
        };
      }
      function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset;
        var paddedZone = (zone >= 0) ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
      }
      function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
        return new Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
      }
      function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
      }
      function weekGetter(size) {
        return function(date) {
          var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
              thisThurs = getThursdayThisWeek(date);
          var diff = +thisThurs - +firstThurs,
              result = 1 + Math.round(diff / 6.048e8);
          return padNumber(result, size);
        };
      }
      function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
      }
      function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
      }
      function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
      }
      var DATE_FORMATS = {
        yyyy: dateGetter('FullYear', 4),
        yy: dateGetter('FullYear', 2, 0, true),
        y: dateGetter('FullYear', 1),
        MMMM: dateStrGetter('Month'),
        MMM: dateStrGetter('Month', true),
        MM: dateGetter('Month', 2, 1),
        M: dateGetter('Month', 1, 1),
        dd: dateGetter('Date', 2),
        d: dateGetter('Date', 1),
        HH: dateGetter('Hours', 2),
        H: dateGetter('Hours', 1),
        hh: dateGetter('Hours', 2, -12),
        h: dateGetter('Hours', 1, -12),
        mm: dateGetter('Minutes', 2),
        m: dateGetter('Minutes', 1),
        ss: dateGetter('Seconds', 2),
        s: dateGetter('Seconds', 1),
        sss: dateGetter('Milliseconds', 3),
        EEEE: dateStrGetter('Day'),
        EEE: dateStrGetter('Day', true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
      };
      var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
          NUMBER_STRING = /^\-?\d+$/;
      dateFilter.$inject = ['$locale'];
      function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
          var match;
          if (match = string.match(R_ISO8601_STR)) {
            var date = new Date(0),
                tzHour = 0,
                tzMin = 0,
                dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                timeSetter = match[8] ? date.setUTCHours : date.setHours;
            if (match[9]) {
              tzHour = toInt(match[9] + match[10]);
              tzMin = toInt(match[9] + match[11]);
            }
            dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
            var h = toInt(match[4] || 0) - tzHour;
            var m = toInt(match[5] || 0) - tzMin;
            var s = toInt(match[6] || 0);
            var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
            timeSetter.call(date, h, m, s, ms);
            return date;
          }
          return string;
        }
        return function(date, format, timezone) {
          var text = '',
              parts = [],
              fn,
              match;
          format = format || 'mediumDate';
          format = $locale.DATETIME_FORMATS[format] || format;
          if (isString(date)) {
            date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
          }
          if (isNumber(date)) {
            date = new Date(date);
          }
          if (!isDate(date) || !isFinite(date.getTime())) {
            return date;
          }
          while (format) {
            match = DATE_FORMATS_SPLIT.exec(format);
            if (match) {
              parts = concat(parts, match, 1);
              format = parts.pop();
            } else {
              parts.push(format);
              format = null;
            }
          }
          var dateTimezoneOffset = date.getTimezoneOffset();
          if (timezone) {
            dateTimezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
            date = convertTimezoneToLocal(date, timezone, true);
          }
          forEach(parts, function(value) {
            fn = DATE_FORMATS[value];
            text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
          });
          return text;
        };
      }
      function jsonFilter() {
        return function(object, spacing) {
          if (isUndefined(spacing)) {
            spacing = 2;
          }
          return toJson(object, spacing);
        };
      }
      var lowercaseFilter = valueFn(lowercase);
      var uppercaseFilter = valueFn(uppercase);
      function limitToFilter() {
        return function(input, limit, begin) {
          if (Math.abs(Number(limit)) === Infinity) {
            limit = Number(limit);
          } else {
            limit = toInt(limit);
          }
          if (isNaN(limit))
            return input;
          if (isNumber(input))
            input = input.toString();
          if (!isArray(input) && !isString(input))
            return input;
          begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
          begin = (begin < 0 && begin >= -input.length) ? input.length + begin : begin;
          if (limit >= 0) {
            return input.slice(begin, begin + limit);
          } else {
            if (begin === 0) {
              return input.slice(limit, input.length);
            } else {
              return input.slice(Math.max(0, begin + limit), begin);
            }
          }
        };
      }
      orderByFilter.$inject = ['$parse'];
      function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder) {
          if (!(isArrayLike(array)))
            return array;
          if (!isArray(sortPredicate)) {
            sortPredicate = [sortPredicate];
          }
          if (sortPredicate.length === 0) {
            sortPredicate = ['+'];
          }
          var predicates = processPredicates(sortPredicate, reverseOrder);
          predicates.push({
            get: function() {
              return {};
            },
            descending: reverseOrder ? -1 : 1
          });
          var compareValues = Array.prototype.map.call(array, getComparisonObject);
          compareValues.sort(doComparison);
          array = compareValues.map(function(item) {
            return item.value;
          });
          return array;
          function getComparisonObject(value, index) {
            return {
              value: value,
              predicateValues: predicates.map(function(predicate) {
                return getPredicateValue(predicate.get(value), index);
              })
            };
          }
          function doComparison(v1, v2) {
            var result = 0;
            for (var index = 0,
                length = predicates.length; index < length; ++index) {
              result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].descending;
              if (result)
                break;
            }
            return result;
          }
        };
        function processPredicates(sortPredicate, reverseOrder) {
          reverseOrder = reverseOrder ? -1 : 1;
          return sortPredicate.map(function(predicate) {
            var descending = 1,
                get = identity;
            if (isFunction(predicate)) {
              get = predicate;
            } else if (isString(predicate)) {
              if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
                descending = predicate.charAt(0) == '-' ? -1 : 1;
                predicate = predicate.substring(1);
              }
              if (predicate !== '') {
                get = $parse(predicate);
                if (get.constant) {
                  var key = get();
                  get = function(value) {
                    return value[key];
                  };
                }
              }
            }
            return {
              get: get,
              descending: descending * reverseOrder
            };
          });
        }
        function isPrimitive(value) {
          switch (typeof value) {
            case 'number':
            case 'boolean':
            case 'string':
              return true;
            default:
              return false;
          }
        }
        function objectValue(value, index) {
          if (typeof value.valueOf === 'function') {
            value = value.valueOf();
            if (isPrimitive(value))
              return value;
          }
          if (hasCustomToString(value)) {
            value = value.toString();
            if (isPrimitive(value))
              return value;
          }
          return index;
        }
        function getPredicateValue(value, index) {
          var type = typeof value;
          if (value === null) {
            type = 'string';
            value = 'null';
          } else if (type === 'string') {
            value = value.toLowerCase();
          } else if (type === 'object') {
            value = objectValue(value, index);
          }
          return {
            value: value,
            type: type
          };
        }
        function compare(v1, v2) {
          var result = 0;
          if (v1.type === v2.type) {
            if (v1.value !== v2.value) {
              result = v1.value < v2.value ? -1 : 1;
            }
          } else {
            result = v1.type < v2.type ? -1 : 1;
          }
          return result;
        }
      }
      function ngDirective(directive) {
        if (isFunction(directive)) {
          directive = {link: directive};
        }
        directive.restrict = directive.restrict || 'AC';
        return valueFn(directive);
      }
      var htmlAnchorDirective = valueFn({
        restrict: 'E',
        compile: function(element, attr) {
          if (!attr.href && !attr.xlinkHref) {
            return function(scope, element) {
              if (element[0].nodeName.toLowerCase() !== 'a')
                return ;
              var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
              element.on('click', function(event) {
                if (!element.attr(href)) {
                  event.preventDefault();
                }
              });
            };
          }
        }
      });
      var ngAttributeAliasDirectives = {};
      forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName == "multiple")
          return ;
        function defaultLinkFn(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        }
        var normalized = directiveNormalize('ng-' + attrName);
        var linkFn = defaultLinkFn;
        if (propName === 'checked') {
          linkFn = function(scope, element, attr) {
            if (attr.ngModel !== attr[normalized]) {
              defaultLinkFn(scope, element, attr);
            }
          };
        }
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            restrict: 'A',
            priority: 100,
            link: linkFn
          };
        };
      });
      forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
          return {
            priority: 100,
            link: function(scope, element, attr) {
              if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
                var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                if (match) {
                  attr.$set("ngPattern", new RegExp(match[1], match[2]));
                  return ;
                }
              }
              scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                attr.$set(ngAttr, value);
              });
            }
          };
        };
      });
      forEach(['src', 'srcset', 'href'], function(attrName) {
        var normalized = directiveNormalize('ng-' + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            priority: 99,
            link: function(scope, element, attr) {
              var propName = attrName,
                  name = attrName;
              if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
                name = 'xlinkHref';
                attr.$attr[name] = 'xlink:href';
                propName = null;
              }
              attr.$observe(normalized, function(value) {
                if (!value) {
                  if (attrName === 'href') {
                    attr.$set(name, null);
                  }
                  return ;
                }
                attr.$set(name, value);
                if (msie && propName)
                  element.prop(propName, attr[name]);
              });
            }
          };
        };
      });
      var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
      },
          SUBMITTED_CLASS = 'ng-submitted';
      function nullFormRenameControl(control, name) {
        control.$name = name;
      }
      FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];
      function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this,
            controls = [];
        var parentForm = form.$$parentForm = element.parent().controller('form') || nullFormCtrl;
        form.$error = {};
        form.$$success = {};
        form.$pending = undefined;
        form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        form.$submitted = false;
        parentForm.$addControl(form);
        form.$rollbackViewValue = function() {
          forEach(controls, function(control) {
            control.$rollbackViewValue();
          });
        };
        form.$commitViewValue = function() {
          forEach(controls, function(control) {
            control.$commitViewValue();
          });
        };
        form.$addControl = function(control) {
          assertNotHasOwnProperty(control.$name, 'input');
          controls.push(control);
          if (control.$name) {
            form[control.$name] = control;
          }
        };
        form.$$renameControl = function(control, newName) {
          var oldName = control.$name;
          if (form[oldName] === control) {
            delete form[oldName];
          }
          form[newName] = control;
          control.$name = newName;
        };
        form.$removeControl = function(control) {
          if (control.$name && form[control.$name] === control) {
            delete form[control.$name];
          }
          forEach(form.$pending, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$error, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$$success, function(value, name) {
            form.$setValidity(name, null, control);
          });
          arrayRemove(controls, control);
        };
        addSetValidityMethod({
          ctrl: this,
          $element: element,
          set: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              object[property] = [controller];
            } else {
              var index = list.indexOf(controller);
              if (index === -1) {
                list.push(controller);
              }
            }
          },
          unset: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              return ;
            }
            arrayRemove(list, controller);
            if (list.length === 0) {
              delete object[property];
            }
          },
          parentForm: parentForm,
          $animate: $animate
        });
        form.$setDirty = function() {
          $animate.removeClass(element, PRISTINE_CLASS);
          $animate.addClass(element, DIRTY_CLASS);
          form.$dirty = true;
          form.$pristine = false;
          parentForm.$setDirty();
        };
        form.$setPristine = function() {
          $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
          form.$dirty = false;
          form.$pristine = true;
          form.$submitted = false;
          forEach(controls, function(control) {
            control.$setPristine();
          });
        };
        form.$setUntouched = function() {
          forEach(controls, function(control) {
            control.$setUntouched();
          });
        };
        form.$setSubmitted = function() {
          $animate.addClass(element, SUBMITTED_CLASS);
          form.$submitted = true;
          parentForm.$setSubmitted();
        };
      }
      var formDirectiveFactory = function(isNgForm) {
        return ['$timeout', '$parse', function($timeout, $parse) {
          var formDirective = {
            name: 'form',
            restrict: isNgForm ? 'EAC' : 'E',
            controller: FormController,
            compile: function ngFormCompile(formElement, attr) {
              formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
              var nameAttr = attr.name ? 'name' : (isNgForm && attr.ngForm ? 'ngForm' : false);
              return {pre: function ngFormPreLink(scope, formElement, attr, controller) {
                  if (!('action' in attr)) {
                    var handleFormSubmission = function(event) {
                      scope.$apply(function() {
                        controller.$commitViewValue();
                        controller.$setSubmitted();
                      });
                      event.preventDefault();
                    };
                    addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                    formElement.on('$destroy', function() {
                      $timeout(function() {
                        removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                      }, 0, false);
                    });
                  }
                  var parentFormCtrl = controller.$$parentForm;
                  var setter = nameAttr ? getSetter(controller.$name) : noop;
                  if (nameAttr) {
                    setter(scope, controller);
                    attr.$observe(nameAttr, function(newValue) {
                      if (controller.$name === newValue)
                        return ;
                      setter(scope, undefined);
                      parentFormCtrl.$$renameControl(controller, newValue);
                      setter = getSetter(controller.$name);
                      setter(scope, controller);
                    });
                  }
                  formElement.on('$destroy', function() {
                    parentFormCtrl.$removeControl(controller);
                    setter(scope, undefined);
                    extend(controller, nullFormCtrl);
                  });
                }};
            }
          };
          return formDirective;
          function getSetter(expression) {
            if (expression === '') {
              return $parse('this[""]').assign;
            }
            return $parse(expression).assign || noop;
          }
        }];
      };
      var formDirective = formDirectiveFactory();
      var ngFormDirective = formDirectiveFactory(true);
      var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
      var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
      var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
      var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
      var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;
      var DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;
      var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;
      var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var inputType = {
        'text': textInputType,
        'date': createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']), 'yyyy-MM-dd'),
        'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']), 'yyyy-MM-ddTHH:mm:ss.sss'),
        'time': createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']), 'HH:mm:ss.sss'),
        'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
        'month': createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, ['yyyy', 'MM']), 'yyyy-MM'),
        'number': numberInputType,
        'url': urlInputType,
        'email': emailInputType,
        'radio': radioInputType,
        'checkbox': checkboxInputType,
        'hidden': noop,
        'button': noop,
        'submit': noop,
        'reset': noop,
        'file': noop
      };
      function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
          return ctrl.$isEmpty(value) ? value : value.toString();
        });
      }
      function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
      }
      function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
          var composing = false;
          element.on('compositionstart', function(data) {
            composing = true;
          });
          element.on('compositionend', function() {
            composing = false;
            listener();
          });
        }
        var listener = function(ev) {
          if (timeout) {
            $browser.defer.cancel(timeout);
            timeout = null;
          }
          if (composing)
            return ;
          var value = element.val(),
              event = ev && ev.type;
          if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
            value = trim(value);
          }
          if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
            ctrl.$setViewValue(value, event);
          }
        };
        if ($sniffer.hasEvent('input')) {
          element.on('input', listener);
        } else {
          var timeout;
          var deferListener = function(ev, input, origValue) {
            if (!timeout) {
              timeout = $browser.defer(function() {
                timeout = null;
                if (!input || input.value !== origValue) {
                  listener(ev);
                }
              });
            }
          };
          element.on('keydown', function(event) {
            var key = event.keyCode;
            if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40))
              return ;
            deferListener(event, this, this.value);
          });
          if ($sniffer.hasEvent('paste')) {
            element.on('paste cut', deferListener);
          }
        }
        element.on('change', listener);
        ctrl.$render = function() {
          var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
          if (element.val() !== value) {
            element.val(value);
          }
        };
      }
      function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
          return isoWeek;
        }
        if (isString(isoWeek)) {
          WEEK_REGEXP.lastIndex = 0;
          var parts = WEEK_REGEXP.exec(isoWeek);
          if (parts) {
            var year = +parts[1],
                week = +parts[2],
                hours = 0,
                minutes = 0,
                seconds = 0,
                milliseconds = 0,
                firstThurs = getFirstThursdayOfYear(year),
                addDays = (week - 1) * 7;
            if (existingDate) {
              hours = existingDate.getHours();
              minutes = existingDate.getMinutes();
              seconds = existingDate.getSeconds();
              milliseconds = existingDate.getMilliseconds();
            }
            return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
          }
        }
        return NaN;
      }
      function createDateParser(regexp, mapping) {
        return function(iso, date) {
          var parts,
              map;
          if (isDate(iso)) {
            return iso;
          }
          if (isString(iso)) {
            if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
              iso = iso.substring(1, iso.length - 1);
            }
            if (ISO_DATE_REGEXP.test(iso)) {
              return new Date(iso);
            }
            regexp.lastIndex = 0;
            parts = regexp.exec(iso);
            if (parts) {
              parts.shift();
              if (date) {
                map = {
                  yyyy: date.getFullYear(),
                  MM: date.getMonth() + 1,
                  dd: date.getDate(),
                  HH: date.getHours(),
                  mm: date.getMinutes(),
                  ss: date.getSeconds(),
                  sss: date.getMilliseconds() / 1000
                };
              } else {
                map = {
                  yyyy: 1970,
                  MM: 1,
                  dd: 1,
                  HH: 0,
                  mm: 0,
                  ss: 0,
                  sss: 0
                };
              }
              forEach(parts, function(part, index) {
                if (index < mapping.length) {
                  map[mapping[index]] = +part;
                }
              });
              return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
            }
          }
          return NaN;
        };
      }
      function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
          badInputChecker(scope, element, attr, ctrl);
          baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
          var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
          var previousDate;
          ctrl.$$parserName = type;
          ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value))
              return null;
            if (regexp.test(value)) {
              var parsedDate = parseDate(value, previousDate);
              if (timezone) {
                parsedDate = convertTimezoneToLocal(parsedDate, timezone);
              }
              return parsedDate;
            }
            return undefined;
          });
          ctrl.$formatters.push(function(value) {
            if (value && !isDate(value)) {
              throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
            }
            if (isValidDate(value)) {
              previousDate = value;
              if (previousDate && timezone) {
                previousDate = convertTimezoneToLocal(previousDate, timezone, true);
              }
              return $filter('date')(value, format, timezone);
            } else {
              previousDate = null;
              return '';
            }
          });
          if (isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
              return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
            };
            attr.$observe('min', function(val) {
              minVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
              return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
            };
            attr.$observe('max', function(val) {
              maxVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          function isValidDate(value) {
            return value && !(value.getTime && value.getTime() !== value.getTime());
          }
          function parseObservedDateValue(val) {
            return isDefined(val) ? (isDate(val) ? val : parseDate(val)) : undefined;
          }
        };
      }
      function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
          ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput && !validity.typeMismatch ? undefined : value;
          });
        }
      }
      function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        ctrl.$$parserName = 'number';
        ctrl.$parsers.push(function(value) {
          if (ctrl.$isEmpty(value))
            return null;
          if (NUMBER_REGEXP.test(value))
            return parseFloat(value);
          return undefined;
        });
        ctrl.$formatters.push(function(value) {
          if (!ctrl.$isEmpty(value)) {
            if (!isNumber(value)) {
              throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
            }
            value = value.toString();
          }
          return value;
        });
        if (isDefined(attr.min) || attr.ngMin) {
          var minVal;
          ctrl.$validators.min = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
          };
          attr.$observe('min', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            minVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
        if (isDefined(attr.max) || attr.ngMax) {
          var maxVal;
          ctrl.$validators.max = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
          };
          attr.$observe('max', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
      }
      function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'url';
        ctrl.$validators.url = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
      }
      function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'email';
        ctrl.$validators.email = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
      }
      function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
          element.attr('name', nextUid());
        }
        var listener = function(ev) {
          if (element[0].checked) {
            ctrl.$setViewValue(attr.value, ev && ev.type);
          }
        };
        element.on('click', listener);
        ctrl.$render = function() {
          var value = attr.value;
          element[0].checked = (value == ctrl.$viewValue);
        };
        attr.$observe('value', ctrl.$render);
      }
      function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
          parseFn = $parse(expression);
          if (!parseFn.constant) {
            throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
          }
          return parseFn(context);
        }
        return fallback;
      }
      function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
        var listener = function(ev) {
          ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on('click', listener);
        ctrl.$render = function() {
          element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
          return value === false;
        };
        ctrl.$formatters.push(function(value) {
          return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
          return value ? trueValue : falseValue;
        });
      }
      var inputDirective = ['$browser', '$sniffer', '$filter', '$parse', function($browser, $sniffer, $filter, $parse) {
        return {
          restrict: 'E',
          require: ['?ngModel'],
          link: {pre: function(scope, element, attr, ctrls) {
              if (ctrls[0]) {
                (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
              }
            }}
        };
      }];
      var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
      var ngValueDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          compile: function(tpl, tplAttr) {
            if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
              return function ngValueConstantLink(scope, elm, attr) {
                attr.$set('value', scope.$eval(attr.ngValue));
              };
            } else {
              return function ngValueLink(scope, elm, attr) {
                scope.$watch(attr.ngValue, function valueWatchAction(value) {
                  attr.$set('value', value);
                });
              };
            }
          }
        };
      };
      var ngBindDirective = ['$compile', function($compile) {
        return {
          restrict: 'AC',
          compile: function ngBindCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBind);
              element = element[0];
              scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                element.textContent = value === undefined ? '' : value;
              });
            };
          }
        };
      }];
      var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate, $compile) {
        return {compile: function ngBindTemplateCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindTemplateLink(scope, element, attr) {
              var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
              $compile.$$addBindingInfo(element, interpolateFn.expressions);
              element = element[0];
              attr.$observe('ngBindTemplate', function(value) {
                element.textContent = value === undefined ? '' : value;
              });
            };
          }};
      }];
      var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
        return {
          restrict: 'A',
          compile: function ngBindHtmlCompile(tElement, tAttrs) {
            var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
            var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
              return (value || '').toString();
            });
            $compile.$$addBindingClass(tElement);
            return function ngBindHtmlLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBindHtml);
              scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || '');
              });
            };
          }
        };
      }];
      var ngChangeDirective = valueFn({
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attr, ctrl) {
          ctrl.$viewChangeListeners.push(function() {
            scope.$eval(attr.ngChange);
          });
        }
      });
      function classDirective(name, selector) {
        name = 'ngClass' + name;
        return ['$animate', function($animate) {
          return {
            restrict: 'AC',
            link: function(scope, element, attr) {
              var oldVal;
              scope.$watch(attr[name], ngClassWatchAction, true);
              attr.$observe('class', function(value) {
                ngClassWatchAction(scope.$eval(attr[name]));
              });
              if (name !== 'ngClass') {
                scope.$watch('$index', function($index, old$index) {
                  var mod = $index & 1;
                  if (mod !== (old$index & 1)) {
                    var classes = arrayClasses(scope.$eval(attr[name]));
                    mod === selector ? addClasses(classes) : removeClasses(classes);
                  }
                });
              }
              function addClasses(classes) {
                var newClasses = digestClassCounts(classes, 1);
                attr.$addClass(newClasses);
              }
              function removeClasses(classes) {
                var newClasses = digestClassCounts(classes, -1);
                attr.$removeClass(newClasses);
              }
              function digestClassCounts(classes, count) {
                var classCounts = element.data('$classCounts') || createMap();
                var classesToUpdate = [];
                forEach(classes, function(className) {
                  if (count > 0 || classCounts[className]) {
                    classCounts[className] = (classCounts[className] || 0) + count;
                    if (classCounts[className] === +(count > 0)) {
                      classesToUpdate.push(className);
                    }
                  }
                });
                element.data('$classCounts', classCounts);
                return classesToUpdate.join(' ');
              }
              function updateClasses(oldClasses, newClasses) {
                var toAdd = arrayDifference(newClasses, oldClasses);
                var toRemove = arrayDifference(oldClasses, newClasses);
                toAdd = digestClassCounts(toAdd, 1);
                toRemove = digestClassCounts(toRemove, -1);
                if (toAdd && toAdd.length) {
                  $animate.addClass(element, toAdd);
                }
                if (toRemove && toRemove.length) {
                  $animate.removeClass(element, toRemove);
                }
              }
              function ngClassWatchAction(newVal) {
                if (selector === true || scope.$index % 2 === selector) {
                  var newClasses = arrayClasses(newVal || []);
                  if (!oldVal) {
                    addClasses(newClasses);
                  } else if (!equals(newVal, oldVal)) {
                    var oldClasses = arrayClasses(oldVal);
                    updateClasses(oldClasses, newClasses);
                  }
                }
                oldVal = shallowCopy(newVal);
              }
            }
          };
          function arrayDifference(tokens1, tokens2) {
            var values = [];
            outer: for (var i = 0; i < tokens1.length; i++) {
              var token = tokens1[i];
              for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j])
                  continue outer;
              }
              values.push(token);
            }
            return values;
          }
          function arrayClasses(classVal) {
            var classes = [];
            if (isArray(classVal)) {
              forEach(classVal, function(v) {
                classes = classes.concat(arrayClasses(v));
              });
              return classes;
            } else if (isString(classVal)) {
              return classVal.split(' ');
            } else if (isObject(classVal)) {
              forEach(classVal, function(v, k) {
                if (v) {
                  classes = classes.concat(k.split(' '));
                }
              });
              return classes;
            }
            return classVal;
          }
        }];
      }
      var ngClassDirective = classDirective('', true);
      var ngClassOddDirective = classDirective('Odd', 0);
      var ngClassEvenDirective = classDirective('Even', 1);
      var ngCloakDirective = ngDirective({compile: function(element, attr) {
          attr.$set('ngCloak', undefined);
          element.removeClass('ng-cloak');
        }});
      var ngControllerDirective = [function() {
        return {
          restrict: 'A',
          scope: true,
          controller: '@',
          priority: 500
        };
      }];
      var ngEventDirectives = {};
      var forceAsyncEvents = {
        'blur': true,
        'focus': true
      };
      forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function(eventName) {
        var directiveName = directiveNormalize('ng-' + eventName);
        ngEventDirectives[directiveName] = ['$parse', '$rootScope', function($parse, $rootScope) {
          return {
            restrict: 'A',
            compile: function($element, attr) {
              var fn = $parse(attr[directiveName], null, true);
              return function ngEventHandler(scope, element) {
                element.on(eventName, function(event) {
                  var callback = function() {
                    fn(scope, {$event: event});
                  };
                  if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                  } else {
                    scope.$apply(callback);
                  }
                });
              };
            }
          };
        }];
      });
      var ngIfDirective = ['$animate', function($animate) {
        return {
          multiElement: true,
          transclude: 'element',
          priority: 600,
          terminal: true,
          restrict: 'A',
          $$tlb: true,
          link: function($scope, $element, $attr, ctrl, $transclude) {
            var block,
                childScope,
                previousElements;
            $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
              if (value) {
                if (!childScope) {
                  $transclude(function(clone, newScope) {
                    childScope = newScope;
                    clone[clone.length++] = document.createComment(' end ngIf: ' + $attr.ngIf + ' ');
                    block = {clone: clone};
                    $animate.enter(clone, $element.parent(), $element);
                  });
                }
              } else {
                if (previousElements) {
                  previousElements.remove();
                  previousElements = null;
                }
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                if (block) {
                  previousElements = getBlockNodes(block.clone);
                  $animate.leave(previousElements).then(function() {
                    previousElements = null;
                  });
                  block = null;
                }
              }
            });
          }
        };
      }];
      var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate', function($templateRequest, $anchorScroll, $animate) {
        return {
          restrict: 'ECA',
          priority: 400,
          terminal: true,
          transclude: 'element',
          controller: angular.noop,
          compile: function(element, attr) {
            var srcExp = attr.ngInclude || attr.src,
                onloadExp = attr.onload || '',
                autoScrollExp = attr.autoscroll;
            return function(scope, $element, $attr, ctrl, $transclude) {
              var changeCounter = 0,
                  currentScope,
                  previousElement,
                  currentElement;
              var cleanupLastIncludeContent = function() {
                if (previousElement) {
                  previousElement.remove();
                  previousElement = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentElement) {
                  $animate.leave(currentElement).then(function() {
                    previousElement = null;
                  });
                  previousElement = currentElement;
                  currentElement = null;
                }
              };
              scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                var afterAnimation = function() {
                  if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                    $anchorScroll();
                  }
                };
                var thisChangeId = ++changeCounter;
                if (src) {
                  $templateRequest(src, true).then(function(response) {
                    if (thisChangeId !== changeCounter)
                      return ;
                    var newScope = scope.$new();
                    ctrl.template = response;
                    var clone = $transclude(newScope, function(clone) {
                      cleanupLastIncludeContent();
                      $animate.enter(clone, null, $element).then(afterAnimation);
                    });
                    currentScope = newScope;
                    currentElement = clone;
                    currentScope.$emit('$includeContentLoaded', src);
                    scope.$eval(onloadExp);
                  }, function() {
                    if (thisChangeId === changeCounter) {
                      cleanupLastIncludeContent();
                      scope.$emit('$includeContentError', src);
                    }
                  });
                  scope.$emit('$includeContentRequested', src);
                } else {
                  cleanupLastIncludeContent();
                  ctrl.template = null;
                }
              });
            };
          }
        };
      }];
      var ngIncludeFillContentDirective = ['$compile', function($compile) {
        return {
          restrict: 'ECA',
          priority: -400,
          require: 'ngInclude',
          link: function(scope, $element, $attr, ctrl) {
            if (/SVG/.test($element[0].toString())) {
              $element.empty();
              $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                $element.append(clone);
              }, {futureParentElement: $element});
              return ;
            }
            $element.html(ctrl.template);
            $compile($element.contents())(scope);
          }
        };
      }];
      var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
          return {pre: function(scope, element, attrs) {
              scope.$eval(attrs.ngInit);
            }};
        }
      });
      var ngListDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          require: 'ngModel',
          link: function(scope, element, attr, ctrl) {
            var ngList = element.attr(attr.$attr.ngList) || ', ';
            var trimValues = attr.ngTrim !== 'false';
            var separator = trimValues ? trim(ngList) : ngList;
            var parse = function(viewValue) {
              if (isUndefined(viewValue))
                return ;
              var list = [];
              if (viewValue) {
                forEach(viewValue.split(separator), function(value) {
                  if (value)
                    list.push(trimValues ? trim(value) : value);
                });
              }
              return list;
            };
            ctrl.$parsers.push(parse);
            ctrl.$formatters.push(function(value) {
              if (isArray(value)) {
                return value.join(ngList);
              }
              return undefined;
            });
            ctrl.$isEmpty = function(value) {
              return !value || !value.length;
            };
          }
        };
      };
      var VALID_CLASS = 'ng-valid',
          INVALID_CLASS = 'ng-invalid',
          PRISTINE_CLASS = 'ng-pristine',
          DIRTY_CLASS = 'ng-dirty',
          UNTOUCHED_CLASS = 'ng-untouched',
          TOUCHED_CLASS = 'ng-touched',
          PENDING_CLASS = 'ng-pending';
      var ngModelMinErr = minErr('ngModel');
      var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate', function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || '', false)($scope);
        var parsedNgModel = $parse($attr.ngModel),
            parsedNgModelAssign = parsedNgModel.assign,
            ngModelGet = parsedNgModel,
            ngModelSet = parsedNgModelAssign,
            pendingDebounce = null,
            parserValid,
            ctrl = this;
        this.$$setOptions = function(options) {
          ctrl.$options = options;
          if (options && options.getterSetter) {
            var invokeModelGetter = $parse($attr.ngModel + '()'),
                invokeModelSetter = $parse($attr.ngModel + '($$$p)');
            ngModelGet = function($scope) {
              var modelValue = parsedNgModel($scope);
              if (isFunction(modelValue)) {
                modelValue = invokeModelGetter($scope);
              }
              return modelValue;
            };
            ngModelSet = function($scope, newValue) {
              if (isFunction(parsedNgModel($scope))) {
                invokeModelSetter($scope, {$$$p: ctrl.$modelValue});
              } else {
                parsedNgModelAssign($scope, ctrl.$modelValue);
              }
            };
          } else if (!parsedNgModel.assign) {
            throw ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
          }
        };
        this.$render = noop;
        this.$isEmpty = function(value) {
          return isUndefined(value) || value === '' || value === null || value !== value;
        };
        var parentForm = $element.inheritedData('$formController') || nullFormCtrl,
            currentValidationRunId = 0;
        addSetValidityMethod({
          ctrl: this,
          $element: $element,
          set: function(object, property) {
            object[property] = true;
          },
          unset: function(object, property) {
            delete object[property];
          },
          parentForm: parentForm,
          $animate: $animate
        });
        this.$setPristine = function() {
          ctrl.$dirty = false;
          ctrl.$pristine = true;
          $animate.removeClass($element, DIRTY_CLASS);
          $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setDirty = function() {
          ctrl.$dirty = true;
          ctrl.$pristine = false;
          $animate.removeClass($element, PRISTINE_CLASS);
          $animate.addClass($element, DIRTY_CLASS);
          parentForm.$setDirty();
        };
        this.$setUntouched = function() {
          ctrl.$touched = false;
          ctrl.$untouched = true;
          $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        };
        this.$setTouched = function() {
          ctrl.$touched = true;
          ctrl.$untouched = false;
          $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        };
        this.$rollbackViewValue = function() {
          $timeout.cancel(pendingDebounce);
          ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
          ctrl.$render();
        };
        this.$validate = function() {
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            return ;
          }
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = ctrl.$$rawModelValue;
          var prevValid = ctrl.$valid;
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
            if (!allowInvalid && prevValid !== allValid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              if (ctrl.$modelValue !== prevModelValue) {
                ctrl.$$writeModelToScope();
              }
            }
          });
        };
        this.$$runValidators = function(modelValue, viewValue, doneCallback) {
          currentValidationRunId++;
          var localValidationRunId = currentValidationRunId;
          if (!processParseErrors()) {
            validationDone(false);
            return ;
          }
          if (!processSyncValidators()) {
            validationDone(false);
            return ;
          }
          processAsyncValidators();
          function processParseErrors() {
            var errorKey = ctrl.$$parserName || 'parse';
            if (parserValid === undefined) {
              setValidity(errorKey, null);
            } else {
              if (!parserValid) {
                forEach(ctrl.$validators, function(v, name) {
                  setValidity(name, null);
                });
                forEach(ctrl.$asyncValidators, function(v, name) {
                  setValidity(name, null);
                });
              }
              setValidity(errorKey, parserValid);
              return parserValid;
            }
            return true;
          }
          function processSyncValidators() {
            var syncValidatorsValid = true;
            forEach(ctrl.$validators, function(validator, name) {
              var result = validator(modelValue, viewValue);
              syncValidatorsValid = syncValidatorsValid && result;
              setValidity(name, result);
            });
            if (!syncValidatorsValid) {
              forEach(ctrl.$asyncValidators, function(v, name) {
                setValidity(name, null);
              });
              return false;
            }
            return true;
          }
          function processAsyncValidators() {
            var validatorPromises = [];
            var allValid = true;
            forEach(ctrl.$asyncValidators, function(validator, name) {
              var promise = validator(modelValue, viewValue);
              if (!isPromiseLike(promise)) {
                throw ngModelMinErr("$asyncValidators", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
              }
              setValidity(name, undefined);
              validatorPromises.push(promise.then(function() {
                setValidity(name, true);
              }, function(error) {
                allValid = false;
                setValidity(name, false);
              }));
            });
            if (!validatorPromises.length) {
              validationDone(true);
            } else {
              $q.all(validatorPromises).then(function() {
                validationDone(allValid);
              }, noop);
            }
          }
          function setValidity(name, isValid) {
            if (localValidationRunId === currentValidationRunId) {
              ctrl.$setValidity(name, isValid);
            }
          }
          function validationDone(allValid) {
            if (localValidationRunId === currentValidationRunId) {
              doneCallback(allValid);
            }
          }
        };
        this.$commitViewValue = function() {
          var viewValue = ctrl.$viewValue;
          $timeout.cancel(pendingDebounce);
          if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
            return ;
          }
          ctrl.$$lastCommittedViewValue = viewValue;
          if (ctrl.$pristine) {
            this.$setDirty();
          }
          this.$$parseAndValidate();
        };
        this.$$parseAndValidate = function() {
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = viewValue;
          parserValid = isUndefined(modelValue) ? undefined : true;
          if (parserValid) {
            for (var i = 0; i < ctrl.$parsers.length; i++) {
              modelValue = ctrl.$parsers[i](modelValue);
              if (isUndefined(modelValue)) {
                parserValid = false;
                break;
              }
            }
          }
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            ctrl.$modelValue = ngModelGet($scope);
          }
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$rawModelValue = modelValue;
          if (allowInvalid) {
            ctrl.$modelValue = modelValue;
            writeToModelIfNeeded();
          }
          ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
            if (!allowInvalid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              writeToModelIfNeeded();
            }
          });
          function writeToModelIfNeeded() {
            if (ctrl.$modelValue !== prevModelValue) {
              ctrl.$$writeModelToScope();
            }
          }
        };
        this.$$writeModelToScope = function() {
          ngModelSet($scope, ctrl.$modelValue);
          forEach(ctrl.$viewChangeListeners, function(listener) {
            try {
              listener();
            } catch (e) {
              $exceptionHandler(e);
            }
          });
        };
        this.$setViewValue = function(value, trigger) {
          ctrl.$viewValue = value;
          if (!ctrl.$options || ctrl.$options.updateOnDefault) {
            ctrl.$$debounceViewValueCommit(trigger);
          }
        };
        this.$$debounceViewValueCommit = function(trigger) {
          var debounceDelay = 0,
              options = ctrl.$options,
              debounce;
          if (options && isDefined(options.debounce)) {
            debounce = options.debounce;
            if (isNumber(debounce)) {
              debounceDelay = debounce;
            } else if (isNumber(debounce[trigger])) {
              debounceDelay = debounce[trigger];
            } else if (isNumber(debounce['default'])) {
              debounceDelay = debounce['default'];
            }
          }
          $timeout.cancel(pendingDebounce);
          if (debounceDelay) {
            pendingDebounce = $timeout(function() {
              ctrl.$commitViewValue();
            }, debounceDelay);
          } else if ($rootScope.$$phase) {
            ctrl.$commitViewValue();
          } else {
            $scope.$apply(function() {
              ctrl.$commitViewValue();
            });
          }
        };
        $scope.$watch(function ngModelWatch() {
          var modelValue = ngModelGet($scope);
          if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
            ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
            parserValid = undefined;
            var formatters = ctrl.$formatters,
                idx = formatters.length;
            var viewValue = modelValue;
            while (idx--) {
              viewValue = formatters[idx](viewValue);
            }
            if (ctrl.$viewValue !== viewValue) {
              ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
              ctrl.$render();
              ctrl.$$runValidators(modelValue, viewValue, noop);
            }
          }
          return modelValue;
        });
      }];
      var ngModelDirective = ['$rootScope', function($rootScope) {
        return {
          restrict: 'A',
          require: ['ngModel', '^?form', '^?ngModelOptions'],
          controller: NgModelController,
          priority: 1,
          compile: function ngModelCompile(element) {
            element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
            return {
              pre: function ngModelPreLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0],
                    formCtrl = ctrls[1] || nullFormCtrl;
                modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                formCtrl.$addControl(modelCtrl);
                attr.$observe('name', function(newValue) {
                  if (modelCtrl.$name !== newValue) {
                    formCtrl.$$renameControl(modelCtrl, newValue);
                  }
                });
                scope.$on('$destroy', function() {
                  formCtrl.$removeControl(modelCtrl);
                });
              },
              post: function ngModelPostLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0];
                if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                  element.on(modelCtrl.$options.updateOn, function(ev) {
                    modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                  });
                }
                element.on('blur', function(ev) {
                  if (modelCtrl.$touched)
                    return ;
                  if ($rootScope.$$phase) {
                    scope.$evalAsync(modelCtrl.$setTouched);
                  } else {
                    scope.$apply(modelCtrl.$setTouched);
                  }
                });
              }
            };
          }
        };
      }];
      var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
      var ngModelOptionsDirective = function() {
        return {
          restrict: 'A',
          controller: ['$scope', '$attrs', function($scope, $attrs) {
            var that = this;
            this.$options = copy($scope.$eval($attrs.ngModelOptions));
            if (this.$options.updateOn !== undefined) {
              this.$options.updateOnDefault = false;
              this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                that.$options.updateOnDefault = true;
                return ' ';
              }));
            } else {
              this.$options.updateOnDefault = true;
            }
          }]
        };
      };
      function addSetValidityMethod(context) {
        var ctrl = context.ctrl,
            $element = context.$element,
            classCache = {},
            set = context.set,
            unset = context.unset,
            parentForm = context.parentForm,
            $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
        ctrl.$setValidity = setValidity;
        function setValidity(validationErrorKey, state, controller) {
          if (state === undefined) {
            createAndSet('$pending', validationErrorKey, controller);
          } else {
            unsetAndCleanup('$pending', validationErrorKey, controller);
          }
          if (!isBoolean(state)) {
            unset(ctrl.$error, validationErrorKey, controller);
            unset(ctrl.$$success, validationErrorKey, controller);
          } else {
            if (state) {
              unset(ctrl.$error, validationErrorKey, controller);
              set(ctrl.$$success, validationErrorKey, controller);
            } else {
              set(ctrl.$error, validationErrorKey, controller);
              unset(ctrl.$$success, validationErrorKey, controller);
            }
          }
          if (ctrl.$pending) {
            cachedToggleClass(PENDING_CLASS, true);
            ctrl.$valid = ctrl.$invalid = undefined;
            toggleValidationCss('', null);
          } else {
            cachedToggleClass(PENDING_CLASS, false);
            ctrl.$valid = isObjectEmpty(ctrl.$error);
            ctrl.$invalid = !ctrl.$valid;
            toggleValidationCss('', ctrl.$valid);
          }
          var combinedState;
          if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
            combinedState = undefined;
          } else if (ctrl.$error[validationErrorKey]) {
            combinedState = false;
          } else if (ctrl.$$success[validationErrorKey]) {
            combinedState = true;
          } else {
            combinedState = null;
          }
          toggleValidationCss(validationErrorKey, combinedState);
          parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
          if (!ctrl[name]) {
            ctrl[name] = {};
          }
          set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
          if (ctrl[name]) {
            unset(ctrl[name], value, controller);
          }
          if (isObjectEmpty(ctrl[name])) {
            ctrl[name] = undefined;
          }
        }
        function cachedToggleClass(className, switchValue) {
          if (switchValue && !classCache[className]) {
            $animate.addClass($element, className);
            classCache[className] = true;
          } else if (!switchValue && classCache[className]) {
            $animate.removeClass($element, className);
            classCache[className] = false;
          }
        }
        function toggleValidationCss(validationErrorKey, isValid) {
          validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
          cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
          cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
        }
      }
      function isObjectEmpty(obj) {
        if (obj) {
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              return false;
            }
          }
        }
        return true;
      }
      var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1000
      });
      var ngOptionsMinErr = minErr('ngOptions');
      var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
      var ngOptionsDirective = ['$compile', '$parse', function($compile, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
          var match = optionsExp.match(NG_OPTIONS_REGEXP);
          if (!(match)) {
            throw ngOptionsMinErr('iexp', "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
          }
          var valueName = match[5] || match[7];
          var keyName = match[6];
          var selectAs = / as /.test(match[0]) && match[1];
          var trackBy = match[9];
          var valueFn = $parse(match[2] ? match[1] : valueName);
          var selectAsFn = selectAs && $parse(selectAs);
          var viewValueFn = selectAsFn || valueFn;
          var trackByFn = trackBy && $parse(trackBy);
          var getTrackByValueFn = trackBy ? function(value, locals) {
            return trackByFn(scope, locals);
          } : function getHashOfValue(value) {
            return hashKey(value);
          };
          var getTrackByValue = function(value, key) {
            return getTrackByValueFn(value, getLocals(value, key));
          };
          var displayFn = $parse(match[2] || match[1]);
          var groupByFn = $parse(match[3] || '');
          var disableWhenFn = $parse(match[4] || '');
          var valuesFn = $parse(match[8]);
          var locals = {};
          var getLocals = keyName ? function(value, key) {
            locals[keyName] = key;
            locals[valueName] = value;
            return locals;
          } : function(value) {
            locals[valueName] = value;
            return locals;
          };
          function Option(selectValue, viewValue, label, group, disabled) {
            this.selectValue = selectValue;
            this.viewValue = viewValue;
            this.label = label;
            this.group = group;
            this.disabled = disabled;
          }
          function getOptionValuesKeys(optionValues) {
            var optionValuesKeys;
            if (!keyName && isArrayLike(optionValues)) {
              optionValuesKeys = optionValues;
            } else {
              optionValuesKeys = [];
              for (var itemKey in optionValues) {
                if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                  optionValuesKeys.push(itemKey);
                }
              }
            }
            return optionValuesKeys;
          }
          return {
            trackBy: trackBy,
            getTrackByValue: getTrackByValue,
            getWatchables: $parse(valuesFn, function(optionValues) {
              var watchedArray = [];
              optionValues = optionValues || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(optionValues[key], key);
                var selectValue = getTrackByValueFn(optionValues[key], locals);
                watchedArray.push(selectValue);
                if (match[2] || match[1]) {
                  var label = displayFn(scope, locals);
                  watchedArray.push(label);
                }
                if (match[4]) {
                  var disableWhen = disableWhenFn(scope, locals);
                  watchedArray.push(disableWhen);
                }
              }
              return watchedArray;
            }),
            getOptions: function() {
              var optionItems = [];
              var selectValueMap = {};
              var optionValues = valuesFn(scope) || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var viewValue = viewValueFn(scope, locals);
                var selectValue = getTrackByValueFn(viewValue, locals);
                var label = displayFn(scope, locals);
                var group = groupByFn(scope, locals);
                var disabled = disableWhenFn(scope, locals);
                var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                optionItems.push(optionItem);
                selectValueMap[selectValue] = optionItem;
              }
              return {
                items: optionItems,
                selectValueMap: selectValueMap,
                getOptionFromViewValue: function(value) {
                  return selectValueMap[getTrackByValue(value)];
                },
                getViewValueFromOption: function(option) {
                  return trackBy ? angular.copy(option.viewValue) : option.viewValue;
                }
              };
            }
          };
        }
        var optionTemplate = document.createElement('option'),
            optGroupTemplate = document.createElement('optgroup');
        return {
          restrict: 'A',
          terminal: true,
          require: ['select', '?ngModel'],
          link: function(scope, selectElement, attr, ctrls) {
            var ngModelCtrl = ctrls[1];
            if (!ngModelCtrl)
              return ;
            var selectCtrl = ctrls[0];
            var multiple = attr.multiple;
            var emptyOption;
            for (var i = 0,
                children = selectElement.children(),
                ii = children.length; i < ii; i++) {
              if (children[i].value === '') {
                emptyOption = children.eq(i);
                break;
              }
            }
            var providedEmptyOption = !!emptyOption;
            var unknownOption = jqLite(optionTemplate.cloneNode(false));
            unknownOption.val('?');
            var options;
            var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
            var renderEmptyOption = function() {
              if (!providedEmptyOption) {
                selectElement.prepend(emptyOption);
              }
              selectElement.val('');
              emptyOption.prop('selected', true);
              emptyOption.attr('selected', true);
            };
            var removeEmptyOption = function() {
              if (!providedEmptyOption) {
                emptyOption.remove();
              }
            };
            var renderUnknownOption = function() {
              selectElement.prepend(unknownOption);
              selectElement.val('?');
              unknownOption.prop('selected', true);
              unknownOption.attr('selected', true);
            };
            var removeUnknownOption = function() {
              unknownOption.remove();
            };
            if (!multiple) {
              selectCtrl.writeValue = function writeNgOptionsValue(value) {
                var option = options.getOptionFromViewValue(value);
                if (option && !option.disabled) {
                  if (selectElement[0].value !== option.selectValue) {
                    removeUnknownOption();
                    removeEmptyOption();
                    selectElement[0].value = option.selectValue;
                    option.element.selected = true;
                    option.element.setAttribute('selected', 'selected');
                  }
                } else {
                  if (value === null || providedEmptyOption) {
                    removeUnknownOption();
                    renderEmptyOption();
                  } else {
                    removeEmptyOption();
                    renderUnknownOption();
                  }
                }
              };
              selectCtrl.readValue = function readNgOptionsValue() {
                var selectedOption = options.selectValueMap[selectElement.val()];
                if (selectedOption && !selectedOption.disabled) {
                  removeEmptyOption();
                  removeUnknownOption();
                  return options.getViewValueFromOption(selectedOption);
                }
                return null;
              };
              if (ngOptions.trackBy) {
                scope.$watch(function() {
                  return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
                }, function() {
                  ngModelCtrl.$render();
                });
              }
            } else {
              ngModelCtrl.$isEmpty = function(value) {
                return !value || value.length === 0;
              };
              selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
                options.items.forEach(function(option) {
                  option.element.selected = false;
                });
                if (value) {
                  value.forEach(function(item) {
                    var option = options.getOptionFromViewValue(item);
                    if (option && !option.disabled)
                      option.element.selected = true;
                  });
                }
              };
              selectCtrl.readValue = function readNgOptionsMultiple() {
                var selectedValues = selectElement.val() || [],
                    selections = [];
                forEach(selectedValues, function(value) {
                  var option = options.selectValueMap[value];
                  if (option && !option.disabled)
                    selections.push(options.getViewValueFromOption(option));
                });
                return selections;
              };
              if (ngOptions.trackBy) {
                scope.$watchCollection(function() {
                  if (isArray(ngModelCtrl.$viewValue)) {
                    return ngModelCtrl.$viewValue.map(function(value) {
                      return ngOptions.getTrackByValue(value);
                    });
                  }
                }, function() {
                  ngModelCtrl.$render();
                });
              }
            }
            if (providedEmptyOption) {
              emptyOption.remove();
              $compile(emptyOption)(scope);
              emptyOption.removeClass('ng-scope');
            } else {
              emptyOption = jqLite(optionTemplate.cloneNode(false));
            }
            updateOptions();
            scope.$watchCollection(ngOptions.getWatchables, updateOptions);
            function updateOptionElement(option, element) {
              option.element = element;
              element.disabled = option.disabled;
              if (option.value !== element.value)
                element.value = option.selectValue;
              if (option.label !== element.label) {
                element.label = option.label;
                element.textContent = option.label;
              }
            }
            function addOrReuseElement(parent, current, type, templateElement) {
              var element;
              if (current && lowercase(current.nodeName) === type) {
                element = current;
              } else {
                element = templateElement.cloneNode(false);
                if (!current) {
                  parent.appendChild(element);
                } else {
                  parent.insertBefore(element, current);
                }
              }
              return element;
            }
            function removeExcessElements(current) {
              var next;
              while (current) {
                next = current.nextSibling;
                jqLiteRemove(current);
                current = next;
              }
            }
            function skipEmptyAndUnknownOptions(current) {
              var emptyOption_ = emptyOption && emptyOption[0];
              var unknownOption_ = unknownOption && unknownOption[0];
              if (emptyOption_ || unknownOption_) {
                while (current && (current === emptyOption_ || current === unknownOption_)) {
                  current = current.nextSibling;
                }
              }
              return current;
            }
            function updateOptions() {
              var previousValue = options && selectCtrl.readValue();
              options = ngOptions.getOptions();
              var groupMap = {};
              var currentElement = selectElement[0].firstChild;
              if (providedEmptyOption) {
                selectElement.prepend(emptyOption);
              }
              currentElement = skipEmptyAndUnknownOptions(currentElement);
              options.items.forEach(function updateOption(option) {
                var group;
                var groupElement;
                var optionElement;
                if (option.group) {
                  group = groupMap[option.group];
                  if (!group) {
                    groupElement = addOrReuseElement(selectElement[0], currentElement, 'optgroup', optGroupTemplate);
                    currentElement = groupElement.nextSibling;
                    groupElement.label = option.group;
                    group = groupMap[option.group] = {
                      groupElement: groupElement,
                      currentOptionElement: groupElement.firstChild
                    };
                  }
                  optionElement = addOrReuseElement(group.groupElement, group.currentOptionElement, 'option', optionTemplate);
                  updateOptionElement(option, optionElement);
                  group.currentOptionElement = optionElement.nextSibling;
                } else {
                  optionElement = addOrReuseElement(selectElement[0], currentElement, 'option', optionTemplate);
                  updateOptionElement(option, optionElement);
                  currentElement = optionElement.nextSibling;
                }
              });
              Object.keys(groupMap).forEach(function(key) {
                removeExcessElements(groupMap[key].currentOptionElement);
              });
              removeExcessElements(currentElement);
              ngModelCtrl.$render();
              if (!ngModelCtrl.$isEmpty(previousValue)) {
                var nextValue = selectCtrl.readValue();
                if (ngOptions.trackBy ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                  ngModelCtrl.$setViewValue(nextValue);
                  ngModelCtrl.$render();
                }
              }
            }
          }
        };
      }];
      var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale, $interpolate, $log) {
        var BRACE = /{}/g,
            IS_WHEN = /^when(Minus)?(.+)$/;
        return {link: function(scope, element, attr) {
            var numberExp = attr.count,
                whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                offset = attr.offset || 0,
                whens = scope.$eval(whenExp) || {},
                whensExpFns = {},
                startSymbol = $interpolate.startSymbol(),
                endSymbol = $interpolate.endSymbol(),
                braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
                watchRemover = angular.noop,
                lastCount;
            forEach(attr, function(expression, attributeName) {
              var tmpMatch = IS_WHEN.exec(attributeName);
              if (tmpMatch) {
                var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
                whens[whenKey] = element.attr(attr.$attr[attributeName]);
              }
            });
            forEach(whens, function(expression, key) {
              whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
            });
            scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
              var count = parseFloat(newVal);
              var countIsNaN = isNaN(count);
              if (!countIsNaN && !(count in whens)) {
                count = $locale.pluralCat(count - offset);
              }
              if ((count !== lastCount) && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                watchRemover();
                var whenExpFn = whensExpFns[count];
                if (isUndefined(whenExpFn)) {
                  if (newVal != null) {
                    $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                  }
                  watchRemover = noop;
                  updateElementText();
                } else {
                  watchRemover = scope.$watch(whenExpFn, updateElementText);
                }
                lastCount = count;
              }
            });
            function updateElementText(newText) {
              element.text(newText || '');
            }
          }};
      }];
      var ngRepeatDirective = ['$parse', '$animate', function($parse, $animate) {
        var NG_REMOVED = '$$NG_REMOVED';
        var ngRepeatMinErr = minErr('ngRepeat');
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
          scope[valueIdentifier] = value;
          if (keyIdentifier)
            scope[keyIdentifier] = key;
          scope.$index = index;
          scope.$first = (index === 0);
          scope.$last = (index === (arrayLength - 1));
          scope.$middle = !(scope.$first || scope.$last);
          scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
          return block.clone[0];
        };
        var getBlockEnd = function(block) {
          return block.clone[block.clone.length - 1];
        };
        return {
          restrict: 'A',
          multiElement: true,
          transclude: 'element',
          priority: 1000,
          terminal: true,
          $$tlb: true,
          compile: function ngRepeatCompile($element, $attr) {
            var expression = $attr.ngRepeat;
            var ngRepeatEndComment = document.createComment(' end ngRepeat: ' + expression + ' ');
            var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
            if (!match) {
              throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
            }
            var lhs = match[1];
            var rhs = match[2];
            var aliasAs = match[3];
            var trackByExp = match[4];
            match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
            if (!match) {
              throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
            }
            var valueIdentifier = match[3] || match[1];
            var keyIdentifier = match[2];
            if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
              throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
            }
            var trackByExpGetter,
                trackByIdExpFn,
                trackByIdArrayFn,
                trackByIdObjFn;
            var hashFnLocals = {$id: hashKey};
            if (trackByExp) {
              trackByExpGetter = $parse(trackByExp);
            } else {
              trackByIdArrayFn = function(key, value) {
                return hashKey(value);
              };
              trackByIdObjFn = function(key) {
                return key;
              };
            }
            return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
              if (trackByExpGetter) {
                trackByIdExpFn = function(key, value, index) {
                  if (keyIdentifier)
                    hashFnLocals[keyIdentifier] = key;
                  hashFnLocals[valueIdentifier] = value;
                  hashFnLocals.$index = index;
                  return trackByExpGetter($scope, hashFnLocals);
                };
              }
              var lastBlockMap = createMap();
              $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                var index,
                    length,
                    previousNode = $element[0],
                    nextNode,
                    nextBlockMap = createMap(),
                    collectionLength,
                    key,
                    value,
                    trackById,
                    trackByIdFn,
                    collectionKeys,
                    block,
                    nextBlockOrder,
                    elementsToRemove;
                if (aliasAs) {
                  $scope[aliasAs] = collection;
                }
                if (isArrayLike(collection)) {
                  collectionKeys = collection;
                  trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                } else {
                  trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                  collectionKeys = [];
                  for (var itemKey in collection) {
                    if (collection.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                      collectionKeys.push(itemKey);
                    }
                  }
                }
                collectionLength = collectionKeys.length;
                nextBlockOrder = new Array(collectionLength);
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  trackById = trackByIdFn(key, value, index);
                  if (lastBlockMap[trackById]) {
                    block = lastBlockMap[trackById];
                    delete lastBlockMap[trackById];
                    nextBlockMap[trackById] = block;
                    nextBlockOrder[index] = block;
                  } else if (nextBlockMap[trackById]) {
                    forEach(nextBlockOrder, function(block) {
                      if (block && block.scope)
                        lastBlockMap[block.id] = block;
                    });
                    throw ngRepeatMinErr('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                  } else {
                    nextBlockOrder[index] = {
                      id: trackById,
                      scope: undefined,
                      clone: undefined
                    };
                    nextBlockMap[trackById] = true;
                  }
                }
                for (var blockKey in lastBlockMap) {
                  block = lastBlockMap[blockKey];
                  elementsToRemove = getBlockNodes(block.clone);
                  $animate.leave(elementsToRemove);
                  if (elementsToRemove[0].parentNode) {
                    for (index = 0, length = elementsToRemove.length; index < length; index++) {
                      elementsToRemove[index][NG_REMOVED] = true;
                    }
                  }
                  block.scope.$destroy();
                }
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  block = nextBlockOrder[index];
                  if (block.scope) {
                    nextNode = previousNode;
                    do {
                      nextNode = nextNode.nextSibling;
                    } while (nextNode && nextNode[NG_REMOVED]);
                    if (getBlockStart(block) != nextNode) {
                      $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));
                    }
                    previousNode = getBlockEnd(block);
                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                  } else {
                    $transclude(function ngRepeatTransclude(clone, scope) {
                      block.scope = scope;
                      var endNode = ngRepeatEndComment.cloneNode(false);
                      clone[clone.length++] = endNode;
                      $animate.enter(clone, null, jqLite(previousNode));
                      previousNode = endNode;
                      block.clone = clone;
                      nextBlockMap[block.id] = block;
                      updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                    });
                  }
                }
                lastBlockMap = nextBlockMap;
              });
            };
          }
        };
      }];
      var NG_HIDE_CLASS = 'ng-hide';
      var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
      var ngShowDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
              $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngHideDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
              $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
          if (oldStyles && (newStyles !== oldStyles)) {
            forEach(oldStyles, function(val, style) {
              element.css(style, '');
            });
          }
          if (newStyles)
            element.css(newStyles);
        }, true);
      });
      var ngSwitchDirective = ['$animate', function($animate) {
        return {
          require: 'ngSwitch',
          controller: ['$scope', function ngSwitchController() {
            this.cases = {};
          }],
          link: function(scope, element, attr, ngSwitchController) {
            var watchExpr = attr.ngSwitch || attr.on,
                selectedTranscludes = [],
                selectedElements = [],
                previousLeaveAnimations = [],
                selectedScopes = [];
            var spliceFactory = function(array, index) {
              return function() {
                array.splice(index, 1);
              };
            };
            scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
              var i,
                  ii;
              for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                $animate.cancel(previousLeaveAnimations[i]);
              }
              previousLeaveAnimations.length = 0;
              for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                var selected = getBlockNodes(selectedElements[i].clone);
                selectedScopes[i].$destroy();
                var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                promise.then(spliceFactory(previousLeaveAnimations, i));
              }
              selectedElements.length = 0;
              selectedScopes.length = 0;
              if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
                forEach(selectedTranscludes, function(selectedTransclude) {
                  selectedTransclude.transclude(function(caseElement, selectedScope) {
                    selectedScopes.push(selectedScope);
                    var anchor = selectedTransclude.element;
                    caseElement[caseElement.length++] = document.createComment(' end ngSwitchWhen: ');
                    var block = {clone: caseElement};
                    selectedElements.push(block);
                    $animate.enter(caseElement, anchor.parent(), anchor);
                  });
                });
              }
            });
          }
        };
      }];
      var ngSwitchWhenDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
          ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
          ctrl.cases['!' + attrs.ngSwitchWhen].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngSwitchDefaultDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
          ctrl.cases['?'] = (ctrl.cases['?'] || []);
          ctrl.cases['?'].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngTranscludeDirective = ngDirective({
        restrict: 'EAC',
        link: function($scope, $element, $attrs, controller, $transclude) {
          if (!$transclude) {
            throw minErr('ngTransclude')('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
          }
          $transclude(function(clone) {
            $element.empty();
            $element.append(clone);
          });
        }
      });
      var scriptDirective = ['$templateCache', function($templateCache) {
        return {
          restrict: 'E',
          terminal: true,
          compile: function(element, attr) {
            if (attr.type == 'text/ng-template') {
              var templateUrl = attr.id,
                  text = element[0].text;
              $templateCache.put(templateUrl, text);
            }
          }
        };
      }];
      var noopNgModelController = {
        $setViewValue: noop,
        $render: noop
      };
      var SelectController = ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
        var self = this,
            optionsMap = new HashMap();
        self.ngModelCtrl = noopNgModelController;
        self.unknownOption = jqLite(document.createElement('option'));
        self.renderUnknownOption = function(val) {
          var unknownVal = '? ' + hashKey(val) + ' ?';
          self.unknownOption.val(unknownVal);
          $element.prepend(self.unknownOption);
          $element.val(unknownVal);
        };
        $scope.$on('$destroy', function() {
          self.renderUnknownOption = noop;
        });
        self.removeUnknownOption = function() {
          if (self.unknownOption.parent())
            self.unknownOption.remove();
        };
        self.readValue = function readSingleValue() {
          self.removeUnknownOption();
          return $element.val();
        };
        self.writeValue = function writeSingleValue(value) {
          if (self.hasOption(value)) {
            self.removeUnknownOption();
            $element.val(value);
            if (value === '')
              self.emptyOption.prop('selected', true);
          } else {
            if (value == null && self.emptyOption) {
              self.removeUnknownOption();
              $element.val('');
            } else {
              self.renderUnknownOption(value);
            }
          }
        };
        self.addOption = function(value, element) {
          assertNotHasOwnProperty(value, '"option value"');
          if (value === '') {
            self.emptyOption = element;
          }
          var count = optionsMap.get(value) || 0;
          optionsMap.put(value, count + 1);
        };
        self.removeOption = function(value) {
          var count = optionsMap.get(value);
          if (count) {
            if (count === 1) {
              optionsMap.remove(value);
              if (value === '') {
                self.emptyOption = undefined;
              }
            } else {
              optionsMap.put(value, count - 1);
            }
          }
        };
        self.hasOption = function(value) {
          return !!optionsMap.get(value);
        };
      }];
      var selectDirective = function() {
        return {
          restrict: 'E',
          require: ['select', '?ngModel'],
          controller: SelectController,
          link: function(scope, element, attr, ctrls) {
            var ngModelCtrl = ctrls[1];
            if (!ngModelCtrl)
              return ;
            var selectCtrl = ctrls[0];
            selectCtrl.ngModelCtrl = ngModelCtrl;
            ngModelCtrl.$render = function() {
              selectCtrl.writeValue(ngModelCtrl.$viewValue);
            };
            element.on('change', function() {
              scope.$apply(function() {
                ngModelCtrl.$setViewValue(selectCtrl.readValue());
              });
            });
            if (attr.multiple) {
              selectCtrl.readValue = function readMultipleValue() {
                var array = [];
                forEach(element.find('option'), function(option) {
                  if (option.selected) {
                    array.push(option.value);
                  }
                });
                return array;
              };
              selectCtrl.writeValue = function writeMultipleValue(value) {
                var items = new HashMap(value);
                forEach(element.find('option'), function(option) {
                  option.selected = isDefined(items.get(option.value));
                });
              };
              var lastView,
                  lastViewRef = NaN;
              scope.$watch(function selectMultipleWatch() {
                if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                  lastView = shallowCopy(ngModelCtrl.$viewValue);
                  ngModelCtrl.$render();
                }
                lastViewRef = ngModelCtrl.$viewValue;
              });
              ngModelCtrl.$isEmpty = function(value) {
                return !value || value.length === 0;
              };
            }
          }
        };
      };
      var optionDirective = ['$interpolate', function($interpolate) {
        function chromeHack(optionElement) {
          if (optionElement[0].hasAttribute('selected')) {
            optionElement[0].selected = true;
          }
        }
        return {
          restrict: 'E',
          priority: 100,
          compile: function(element, attr) {
            if (isUndefined(attr.value)) {
              var interpolateFn = $interpolate(element.text(), true);
              if (!interpolateFn) {
                attr.$set('value', element.text());
              }
            }
            return function(scope, element, attr) {
              var selectCtrlName = '$selectController',
                  parent = element.parent(),
                  selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
              if (selectCtrl && selectCtrl.ngModelCtrl) {
                if (interpolateFn) {
                  scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
                    attr.$set('value', newVal);
                    if (oldVal !== newVal) {
                      selectCtrl.removeOption(oldVal);
                    }
                    selectCtrl.addOption(newVal, element);
                    selectCtrl.ngModelCtrl.$render();
                    chromeHack(element);
                  });
                } else {
                  selectCtrl.addOption(attr.value, element);
                  selectCtrl.ngModelCtrl.$render();
                  chromeHack(element);
                }
                element.on('$destroy', function() {
                  selectCtrl.removeOption(attr.value);
                  selectCtrl.ngModelCtrl.$render();
                });
              }
            };
          }
        };
      }];
      var styleDirective = valueFn({
        restrict: 'E',
        terminal: false
      });
      var requiredDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return ;
            attr.required = true;
            ctrl.$validators.required = function(modelValue, viewValue) {
              return !attr.required || !ctrl.$isEmpty(viewValue);
            };
            attr.$observe('required', function() {
              ctrl.$validate();
            });
          }
        };
      };
      var patternDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return ;
            var regexp,
                patternExp = attr.ngPattern || attr.pattern;
            attr.$observe('pattern', function(regex) {
              if (isString(regex) && regex.length > 0) {
                regex = new RegExp('^' + regex + '$');
              }
              if (regex && !regex.test) {
                throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
              }
              regexp = regex || undefined;
              ctrl.$validate();
            });
            ctrl.$validators.pattern = function(value) {
              return ctrl.$isEmpty(value) || isUndefined(regexp) || regexp.test(value);
            };
          }
        };
      };
      var maxlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return ;
            var maxlength = -1;
            attr.$observe('maxlength', function(value) {
              var intVal = toInt(value);
              maxlength = isNaN(intVal) ? -1 : intVal;
              ctrl.$validate();
            });
            ctrl.$validators.maxlength = function(modelValue, viewValue) {
              return (maxlength < 0) || ctrl.$isEmpty(viewValue) || (viewValue.length <= maxlength);
            };
          }
        };
      };
      var minlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return ;
            var minlength = 0;
            attr.$observe('minlength', function(value) {
              minlength = toInt(value) || 0;
              ctrl.$validate();
            });
            ctrl.$validators.minlength = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
            };
          }
        };
      };
      if (window.angular.bootstrap) {
        console.log('WARNING: Tried to load angular more than once.');
        return ;
      }
      bindJQuery();
      publishExternalAPI(angular);
      angular.module("ngLocale", [], ["$provide", function($provide) {
        var PLURAL_CATEGORY = {
          ZERO: "zero",
          ONE: "one",
          TWO: "two",
          FEW: "few",
          MANY: "many",
          OTHER: "other"
        };
        function getDecimals(n) {
          n = n + '';
          var i = n.indexOf('.');
          return (i == -1) ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
          var v = opt_precision;
          if (undefined === v) {
            v = Math.min(getDecimals(n), 3);
          }
          var base = Math.pow(10, v);
          var f = ((n * base) | 0) % base;
          return {
            v: v,
            f: f
          };
        }
        $provide.value("$locale", {
          "DATETIME_FORMATS": {
            "AMPMS": ["AM", "PM"],
            "DAY": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            "ERANAMES": ["Before Christ", "Anno Domini"],
            "ERAS": ["BC", "AD"],
            "FIRSTDAYOFWEEK": 6,
            "MONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "SHORTDAY": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            "SHORTMONTH": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            "WEEKENDRANGE": [5, 6],
            "fullDate": "EEEE, MMMM d, y",
            "longDate": "MMMM d, y",
            "medium": "MMM d, y h:mm:ss a",
            "mediumDate": "MMM d, y",
            "mediumTime": "h:mm:ss a",
            "short": "M/d/yy h:mm a",
            "shortDate": "M/d/yy",
            "shortTime": "h:mm a"
          },
          "NUMBER_FORMATS": {
            "CURRENCY_SYM": "$",
            "DECIMAL_SEP": ".",
            "GROUP_SEP": ",",
            "PATTERNS": [{
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 3,
              "minFrac": 0,
              "minInt": 1,
              "negPre": "-",
              "negSuf": "",
              "posPre": "",
              "posSuf": ""
            }, {
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 2,
              "minFrac": 2,
              "minInt": 1,
              "negPre": "-\u00a4",
              "negSuf": "",
              "posPre": "\u00a4",
              "posSuf": ""
            }]
          },
          "id": "en-us",
          "pluralCat": function(n, opt_precision) {
            var i = n | 0;
            var vf = getVF(n, opt_precision);
            if (i == 1 && vf.v == 0) {
              return PLURAL_CATEGORY.ONE;
            }
            return PLURAL_CATEGORY.OTHER;
          }
        });
      }]);
      jqLite(document).ready(function() {
        angularInit(document, bootstrap);
      });
    })(window, document);
    !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, "angular");
});

System.register("github:angular/bower-angular-animate@1.4.4/angular-animate", ["github:angular/bower-angular@1.4.4"], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, ["github:angular/bower-angular@1.4.4"]);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular, undefined) {
      'use strict';
      var noop = angular.noop;
      var extend = angular.extend;
      var jqLite = angular.element;
      var forEach = angular.forEach;
      var isArray = angular.isArray;
      var isString = angular.isString;
      var isObject = angular.isObject;
      var isUndefined = angular.isUndefined;
      var isDefined = angular.isDefined;
      var isFunction = angular.isFunction;
      var isElement = angular.isElement;
      var ELEMENT_NODE = 1;
      var COMMENT_NODE = 8;
      var ADD_CLASS_SUFFIX = '-add';
      var REMOVE_CLASS_SUFFIX = '-remove';
      var EVENT_CLASS_PREFIX = 'ng-';
      var ACTIVE_CLASS_SUFFIX = '-active';
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';
      var CSS_PREFIX = '',
          TRANSITION_PROP,
          TRANSITIONEND_EVENT,
          ANIMATION_PROP,
          ANIMATIONEND_EVENT;
      if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
        CSS_PREFIX = '-webkit-';
        TRANSITION_PROP = 'WebkitTransition';
        TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
      } else {
        TRANSITION_PROP = 'transition';
        TRANSITIONEND_EVENT = 'transitionend';
      }
      if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
        CSS_PREFIX = '-webkit-';
        ANIMATION_PROP = 'WebkitAnimation';
        ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
      } else {
        ANIMATION_PROP = 'animation';
        ANIMATIONEND_EVENT = 'animationend';
      }
      var DURATION_KEY = 'Duration';
      var PROPERTY_KEY = 'Property';
      var DELAY_KEY = 'Delay';
      var TIMING_KEY = 'TimingFunction';
      var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
      var ANIMATION_PLAYSTATE_KEY = 'PlayState';
      var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
      var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
      var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
      var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
      var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
      var isPromiseLike = function(p) {
        return p && p.then ? true : false;
      };
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function packageStyles(options) {
        var styles = {};
        if (options && (options.to || options.from)) {
          styles.to = options.to;
          styles.from = options.from;
        }
        return styles;
      }
      function pendClasses(classes, fix, isPrefix) {
        var className = '';
        classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [];
        forEach(classes, function(klass, i) {
          if (klass && klass.length > 0) {
            className += (i > 0) ? ' ' : '';
            className += isPrefix ? fix + klass : klass + fix;
          }
        });
        return className;
      }
      function removeFromArray(arr, val) {
        var index = arr.indexOf(val);
        if (val >= 0) {
          arr.splice(index, 1);
        }
      }
      function stripCommentsFromElement(element) {
        if (element instanceof jqLite) {
          switch (element.length) {
            case 0:
              return [];
              break;
            case 1:
              if (element[0].nodeType === ELEMENT_NODE) {
                return element;
              }
              break;
            default:
              return jqLite(extractElementNode(element));
              break;
          }
        }
        if (element.nodeType === ELEMENT_NODE) {
          return jqLite(element);
        }
      }
      function extractElementNode(element) {
        if (!element[0])
          return element;
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType == ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function $$addClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.addClass(elm, className);
        });
      }
      function $$removeClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.removeClass(elm, className);
        });
      }
      function applyAnimationClassesFactory($$jqLite) {
        return function(element, options) {
          if (options.addClass) {
            $$addClass($$jqLite, element, options.addClass);
            options.addClass = null;
          }
          if (options.removeClass) {
            $$removeClass($$jqLite, element, options.removeClass);
            options.removeClass = null;
          }
        };
      }
      function prepareAnimationOptions(options) {
        options = options || {};
        if (!options.$$prepared) {
          var domOperation = options.domOperation || noop;
          options.domOperation = function() {
            options.$$domOperationFired = true;
            domOperation();
            domOperation = noop;
          };
          options.$$prepared = true;
        }
        return options;
      }
      function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options);
        applyAnimationToStyles(element, options);
      }
      function applyAnimationFromStyles(element, options) {
        if (options.from) {
          element.css(options.from);
          options.from = null;
        }
      }
      function applyAnimationToStyles(element, options) {
        if (options.to) {
          element.css(options.to);
          options.to = null;
        }
      }
      function mergeAnimationOptions(element, target, newOptions) {
        var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
        var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
        var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);
        if (newOptions.preparationClasses) {
          target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
          delete newOptions.preparationClasses;
        }
        var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
        extend(target, newOptions);
        if (realDomOperation) {
          target.domOperation = realDomOperation;
        }
        if (classes.addClass) {
          target.addClass = classes.addClass;
        } else {
          target.addClass = null;
        }
        if (classes.removeClass) {
          target.removeClass = classes.removeClass;
        } else {
          target.removeClass = null;
        }
        return target;
      }
      function resolveElementClasses(existing, toAdd, toRemove) {
        var ADD_CLASS = 1;
        var REMOVE_CLASS = -1;
        var flags = {};
        existing = splitClassesToLookup(existing);
        toAdd = splitClassesToLookup(toAdd);
        forEach(toAdd, function(value, key) {
          flags[key] = ADD_CLASS;
        });
        toRemove = splitClassesToLookup(toRemove);
        forEach(toRemove, function(value, key) {
          flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
        });
        var classes = {
          addClass: '',
          removeClass: ''
        };
        forEach(flags, function(val, klass) {
          var prop,
              allow;
          if (val === ADD_CLASS) {
            prop = 'addClass';
            allow = !existing[klass];
          } else if (val === REMOVE_CLASS) {
            prop = 'removeClass';
            allow = existing[klass];
          }
          if (allow) {
            if (classes[prop].length) {
              classes[prop] += ' ';
            }
            classes[prop] += klass;
          }
        });
        function splitClassesToLookup(classes) {
          if (isString(classes)) {
            classes = classes.split(' ');
          }
          var obj = {};
          forEach(classes, function(klass) {
            if (klass.length) {
              obj[klass] = true;
            }
          });
          return obj;
        }
        return classes;
      }
      function getDomNode(element) {
        return (element instanceof angular.element) ? element[0] : element;
      }
      function applyGeneratedPreparationClasses(element, event, options) {
        var classes = '';
        if (event) {
          classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
        }
        if (options.addClass) {
          classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
        }
        if (options.removeClass) {
          classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
        }
        if (classes.length) {
          options.preparationClasses = classes;
          element.addClass(classes);
        }
      }
      function clearGeneratedClasses(element, options) {
        if (options.preparationClasses) {
          element.removeClass(options.preparationClasses);
          options.preparationClasses = null;
        }
        if (options.activeClasses) {
          element.removeClass(options.activeClasses);
          options.activeClasses = null;
        }
      }
      function blockTransitions(node, duration) {
        var value = duration ? '-' + duration + 's' : '';
        applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
        return [TRANSITION_DELAY_PROP, value];
      }
      function blockKeyframeAnimations(node, applyBlock) {
        var value = applyBlock ? 'paused' : '';
        var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
        applyInlineStyle(node, [key, value]);
        return [key, value];
      }
      function applyInlineStyle(node, styleTuple) {
        var prop = styleTuple[0];
        var value = styleTuple[1];
        node.style[prop] = value;
      }
      function concatWithSpace(a, b) {
        if (!a)
          return b;
        if (!b)
          return a;
        return a + ' ' + b;
      }
      function $$BodyProvider() {
        this.$get = ['$document', function($document) {
          return jqLite($document[0].body);
        }];
      }
      var $$AnimateChildrenDirective = [function() {
        return function(scope, element, attrs) {
          var val = attrs.ngAnimateChildren;
          if (angular.isString(val) && val.length === 0) {
            element.data(NG_ANIMATE_CHILDREN_DATA, true);
          } else {
            attrs.$observe('ngAnimateChildren', function(value) {
              value = value === 'on' || value === 'true';
              element.data(NG_ANIMATE_CHILDREN_DATA, value);
            });
          }
        };
      }];
      var ONE_SECOND = 1000;
      var BASE_TEN = 10;
      var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
      var CLOSING_TIME_BUFFER = 1.5;
      var DETECT_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP,
        animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
      };
      var DETECT_STAGGER_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP
      };
      function getCssKeyframeDurationStyle(duration) {
        return [ANIMATION_DURATION_PROP, duration + 's'];
      }
      function getCssDelayStyle(delay, isKeyframeAnimation) {
        var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
        return [prop, delay + 's'];
      }
      function computeCssStyles($window, element, properties) {
        var styles = Object.create(null);
        var detectedStyles = $window.getComputedStyle(element) || {};
        forEach(properties, function(formalStyleName, actualStyleName) {
          var val = detectedStyles[formalStyleName];
          if (val) {
            var c = val.charAt(0);
            if (c === '-' || c === '+' || c >= 0) {
              val = parseMaxTime(val);
            }
            if (val === 0) {
              val = null;
            }
            styles[actualStyleName] = val;
          }
        });
        return styles;
      }
      function parseMaxTime(str) {
        var maxValue = 0;
        var values = str.split(/\s*,\s*/);
        forEach(values, function(value) {
          if (value.charAt(value.length - 1) == 's') {
            value = value.substring(0, value.length - 1);
          }
          value = parseFloat(value) || 0;
          maxValue = maxValue ? Math.max(value, maxValue) : value;
        });
        return maxValue;
      }
      function truthyTimingValue(val) {
        return val === 0 || val != null;
      }
      function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
        var style = TRANSITION_PROP;
        var value = duration + 's';
        if (applyOnlyDuration) {
          style += DURATION_KEY;
        } else {
          value += ' linear all';
        }
        return [style, value];
      }
      function createLocalCacheLookup() {
        var cache = Object.create(null);
        return {
          flush: function() {
            cache = Object.create(null);
          },
          count: function(key) {
            var entry = cache[key];
            return entry ? entry.total : 0;
          },
          get: function(key) {
            var entry = cache[key];
            return entry && entry.value;
          },
          put: function(key, value) {
            if (!cache[key]) {
              cache[key] = {
                total: 1,
                value: value
              };
            } else {
              cache[key].total++;
            }
          }
        };
      }
      var $AnimateCssProvider = ['$animateProvider', function($animateProvider) {
        var gcsLookup = createLocalCacheLookup();
        var gcsStaggerLookup = createLocalCacheLookup();
        this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout', '$$forceReflow', '$sniffer', '$$rAF', function($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAF) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          var parentCounter = 0;
          function gcsHashFn(node, extraClasses) {
            var KEY = "$$ngAnimateParentKey";
            var parentNode = node.parentNode;
            var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
            return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;
          }
          function computeCachedCssStyles(node, className, cacheKey, properties) {
            var timings = gcsLookup.get(cacheKey);
            if (!timings) {
              timings = computeCssStyles($window, node, properties);
              if (timings.animationIterationCount === 'infinite') {
                timings.animationIterationCount = 1;
              }
            }
            gcsLookup.put(cacheKey, timings);
            return timings;
          }
          function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
            var stagger;
            if (gcsLookup.count(cacheKey) > 0) {
              stagger = gcsStaggerLookup.get(cacheKey);
              if (!stagger) {
                var staggerClassName = pendClasses(className, '-stagger');
                $$jqLite.addClass(node, staggerClassName);
                stagger = computeCssStyles($window, node, properties);
                stagger.animationDuration = Math.max(stagger.animationDuration, 0);
                stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);
                $$jqLite.removeClass(node, staggerClassName);
                gcsStaggerLookup.put(cacheKey, stagger);
              }
            }
            return stagger || {};
          }
          var cancelLastRAFRequest;
          var rafWaitQueue = [];
          function waitUntilQuiet(callback) {
            if (cancelLastRAFRequest) {
              cancelLastRAFRequest();
            }
            rafWaitQueue.push(callback);
            cancelLastRAFRequest = $$rAF(function() {
              cancelLastRAFRequest = null;
              gcsLookup.flush();
              gcsStaggerLookup.flush();
              var pageWidth = $$forceReflow();
              for (var i = 0; i < rafWaitQueue.length; i++) {
                rafWaitQueue[i](pageWidth);
              }
              rafWaitQueue.length = 0;
            });
          }
          return init;
          function computeTimings(node, className, cacheKey) {
            var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
            var aD = timings.animationDelay;
            var tD = timings.transitionDelay;
            timings.maxDelay = aD && tD ? Math.max(aD, tD) : (aD || tD);
            timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration);
            return timings;
          }
          function init(element, options) {
            var node = getDomNode(element);
            if (!node || !node.parentNode) {
              return closeAndReturnNoopAnimator();
            }
            options = prepareAnimationOptions(options);
            var temporaryStyles = [];
            var classes = element.attr('class');
            var styles = packageStyles(options);
            var animationClosed;
            var animationPaused;
            var animationCompleted;
            var runner;
            var runnerHost;
            var maxDelay;
            var maxDelayTime;
            var maxDuration;
            var maxDurationTime;
            if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {
              return closeAndReturnNoopAnimator();
            }
            var method = options.event && isArray(options.event) ? options.event.join(' ') : options.event;
            var isStructural = method && options.structural;
            var structuralClassName = '';
            var addRemoveClassName = '';
            if (isStructural) {
              structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
            } else if (method) {
              structuralClassName = method;
            }
            if (options.addClass) {
              addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
            }
            if (options.removeClass) {
              if (addRemoveClassName.length) {
                addRemoveClassName += ' ';
              }
              addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
            }
            if (options.applyClassesEarly && addRemoveClassName.length) {
              applyAnimationClasses(element, options);
              addRemoveClassName = '';
            }
            var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();
            var fullClassName = classes + ' ' + preparationClasses;
            var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
            var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
            var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;
            if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) {
              return closeAndReturnNoopAnimator();
            }
            var cacheKey,
                stagger;
            if (options.stagger > 0) {
              var staggerVal = parseFloat(options.stagger);
              stagger = {
                transitionDelay: staggerVal,
                animationDelay: staggerVal,
                transitionDuration: 0,
                animationDuration: 0
              };
            } else {
              cacheKey = gcsHashFn(node, fullClassName);
              stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
            }
            if (!options.$$skipPreparationClasses) {
              $$jqLite.addClass(element, preparationClasses);
            }
            var applyOnlyDuration;
            if (options.transitionStyle) {
              var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
              applyInlineStyle(node, transitionStyle);
              temporaryStyles.push(transitionStyle);
            }
            if (options.duration >= 0) {
              applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
              var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
              applyInlineStyle(node, durationStyle);
              temporaryStyles.push(durationStyle);
            }
            if (options.keyframeStyle) {
              var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
              applyInlineStyle(node, keyframeStyle);
              temporaryStyles.push(keyframeStyle);
            }
            var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0;
            var isFirst = itemIndex === 0;
            if (isFirst && !options.skipBlocking) {
              blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
            }
            var timings = computeTimings(node, fullClassName, cacheKey);
            var relativeDelay = timings.maxDelay;
            maxDelay = Math.max(relativeDelay, 0);
            maxDuration = timings.maxDuration;
            var flags = {};
            flags.hasTransitions = timings.transitionDuration > 0;
            flags.hasAnimations = timings.animationDuration > 0;
            flags.hasTransitionAll = flags.hasTransitions && timings.transitionProperty == 'all';
            flags.applyTransitionDuration = hasToStyles && ((flags.hasTransitions && !flags.hasTransitionAll) || (flags.hasAnimations && !flags.hasTransitions));
            flags.applyAnimationDuration = options.duration && flags.hasAnimations;
            flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
            flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations;
            flags.recalculateTimingStyles = addRemoveClassName.length > 0;
            if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
              maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;
              if (flags.applyTransitionDuration) {
                flags.hasTransitions = true;
                timings.transitionDuration = maxDuration;
                applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
                temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
              }
              if (flags.applyAnimationDuration) {
                flags.hasAnimations = true;
                timings.animationDuration = maxDuration;
                temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
              }
            }
            if (maxDuration === 0 && !flags.recalculateTimingStyles) {
              return closeAndReturnNoopAnimator();
            }
            if (options.duration == null && timings.transitionDuration > 0) {
              flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
            }
            maxDelayTime = maxDelay * ONE_SECOND;
            maxDurationTime = maxDuration * ONE_SECOND;
            if (!options.skipBlocking) {
              flags.blockTransition = timings.transitionDuration > 0;
              flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
            }
            applyAnimationFromStyles(element, options);
            if (flags.blockTransition || flags.blockKeyframeAnimation) {
              applyBlocking(maxDuration);
            } else if (!options.skipBlocking) {
              blockTransitions(node, false);
            }
            return {
              $$willAnimate: true,
              end: endFn,
              start: function() {
                if (animationClosed)
                  return ;
                runnerHost = {
                  end: endFn,
                  cancel: cancelFn,
                  resume: null,
                  pause: null
                };
                runner = new $$AnimateRunner(runnerHost);
                waitUntilQuiet(start);
                return runner;
              }
            };
            function endFn() {
              close();
            }
            function cancelFn() {
              close(true);
            }
            function close(rejected) {
              if (animationClosed || (animationCompleted && animationPaused))
                return ;
              animationClosed = true;
              animationPaused = false;
              if (!options.$$skipPreparationClasses) {
                $$jqLite.removeClass(element, preparationClasses);
              }
              $$jqLite.removeClass(element, activeClasses);
              blockKeyframeAnimations(node, false);
              blockTransitions(node, false);
              forEach(temporaryStyles, function(entry) {
                node.style[entry[0]] = '';
              });
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              if (options.onDone) {
                options.onDone();
              }
              if (runner) {
                runner.complete(!rejected);
              }
            }
            function applyBlocking(duration) {
              if (flags.blockTransition) {
                blockTransitions(node, duration);
              }
              if (flags.blockKeyframeAnimation) {
                blockKeyframeAnimations(node, !!duration);
              }
            }
            function closeAndReturnNoopAnimator() {
              runner = new $$AnimateRunner({
                end: endFn,
                cancel: cancelFn
              });
              close();
              return {
                $$willAnimate: false,
                start: function() {
                  return runner;
                },
                end: endFn
              };
            }
            function start() {
              if (animationClosed)
                return ;
              if (!node.parentNode) {
                close();
                return ;
              }
              var startTime,
                  events = [];
              var playPause = function(playAnimation) {
                if (!animationCompleted) {
                  animationPaused = !playAnimation;
                  if (timings.animationDuration) {
                    var value = blockKeyframeAnimations(node, animationPaused);
                    animationPaused ? temporaryStyles.push(value) : removeFromArray(temporaryStyles, value);
                  }
                } else if (animationPaused && playAnimation) {
                  animationPaused = false;
                  close();
                }
              };
              var maxStagger = itemIndex > 0 && ((timings.transitionDuration && stagger.transitionDuration === 0) || (timings.animationDuration && stagger.animationDuration === 0)) && Math.max(stagger.animationDelay, stagger.transitionDelay);
              if (maxStagger) {
                $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), false);
              } else {
                triggerAnimationStart();
              }
              runnerHost.resume = function() {
                playPause(true);
              };
              runnerHost.pause = function() {
                playPause(false);
              };
              function triggerAnimationStart() {
                if (animationClosed)
                  return ;
                applyBlocking(false);
                forEach(temporaryStyles, function(entry) {
                  var key = entry[0];
                  var value = entry[1];
                  node.style[key] = value;
                });
                applyAnimationClasses(element, options);
                $$jqLite.addClass(element, activeClasses);
                if (flags.recalculateTimingStyles) {
                  fullClassName = node.className + ' ' + preparationClasses;
                  cacheKey = gcsHashFn(node, fullClassName);
                  timings = computeTimings(node, fullClassName, cacheKey);
                  relativeDelay = timings.maxDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  maxDuration = timings.maxDuration;
                  if (maxDuration === 0) {
                    close();
                    return ;
                  }
                  flags.hasTransitions = timings.transitionDuration > 0;
                  flags.hasAnimations = timings.animationDuration > 0;
                }
                if (flags.applyTransitionDelay || flags.applyAnimationDelay) {
                  relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  var delayStyle;
                  if (flags.applyTransitionDelay) {
                    timings.transitionDelay = relativeDelay;
                    delayStyle = getCssDelayStyle(relativeDelay);
                    temporaryStyles.push(delayStyle);
                    node.style[delayStyle[0]] = delayStyle[1];
                  }
                  if (flags.applyAnimationDelay) {
                    timings.animationDelay = relativeDelay;
                    delayStyle = getCssDelayStyle(relativeDelay, true);
                    temporaryStyles.push(delayStyle);
                    node.style[delayStyle[0]] = delayStyle[1];
                  }
                }
                maxDelayTime = maxDelay * ONE_SECOND;
                maxDurationTime = maxDuration * ONE_SECOND;
                if (options.easing) {
                  var easeProp,
                      easeVal = options.easing;
                  if (flags.hasTransitions) {
                    easeProp = TRANSITION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                  if (flags.hasAnimations) {
                    easeProp = ANIMATION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                }
                if (timings.transitionDuration) {
                  events.push(TRANSITIONEND_EVENT);
                }
                if (timings.animationDuration) {
                  events.push(ANIMATIONEND_EVENT);
                }
                startTime = Date.now();
                element.on(events.join(' '), onAnimationProgress);
                $timeout(onAnimationExpired, maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime, false);
                applyAnimationToStyles(element, options);
              }
              function onAnimationExpired() {
                close();
              }
              function onAnimationProgress(event) {
                event.stopPropagation();
                var ev = event.originalEvent || event;
                var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();
                var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
                if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                  animationCompleted = true;
                  close();
                }
              }
            }
          }
        }];
      }];
      var $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateCssDriver');
        var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
        var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';
        var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
        var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';
        this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$$body', '$sniffer', '$$jqLite', function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $$body, $sniffer, $$jqLite) {
          if (!$sniffer.animations && !$sniffer.transitions)
            return noop;
          var bodyNode = getDomNode($$body);
          var rootNode = getDomNode($rootElement);
          var rootBodyElement = jqLite(bodyNode.parentNode === rootNode ? bodyNode : rootNode);
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function initDriverFn(animationDetails, onBeforeClassesAppliedCb) {
            return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails, onBeforeClassesAppliedCb);
          };
          function filterCssClasses(classes) {
            return classes.replace(/\bng-\S+\b/g, '');
          }
          function getUniqueValues(a, b) {
            if (isString(a))
              a = a.split(' ');
            if (isString(b))
              b = b.split(' ');
            return a.filter(function(val) {
              return b.indexOf(val) === -1;
            }).join(' ');
          }
          function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
            var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
            var startingClasses = filterCssClasses(getClassVal(clone));
            outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);
            rootBodyElement.append(clone);
            var animatorIn,
                animatorOut = prepareOutAnimation();
            if (!animatorOut) {
              animatorIn = prepareInAnimation();
              if (!animatorIn) {
                return end();
              }
            }
            var startingAnimator = animatorOut || animatorIn;
            return {start: function() {
                var runner;
                var currentAnimation = startingAnimator.start();
                currentAnimation.done(function() {
                  currentAnimation = null;
                  if (!animatorIn) {
                    animatorIn = prepareInAnimation();
                    if (animatorIn) {
                      currentAnimation = animatorIn.start();
                      currentAnimation.done(function() {
                        currentAnimation = null;
                        end();
                        runner.complete();
                      });
                      return currentAnimation;
                    }
                  }
                  end();
                  runner.complete();
                });
                runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                return runner;
                function endFn() {
                  if (currentAnimation) {
                    currentAnimation.end();
                  }
                }
              }};
            function calculateAnchorStyles(anchor) {
              var styles = {};
              var coords = getDomNode(anchor).getBoundingClientRect();
              forEach(['width', 'height', 'top', 'left'], function(key) {
                var value = coords[key];
                switch (key) {
                  case 'top':
                    value += bodyNode.scrollTop;
                    break;
                  case 'left':
                    value += bodyNode.scrollLeft;
                    break;
                }
                styles[key] = Math.floor(value) + 'px';
              });
              return styles;
            }
            function prepareOutAnimation() {
              var animator = $animateCss(clone, {
                addClass: NG_OUT_ANCHOR_CLASS_NAME,
                delay: true,
                from: calculateAnchorStyles(outAnchor)
              });
              return animator.$$willAnimate ? animator : null;
            }
            function getClassVal(element) {
              return element.attr('class') || '';
            }
            function prepareInAnimation() {
              var endingClasses = filterCssClasses(getClassVal(inAnchor));
              var toAdd = getUniqueValues(endingClasses, startingClasses);
              var toRemove = getUniqueValues(startingClasses, endingClasses);
              var animator = $animateCss(clone, {
                to: calculateAnchorStyles(inAnchor),
                addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
                removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
                delay: true
              });
              return animator.$$willAnimate ? animator : null;
            }
            function end() {
              clone.remove();
              outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
              inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
            }
          }
          function prepareFromToAnchorAnimation(from, to, classes, anchors) {
            var fromAnimation = prepareRegularAnimation(from, noop);
            var toAnimation = prepareRegularAnimation(to, noop);
            var anchorAnimations = [];
            forEach(anchors, function(anchor) {
              var outElement = anchor['out'];
              var inElement = anchor['in'];
              var animator = prepareAnchoredAnimation(classes, outElement, inElement);
              if (animator) {
                anchorAnimations.push(animator);
              }
            });
            if (!fromAnimation && !toAnimation && anchorAnimations.length === 0)
              return ;
            return {start: function() {
                var animationRunners = [];
                if (fromAnimation) {
                  animationRunners.push(fromAnimation.start());
                }
                if (toAnimation) {
                  animationRunners.push(toAnimation.start());
                }
                forEach(anchorAnimations, function(animation) {
                  animationRunners.push(animation.start());
                });
                var runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                $$AnimateRunner.all(animationRunners, function(status) {
                  runner.complete(status);
                });
                return runner;
                function endFn() {
                  forEach(animationRunners, function(runner) {
                    runner.end();
                  });
                }
              }};
          }
          function prepareRegularAnimation(animationDetails, onBeforeClassesAppliedCb) {
            var element = animationDetails.element;
            var options = animationDetails.options || {};
            options.$$skipPreparationClasses = true;
            options.skipBlocking = true;
            if (animationDetails.structural) {
              options.event = animationDetails.event;
              if (animationDetails.event === 'leave') {
                options.onDone = options.domOperation;
              }
            }
            onBeforeClassesAppliedCb(element);
            applyAnimationClasses(element, options);
            if (options.preparationClasses) {
              options.event = concatWithSpace(options.event, options.preparationClasses);
            }
            var animator = $animateCss(element, options);
            return animator.$$willAnimate ? animator : null;
          }
        }];
      }];
      var $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {
        this.$get = ['$injector', '$$AnimateRunner', '$$rAFMutex', '$$jqLite', function($injector, $$AnimateRunner, $$rAFMutex, $$jqLite) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function(element, event, classes, options) {
            if (arguments.length === 3 && isObject(classes)) {
              options = classes;
              classes = null;
            }
            options = prepareAnimationOptions(options);
            if (!classes) {
              classes = element.attr('class') || '';
              if (options.addClass) {
                classes += ' ' + options.addClass;
              }
              if (options.removeClass) {
                classes += ' ' + options.removeClass;
              }
            }
            var classesToAdd = options.addClass;
            var classesToRemove = options.removeClass;
            var animations = lookupAnimations(classes);
            var before,
                after;
            if (animations.length) {
              var afterFn,
                  beforeFn;
              if (event == 'leave') {
                beforeFn = 'leave';
                afterFn = 'afterLeave';
              } else {
                beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
                afterFn = event;
              }
              if (event !== 'enter' && event !== 'move') {
                before = packageAnimations(element, event, options, animations, beforeFn);
              }
              after = packageAnimations(element, event, options, animations, afterFn);
            }
            if (!before && !after)
              return ;
            function applyOptions() {
              options.domOperation();
              applyAnimationClasses(element, options);
            }
            return {start: function() {
                var closeActiveAnimations;
                var chain = [];
                if (before) {
                  chain.push(function(fn) {
                    closeActiveAnimations = before(fn);
                  });
                }
                if (chain.length) {
                  chain.push(function(fn) {
                    applyOptions();
                    fn(true);
                  });
                } else {
                  applyOptions();
                }
                if (after) {
                  chain.push(function(fn) {
                    closeActiveAnimations = after(fn);
                  });
                }
                var animationClosed = false;
                var runner = new $$AnimateRunner({
                  end: function() {
                    endAnimations();
                  },
                  cancel: function() {
                    endAnimations(true);
                  }
                });
                $$AnimateRunner.chain(chain, onComplete);
                return runner;
                function onComplete(success) {
                  animationClosed = true;
                  applyOptions();
                  applyAnimationStyles(element, options);
                  runner.complete(success);
                }
                function endAnimations(cancelled) {
                  if (!animationClosed) {
                    (closeActiveAnimations || noop)(cancelled);
                    onComplete(cancelled);
                  }
                }
              }};
            function executeAnimationFn(fn, element, event, options, onDone) {
              var args;
              switch (event) {
                case 'animate':
                  args = [element, options.from, options.to, onDone];
                  break;
                case 'setClass':
                  args = [element, classesToAdd, classesToRemove, onDone];
                  break;
                case 'addClass':
                  args = [element, classesToAdd, onDone];
                  break;
                case 'removeClass':
                  args = [element, classesToRemove, onDone];
                  break;
                default:
                  args = [element, onDone];
                  break;
              }
              args.push(options);
              var value = fn.apply(fn, args);
              if (value) {
                if (isFunction(value.start)) {
                  value = value.start();
                }
                if (value instanceof $$AnimateRunner) {
                  value.done(onDone);
                } else if (isFunction(value)) {
                  return value;
                }
              }
              return noop;
            }
            function groupEventedAnimations(element, event, options, animations, fnName) {
              var operations = [];
              forEach(animations, function(ani) {
                var animation = ani[fnName];
                if (!animation)
                  return ;
                operations.push(function() {
                  var runner;
                  var endProgressCb;
                  var resolved = false;
                  var onAnimationComplete = function(rejected) {
                    if (!resolved) {
                      resolved = true;
                      (endProgressCb || noop)(rejected);
                      runner.complete(!rejected);
                    }
                  };
                  runner = new $$AnimateRunner({
                    end: function() {
                      onAnimationComplete();
                    },
                    cancel: function() {
                      onAnimationComplete(true);
                    }
                  });
                  endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                    var cancelled = result === false;
                    onAnimationComplete(cancelled);
                  });
                  return runner;
                });
              });
              return operations;
            }
            function packageAnimations(element, event, options, animations, fnName) {
              var operations = groupEventedAnimations(element, event, options, animations, fnName);
              if (operations.length === 0) {
                var a,
                    b;
                if (fnName === 'beforeSetClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
                } else if (fnName === 'setClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
                }
                if (a) {
                  operations = operations.concat(a);
                }
                if (b) {
                  operations = operations.concat(b);
                }
              }
              if (operations.length === 0)
                return ;
              return function startAnimation(callback) {
                var runners = [];
                if (operations.length) {
                  forEach(operations, function(animateFn) {
                    runners.push(animateFn());
                  });
                }
                runners.length ? $$AnimateRunner.all(runners, callback) : callback();
                return function endFn(reject) {
                  forEach(runners, function(runner) {
                    reject ? runner.cancel() : runner.end();
                  });
                };
              };
            }
          };
          function lookupAnimations(classes) {
            classes = isArray(classes) ? classes : classes.split(' ');
            var matches = [],
                flagMap = {};
            for (var i = 0; i < classes.length; i++) {
              var klass = classes[i],
                  animationFactory = $animateProvider.$$registeredAnimations[klass];
              if (animationFactory && !flagMap[klass]) {
                matches.push($injector.get(animationFactory));
                flagMap[klass] = true;
              }
            }
            return matches;
          }
        }];
      }];
      var $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateJsDriver');
        this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {
          return function initDriverFn(animationDetails) {
            if (animationDetails.from && animationDetails.to) {
              var fromAnimation = prepareAnimation(animationDetails.from);
              var toAnimation = prepareAnimation(animationDetails.to);
              if (!fromAnimation && !toAnimation)
                return ;
              return {start: function() {
                  var animationRunners = [];
                  if (fromAnimation) {
                    animationRunners.push(fromAnimation.start());
                  }
                  if (toAnimation) {
                    animationRunners.push(toAnimation.start());
                  }
                  $$AnimateRunner.all(animationRunners, done);
                  var runner = new $$AnimateRunner({
                    end: endFnFactory(),
                    cancel: endFnFactory()
                  });
                  return runner;
                  function endFnFactory() {
                    return function() {
                      forEach(animationRunners, function(runner) {
                        runner.end();
                      });
                    };
                  }
                  function done(status) {
                    runner.complete(status);
                  }
                }};
            } else {
              return prepareAnimation(animationDetails);
            }
          };
          function prepareAnimation(animationDetails) {
            var element = animationDetails.element;
            var event = animationDetails.event;
            var options = animationDetails.options;
            var classes = animationDetails.classes;
            return $$animateJs(element, event, classes, options);
          }
        }];
      }];
      var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
      var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
      var $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {
        var PRE_DIGEST_STATE = 1;
        var RUNNING_STATE = 2;
        var rules = this.rules = {
          skip: [],
          cancel: [],
          join: []
        };
        function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
          return rules[ruleType].some(function(fn) {
            return fn(element, currentAnimation, previousAnimation);
          });
        }
        function hasAnimationClasses(options, and) {
          options = options || {};
          var a = (options.addClass || '').length > 0;
          var b = (options.removeClass || '').length > 0;
          return and ? a && b : a || b;
        }
        rules.join.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && hasAnimationClasses(newAnimation.options);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && !hasAnimationClasses(newAnimation.options);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.event == 'leave' && newAnimation.structural;
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          var nO = newAnimation.options;
          var cO = currentAnimation.options;
          return (nO.addClass && nO.addClass === cO.removeClass) || (nO.removeClass && nO.removeClass === cO.addClass);
        });
        this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$body', '$$HashMap', '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow', function($$rAF, $rootScope, $rootElement, $document, $$body, $$HashMap, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow) {
          var activeAnimationsLookup = new $$HashMap();
          var disabledElementsLookup = new $$HashMap();
          var animationsEnabled = null;
          var deregisterWatch = $rootScope.$watch(function() {
            return $templateRequest.totalPendingRequests === 0;
          }, function(isEmpty) {
            if (!isEmpty)
              return ;
            deregisterWatch();
            $rootScope.$$postDigest(function() {
              $rootScope.$$postDigest(function() {
                if (animationsEnabled === null) {
                  animationsEnabled = true;
                }
              });
            });
          });
          var callbackRegistry = {};
          var classNameFilter = $animateProvider.classNameFilter();
          var isAnimatableClassName = !classNameFilter ? function() {
            return true;
          } : function(className) {
            return classNameFilter.test(className);
          };
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function normalizeAnimationOptions(element, options) {
            return mergeAnimationOptions(element, options, {});
          }
          function findCallbacks(element, event) {
            var targetNode = getDomNode(element);
            var matches = [];
            var entries = callbackRegistry[event];
            if (entries) {
              forEach(entries, function(entry) {
                if (entry.node.contains(targetNode)) {
                  matches.push(entry.callback);
                }
              });
            }
            return matches;
          }
          function triggerCallback(event, element, phase, data) {
            $$rAF(function() {
              forEach(findCallbacks(element, event), function(callback) {
                callback(element, phase, data);
              });
            });
          }
          return {
            on: function(event, container, callback) {
              var node = extractElementNode(container);
              callbackRegistry[event] = callbackRegistry[event] || [];
              callbackRegistry[event].push({
                node: node,
                callback: callback
              });
            },
            off: function(event, container, callback) {
              var entries = callbackRegistry[event];
              if (!entries)
                return ;
              callbackRegistry[event] = arguments.length === 1 ? null : filterFromRegistry(entries, container, callback);
              function filterFromRegistry(list, matchContainer, matchCallback) {
                var containerNode = extractElementNode(matchContainer);
                return list.filter(function(entry) {
                  var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
                  return !isMatch;
                });
              }
            },
            pin: function(element, parentElement) {
              assertArg(isElement(element), 'element', 'not an element');
              assertArg(isElement(parentElement), 'parentElement', 'not an element');
              element.data(NG_ANIMATE_PIN_DATA, parentElement);
            },
            push: function(element, event, options, domOperation) {
              options = options || {};
              options.domOperation = domOperation;
              return queueAnimation(element, event, options);
            },
            enabled: function(element, bool) {
              var argCount = arguments.length;
              if (argCount === 0) {
                bool = !!animationsEnabled;
              } else {
                var hasElement = isElement(element);
                if (!hasElement) {
                  bool = animationsEnabled = !!element;
                } else {
                  var node = getDomNode(element);
                  var recordExists = disabledElementsLookup.get(node);
                  if (argCount === 1) {
                    bool = !recordExists;
                  } else {
                    bool = !!bool;
                    if (!bool) {
                      disabledElementsLookup.put(node, true);
                    } else if (recordExists) {
                      disabledElementsLookup.remove(node);
                    }
                  }
                }
              }
              return bool;
            }
          };
          function queueAnimation(element, event, options) {
            var node,
                parent;
            element = stripCommentsFromElement(element);
            if (element) {
              node = getDomNode(element);
              parent = element.parent();
            }
            options = prepareAnimationOptions(options);
            var runner = new $$AnimateRunner();
            if (isArray(options.addClass)) {
              options.addClass = options.addClass.join(' ');
            }
            if (options.addClass && !isString(options.addClass)) {
              options.addClass = null;
            }
            if (isArray(options.removeClass)) {
              options.removeClass = options.removeClass.join(' ');
            }
            if (options.removeClass && !isString(options.removeClass)) {
              options.removeClass = null;
            }
            if (options.from && !isObject(options.from)) {
              options.from = null;
            }
            if (options.to && !isObject(options.to)) {
              options.to = null;
            }
            if (!node) {
              close();
              return runner;
            }
            var className = [node.className, options.addClass, options.removeClass].join(' ');
            if (!isAnimatableClassName(className)) {
              close();
              return runner;
            }
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var skipAnimations = !animationsEnabled || disabledElementsLookup.get(node);
            var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};
            var hasExistingAnimation = !!existingAnimation.state;
            if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {
              skipAnimations = !areAnimationsAllowed(element, parent, event);
            }
            if (skipAnimations) {
              close();
              return runner;
            }
            if (isStructural) {
              closeChildAnimations(element);
            }
            var newAnimation = {
              structural: isStructural,
              element: element,
              event: event,
              close: close,
              options: options,
              runner: runner
            };
            if (hasExistingAnimation) {
              var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);
              if (skipAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  close();
                  return runner;
                } else {
                  mergeAnimationOptions(element, existingAnimation.options, options);
                  return existingAnimation.runner;
                }
              }
              var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);
              if (cancelAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  existingAnimation.runner.end();
                } else if (existingAnimation.structural) {
                  existingAnimation.close();
                } else {
                  mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);
                  return existingAnimation.runner;
                }
              } else {
                var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);
                if (joinAnimationFlag) {
                  if (existingAnimation.state === RUNNING_STATE) {
                    normalizeAnimationOptions(element, options);
                  } else {
                    applyGeneratedPreparationClasses(element, isStructural ? event : null, options);
                    event = newAnimation.event = existingAnimation.event;
                    options = mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);
                    return existingAnimation.runner;
                  }
                }
              }
            } else {
              normalizeAnimationOptions(element, options);
            }
            var isValidAnimation = newAnimation.structural;
            if (!isValidAnimation) {
              isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0) || hasAnimationClasses(newAnimation.options);
            }
            if (!isValidAnimation) {
              close();
              clearElementAnimationState(element);
              return runner;
            }
            applyGeneratedPreparationClasses(element, isStructural ? event : null, options);
            blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
            var counter = (existingAnimation.counter || 0) + 1;
            newAnimation.counter = counter;
            markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);
            $rootScope.$$postDigest(function() {
              var animationDetails = activeAnimationsLookup.get(node);
              var animationCancelled = !animationDetails;
              animationDetails = animationDetails || {};
              var parentElement = element.parent() || [];
              var isValidAnimation = parentElement.length > 0 && (animationDetails.event === 'animate' || animationDetails.structural || hasAnimationClasses(animationDetails.options));
              if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
                if (animationCancelled) {
                  applyAnimationClasses(element, options);
                  applyAnimationStyles(element, options);
                }
                if (animationCancelled || (isStructural && animationDetails.event !== event)) {
                  options.domOperation();
                  runner.end();
                }
                if (!isValidAnimation) {
                  clearElementAnimationState(element);
                }
                return ;
              }
              event = !animationDetails.structural && hasAnimationClasses(animationDetails.options, true) ? 'setClass' : animationDetails.event;
              markElementAnimationState(element, RUNNING_STATE);
              var realRunner = $$animation(element, event, animationDetails.options, function(e) {
                $$forceReflow();
                blockTransitions(getDomNode(e), false);
              });
              realRunner.done(function(status) {
                close(!status);
                var animationDetails = activeAnimationsLookup.get(node);
                if (animationDetails && animationDetails.counter === counter) {
                  clearElementAnimationState(getDomNode(element));
                }
                notifyProgress(runner, event, 'close', {});
              });
              runner.setHost(realRunner);
              notifyProgress(runner, event, 'start', {});
            });
            return runner;
            function notifyProgress(runner, event, phase, data) {
              triggerCallback(event, element, phase, data);
              runner.progress(event, phase, data);
            }
            function close(reject) {
              clearGeneratedClasses(element, options);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              runner.complete(!reject);
            }
          }
          function closeChildAnimations(element) {
            var node = getDomNode(element);
            var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
            forEach(children, function(child) {
              var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));
              var animationDetails = activeAnimationsLookup.get(child);
              switch (state) {
                case RUNNING_STATE:
                  animationDetails.runner.end();
                case PRE_DIGEST_STATE:
                  if (animationDetails) {
                    activeAnimationsLookup.remove(child);
                  }
                  break;
              }
            });
          }
          function clearElementAnimationState(element) {
            var node = getDomNode(element);
            node.removeAttribute(NG_ANIMATE_ATTR_NAME);
            activeAnimationsLookup.remove(node);
          }
          function isMatchingElement(nodeOrElmA, nodeOrElmB) {
            return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
          }
          function areAnimationsAllowed(element, parentElement, event) {
            var bodyElementDetected = isMatchingElement(element, $$body) || element[0].nodeName === 'HTML';
            var rootElementDetected = isMatchingElement(element, $rootElement);
            var parentAnimationDetected = false;
            var animateChildren;
            var parentHost = element.data(NG_ANIMATE_PIN_DATA);
            if (parentHost) {
              parentElement = parentHost;
            }
            while (parentElement && parentElement.length) {
              if (!rootElementDetected) {
                rootElementDetected = isMatchingElement(parentElement, $rootElement);
              }
              var parentNode = parentElement[0];
              if (parentNode.nodeType !== ELEMENT_NODE) {
                break;
              }
              var details = activeAnimationsLookup.get(parentNode) || {};
              if (!parentAnimationDetected) {
                parentAnimationDetected = details.structural || disabledElementsLookup.get(parentNode);
              }
              if (isUndefined(animateChildren) || animateChildren === true) {
                var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);
                if (isDefined(value)) {
                  animateChildren = value;
                }
              }
              if (parentAnimationDetected && animateChildren === false)
                break;
              if (!rootElementDetected) {
                rootElementDetected = isMatchingElement(parentElement, $rootElement);
                if (!rootElementDetected) {
                  parentHost = parentElement.data(NG_ANIMATE_PIN_DATA);
                  if (parentHost) {
                    parentElement = parentHost;
                  }
                }
              }
              if (!bodyElementDetected) {
                bodyElementDetected = isMatchingElement(parentElement, $$body);
              }
              parentElement = parentElement.parent();
            }
            var allowAnimation = !parentAnimationDetected || animateChildren;
            return allowAnimation && rootElementDetected && bodyElementDetected;
          }
          function markElementAnimationState(element, state, details) {
            details = details || {};
            details.state = state;
            var node = getDomNode(element);
            node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
            var oldValue = activeAnimationsLookup.get(node);
            var newValue = oldValue ? extend(oldValue, details) : details;
            activeAnimationsLookup.put(node, newValue);
          }
        }];
      }];
      var $$rAFMutexFactory = ['$$rAF', function($$rAF) {
        return function() {
          var passed = false;
          $$rAF(function() {
            passed = true;
          });
          return function(fn) {
            passed ? fn() : $$rAF(fn);
          };
        };
      }];
      var $$AnimateRunnerFactory = ['$q', '$$rAFMutex', function($q, $$rAFMutex) {
        var INITIAL_STATE = 0;
        var DONE_PENDING_STATE = 1;
        var DONE_COMPLETE_STATE = 2;
        AnimateRunner.chain = function(chain, callback) {
          var index = 0;
          next();
          function next() {
            if (index === chain.length) {
              callback(true);
              return ;
            }
            chain[index](function(response) {
              if (response === false) {
                callback(false);
                return ;
              }
              index++;
              next();
            });
          }
        };
        AnimateRunner.all = function(runners, callback) {
          var count = 0;
          var status = true;
          forEach(runners, function(runner) {
            runner.done(onProgress);
          });
          function onProgress(response) {
            status = status && response;
            if (++count === runners.length) {
              callback(status);
            }
          }
        };
        function AnimateRunner(host) {
          this.setHost(host);
          this._doneCallbacks = [];
          this._runInAnimationFrame = $$rAFMutex();
          this._state = 0;
        }
        AnimateRunner.prototype = {
          setHost: function(host) {
            this.host = host || {};
          },
          done: function(fn) {
            if (this._state === DONE_COMPLETE_STATE) {
              fn();
            } else {
              this._doneCallbacks.push(fn);
            }
          },
          progress: noop,
          getPromise: function() {
            if (!this.promise) {
              var self = this;
              this.promise = $q(function(resolve, reject) {
                self.done(function(status) {
                  status === false ? reject() : resolve();
                });
              });
            }
            return this.promise;
          },
          then: function(resolveHandler, rejectHandler) {
            return this.getPromise().then(resolveHandler, rejectHandler);
          },
          'catch': function(handler) {
            return this.getPromise()['catch'](handler);
          },
          'finally': function(handler) {
            return this.getPromise()['finally'](handler);
          },
          pause: function() {
            if (this.host.pause) {
              this.host.pause();
            }
          },
          resume: function() {
            if (this.host.resume) {
              this.host.resume();
            }
          },
          end: function() {
            if (this.host.end) {
              this.host.end();
            }
            this._resolve(true);
          },
          cancel: function() {
            if (this.host.cancel) {
              this.host.cancel();
            }
            this._resolve(false);
          },
          complete: function(response) {
            var self = this;
            if (self._state === INITIAL_STATE) {
              self._state = DONE_PENDING_STATE;
              self._runInAnimationFrame(function() {
                self._resolve(response);
              });
            }
          },
          _resolve: function(response) {
            if (this._state !== DONE_COMPLETE_STATE) {
              forEach(this._doneCallbacks, function(fn) {
                fn(response);
              });
              this._doneCallbacks.length = 0;
              this._state = DONE_COMPLETE_STATE;
            }
          }
        };
        return AnimateRunner;
      }];
      var $$AnimationProvider = ['$animateProvider', function($animateProvider) {
        var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';
        var drivers = this.drivers = [];
        var RUNNER_STORAGE_KEY = '$$animationRunner';
        function setRunner(element, runner) {
          element.data(RUNNER_STORAGE_KEY, runner);
        }
        function removeRunner(element) {
          element.removeData(RUNNER_STORAGE_KEY);
        }
        function getRunner(element) {
          return element.data(RUNNER_STORAGE_KEY);
        }
        this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$HashMap) {
          var animationQueue = [];
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function sortAnimations(animations) {
            var tree = {children: []};
            var i,
                lookup = new $$HashMap();
            for (i = 0; i < animations.length; i++) {
              var animation = animations[i];
              lookup.put(animation.domNode, animations[i] = {
                domNode: animation.domNode,
                fn: animation.fn,
                children: []
              });
            }
            for (i = 0; i < animations.length; i++) {
              processNode(animations[i]);
            }
            return flatten(tree);
            function processNode(entry) {
              if (entry.processed)
                return entry;
              entry.processed = true;
              var elementNode = entry.domNode;
              var parentNode = elementNode.parentNode;
              lookup.put(elementNode, entry);
              var parentEntry;
              while (parentNode) {
                parentEntry = lookup.get(parentNode);
                if (parentEntry) {
                  if (!parentEntry.processed) {
                    parentEntry = processNode(parentEntry);
                  }
                  break;
                }
                parentNode = parentNode.parentNode;
              }
              (parentEntry || tree).children.push(entry);
              return entry;
            }
            function flatten(tree) {
              var result = [];
              var queue = [];
              var i;
              for (i = 0; i < tree.children.length; i++) {
                queue.push(tree.children[i]);
              }
              var remainingLevelEntries = queue.length;
              var nextLevelEntries = 0;
              var row = [];
              for (i = 0; i < queue.length; i++) {
                var entry = queue[i];
                if (remainingLevelEntries <= 0) {
                  remainingLevelEntries = nextLevelEntries;
                  nextLevelEntries = 0;
                  result = result.concat(row);
                  row = [];
                }
                row.push(entry.fn);
                forEach(entry.children, function(childEntry) {
                  nextLevelEntries++;
                  queue.push(childEntry);
                });
                remainingLevelEntries--;
              }
              if (row.length) {
                result = result.concat(row);
              }
              return result;
            }
          }
          return function(element, event, options, onBeforeClassesAppliedCb) {
            options = prepareAnimationOptions(options);
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var runner = new $$AnimateRunner({
              end: function() {
                close();
              },
              cancel: function() {
                close(true);
              }
            });
            if (!drivers.length) {
              close();
              return runner;
            }
            setRunner(element, runner);
            var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
            var tempClasses = options.tempClasses;
            if (tempClasses) {
              classes += ' ' + tempClasses;
              options.tempClasses = null;
            }
            animationQueue.push({
              element: element,
              classes: classes,
              event: event,
              structural: isStructural,
              options: options,
              beforeStart: beforeStart,
              close: close
            });
            element.on('$destroy', handleDestroyedElement);
            if (animationQueue.length > 1)
              return runner;
            $rootScope.$$postDigest(function() {
              var animations = [];
              forEach(animationQueue, function(entry) {
                var elm = entry.element;
                if (getRunner(elm) && getDomNode(elm).parentNode) {
                  animations.push(entry);
                } else {
                  entry.close();
                }
              });
              animationQueue.length = 0;
              var groupedAnimations = groupAnimations(animations);
              var toBeSortedAnimations = [];
              forEach(groupedAnimations, function(animationEntry) {
                toBeSortedAnimations.push({
                  domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                  fn: function triggerAnimationStart() {
                    animationEntry.beforeStart();
                    var startAnimationFn,
                        closeFn = animationEntry.close;
                    var targetElement = animationEntry.anchors ? (animationEntry.from.element || animationEntry.to.element) : animationEntry.element;
                    if (getRunner(targetElement)) {
                      var operation = invokeFirstDriver(animationEntry, onBeforeClassesAppliedCb);
                      if (operation) {
                        startAnimationFn = operation.start;
                      }
                    }
                    if (!startAnimationFn) {
                      closeFn();
                    } else {
                      var animationRunner = startAnimationFn();
                      animationRunner.done(function(status) {
                        closeFn(!status);
                      });
                      updateAnimationRunners(animationEntry, animationRunner);
                    }
                  }
                });
              });
              forEach(sortAnimations(toBeSortedAnimations), function(triggerAnimation) {
                triggerAnimation();
              });
            });
            return runner;
            function getAnchorNodes(node) {
              var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
              var items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [node] : node.querySelectorAll(SELECTOR);
              var anchors = [];
              forEach(items, function(node) {
                var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                if (attr && attr.length) {
                  anchors.push(node);
                }
              });
              return anchors;
            }
            function groupAnimations(animations) {
              var preparedAnimations = [];
              var refLookup = {};
              forEach(animations, function(animation, index) {
                var element = animation.element;
                var node = getDomNode(element);
                var event = animation.event;
                var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;
                var anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                if (anchorNodes.length) {
                  var direction = enterOrMove ? 'to' : 'from';
                  forEach(anchorNodes, function(anchor) {
                    var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                    refLookup[key] = refLookup[key] || {};
                    refLookup[key][direction] = {
                      animationID: index,
                      element: jqLite(anchor)
                    };
                  });
                } else {
                  preparedAnimations.push(animation);
                }
              });
              var usedIndicesLookup = {};
              var anchorGroups = {};
              forEach(refLookup, function(operations, key) {
                var from = operations.from;
                var to = operations.to;
                if (!from || !to) {
                  var index = from ? from.animationID : to.animationID;
                  var indexKey = index.toString();
                  if (!usedIndicesLookup[indexKey]) {
                    usedIndicesLookup[indexKey] = true;
                    preparedAnimations.push(animations[index]);
                  }
                  return ;
                }
                var fromAnimation = animations[from.animationID];
                var toAnimation = animations[to.animationID];
                var lookupKey = from.animationID.toString();
                if (!anchorGroups[lookupKey]) {
                  var group = anchorGroups[lookupKey] = {
                    beforeStart: function() {
                      fromAnimation.beforeStart();
                      toAnimation.beforeStart();
                    },
                    close: function() {
                      fromAnimation.close();
                      toAnimation.close();
                    },
                    classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                    from: fromAnimation,
                    to: toAnimation,
                    anchors: []
                  };
                  if (group.classes.length) {
                    preparedAnimations.push(group);
                  } else {
                    preparedAnimations.push(fromAnimation);
                    preparedAnimations.push(toAnimation);
                  }
                }
                anchorGroups[lookupKey].anchors.push({
                  'out': from.element,
                  'in': to.element
                });
              });
              return preparedAnimations;
            }
            function cssClassesIntersection(a, b) {
              a = a.split(' ');
              b = b.split(' ');
              var matches = [];
              for (var i = 0; i < a.length; i++) {
                var aa = a[i];
                if (aa.substring(0, 3) === 'ng-')
                  continue;
                for (var j = 0; j < b.length; j++) {
                  if (aa === b[j]) {
                    matches.push(aa);
                    break;
                  }
                }
              }
              return matches.join(' ');
            }
            function invokeFirstDriver(animationDetails, onBeforeClassesAppliedCb) {
              for (var i = drivers.length - 1; i >= 0; i--) {
                var driverName = drivers[i];
                if (!$injector.has(driverName))
                  continue;
                var factory = $injector.get(driverName);
                var driver = factory(animationDetails, onBeforeClassesAppliedCb);
                if (driver) {
                  return driver;
                }
              }
            }
            function beforeStart() {
              element.addClass(NG_ANIMATE_CLASSNAME);
              if (tempClasses) {
                $$jqLite.addClass(element, tempClasses);
              }
            }
            function updateAnimationRunners(animation, newRunner) {
              if (animation.from && animation.to) {
                update(animation.from.element);
                update(animation.to.element);
              } else {
                update(animation.element);
              }
              function update(element) {
                getRunner(element).setHost(newRunner);
              }
            }
            function handleDestroyedElement() {
              var runner = getRunner(element);
              if (runner && (event !== 'leave' || !options.$$domOperationFired)) {
                runner.end();
              }
            }
            function close(rejected) {
              element.off('$destroy', handleDestroyedElement);
              removeRunner(element);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              if (tempClasses) {
                $$jqLite.removeClass(element, tempClasses);
              }
              element.removeClass(NG_ANIMATE_CLASSNAME);
              runner.complete(!rejected);
            }
          };
        }];
      }];
      angular.module('ngAnimate', []).provider('$$body', $$BodyProvider).directive('ngAnimateChildren', $$AnimateChildrenDirective).factory('$$rAFMutex', $$rAFMutexFactory).factory('$$AnimateRunner', $$AnimateRunnerFactory).provider('$$animateQueue', $$AnimateQueueProvider).provider('$$animation', $$AnimationProvider).provider('$animateCss', $AnimateCssProvider).provider('$$animateCssDriver', $$AnimateCssDriverProvider).provider('$$animateJs', $$AnimateJsProvider).provider('$$animateJsDriver', $$AnimateJsDriverProvider);
    })(window, window.angular);
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, false);
});

System.register("github:angular/bower-angular-sanitize@1.4.4/angular-sanitize", ["github:angular/bower-angular@1.4.4"], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, ["github:angular/bower-angular@1.4.4"]);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular, undefined) {
      'use strict';
      var $sanitizeMinErr = angular.$$minErr('$sanitize');
      function $SanitizeProvider() {
        this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
          return function(html) {
            var buf = [];
            htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
              return !/^unsafe/.test($$sanitizeUri(uri, isImage));
            }));
            return buf.join('');
          };
        }];
      }
      function sanitizeText(chars) {
        var buf = [];
        var writer = htmlSanitizeWriter(buf, angular.noop);
        writer.chars(chars);
        return buf.join('');
      }
      var START_TAG_REGEXP = /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/,
          END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/,
          ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,
          BEGIN_TAG_REGEXP = /^</,
          BEGING_END_TAGE_REGEXP = /^<\//,
          COMMENT_REGEXP = /<!--(.*?)-->/g,
          DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,
          CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g,
          SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
          NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;
      var voidElements = makeMap("area,br,col,hr,img,wbr");
      var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
          optionalEndTagInlineElements = makeMap("rp,rt"),
          optionalEndTagElements = angular.extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);
      var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," + "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," + "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));
      var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," + "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," + "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
      var svgElements = makeMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," + "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," + "radialGradient,rect,stop,svg,switch,text,title,tspan,use");
      var specialElements = makeMap("script,style");
      var validElements = angular.extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements, svgElements);
      var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href");
      var htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' + 'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' + 'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' + 'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' + 'valign,value,vspace,width');
      var svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' + 'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' + 'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' + 'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' + 'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' + 'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' + 'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' + 'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' + 'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' + 'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' + 'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' + 'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' + 'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' + 'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' + 'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);
      var validAttrs = angular.extend({}, uriAttrs, svgAttrs, htmlAttrs);
      function makeMap(str, lowercaseKeys) {
        var obj = {},
            items = str.split(','),
            i;
        for (i = 0; i < items.length; i++) {
          obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;
        }
        return obj;
      }
      function htmlParser(html, handler) {
        if (typeof html !== 'string') {
          if (html === null || typeof html === 'undefined') {
            html = '';
          } else {
            html = '' + html;
          }
        }
        var index,
            chars,
            match,
            stack = [],
            last = html,
            text;
        stack.last = function() {
          return stack[stack.length - 1];
        };
        while (html) {
          text = '';
          chars = true;
          if (!stack.last() || !specialElements[stack.last()]) {
            if (html.indexOf("<!--") === 0) {
              index = html.indexOf("--", 4);
              if (index >= 0 && html.lastIndexOf("-->", index) === index) {
                if (handler.comment)
                  handler.comment(html.substring(4, index));
                html = html.substring(index + 3);
                chars = false;
              }
            } else if (DOCTYPE_REGEXP.test(html)) {
              match = html.match(DOCTYPE_REGEXP);
              if (match) {
                html = html.replace(match[0], '');
                chars = false;
              }
            } else if (BEGING_END_TAGE_REGEXP.test(html)) {
              match = html.match(END_TAG_REGEXP);
              if (match) {
                html = html.substring(match[0].length);
                match[0].replace(END_TAG_REGEXP, parseEndTag);
                chars = false;
              }
            } else if (BEGIN_TAG_REGEXP.test(html)) {
              match = html.match(START_TAG_REGEXP);
              if (match) {
                if (match[4]) {
                  html = html.substring(match[0].length);
                  match[0].replace(START_TAG_REGEXP, parseStartTag);
                }
                chars = false;
              } else {
                text += '<';
                html = html.substring(1);
              }
            }
            if (chars) {
              index = html.indexOf("<");
              text += index < 0 ? html : html.substring(0, index);
              html = index < 0 ? "" : html.substring(index);
              if (handler.chars)
                handler.chars(decodeEntities(text));
            }
          } else {
            html = html.replace(new RegExp("([\\W\\w]*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", 'i'), function(all, text) {
              text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");
              if (handler.chars)
                handler.chars(decodeEntities(text));
              return "";
            });
            parseEndTag("", stack.last());
          }
          if (html == last) {
            throw $sanitizeMinErr('badparse', "The sanitizer was unable to parse the following block " + "of html: {0}", html);
          }
          last = html;
        }
        parseEndTag();
        function parseStartTag(tag, tagName, rest, unary) {
          tagName = angular.lowercase(tagName);
          if (blockElements[tagName]) {
            while (stack.last() && inlineElements[stack.last()]) {
              parseEndTag("", stack.last());
            }
          }
          if (optionalEndTagElements[tagName] && stack.last() == tagName) {
            parseEndTag("", tagName);
          }
          unary = voidElements[tagName] || !!unary;
          if (!unary) {
            stack.push(tagName);
          }
          var attrs = {};
          rest.replace(ATTR_REGEXP, function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
            var value = doubleQuotedValue || singleQuotedValue || unquotedValue || '';
            attrs[name] = decodeEntities(value);
          });
          if (handler.start)
            handler.start(tagName, attrs, unary);
        }
        function parseEndTag(tag, tagName) {
          var pos = 0,
              i;
          tagName = angular.lowercase(tagName);
          if (tagName) {
            for (pos = stack.length - 1; pos >= 0; pos--) {
              if (stack[pos] == tagName)
                break;
            }
          }
          if (pos >= 0) {
            for (i = stack.length - 1; i >= pos; i--)
              if (handler.end)
                handler.end(stack[i]);
            stack.length = pos;
          }
        }
      }
      var hiddenPre = document.createElement("pre");
      function decodeEntities(value) {
        if (!value) {
          return '';
        }
        hiddenPre.innerHTML = value.replace(/</g, "&lt;");
        return hiddenPre.textContent;
      }
      function encodeEntities(value) {
        return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function(value) {
          var hi = value.charCodeAt(0);
          var low = value.charCodeAt(1);
          return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
        }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
          return '&#' + value.charCodeAt(0) + ';';
        }).replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }
      function htmlSanitizeWriter(buf, uriValidator) {
        var ignore = false;
        var out = angular.bind(buf, buf.push);
        return {
          start: function(tag, attrs, unary) {
            tag = angular.lowercase(tag);
            if (!ignore && specialElements[tag]) {
              ignore = tag;
            }
            if (!ignore && validElements[tag] === true) {
              out('<');
              out(tag);
              angular.forEach(attrs, function(value, key) {
                var lkey = angular.lowercase(key);
                var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
                if (validAttrs[lkey] === true && (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                  out(' ');
                  out(key);
                  out('="');
                  out(encodeEntities(value));
                  out('"');
                }
              });
              out(unary ? '/>' : '>');
            }
          },
          end: function(tag) {
            tag = angular.lowercase(tag);
            if (!ignore && validElements[tag] === true) {
              out('</');
              out(tag);
              out('>');
            }
            if (tag == ignore) {
              ignore = false;
            }
          },
          chars: function(chars) {
            if (!ignore) {
              out(encodeEntities(chars));
            }
          }
        };
      }
      angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);
      angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
            MAILTO_REGEXP = /^mailto:/i;
        return function(text, target) {
          if (!text)
            return text;
          var match;
          var raw = text;
          var html = [];
          var url;
          var i;
          while ((match = raw.match(LINKY_URL_REGEXP))) {
            url = match[0];
            if (!match[2] && !match[4]) {
              url = (match[3] ? 'http://' : 'mailto:') + url;
            }
            i = match.index;
            addText(raw.substr(0, i));
            addLink(url, match[0].replace(MAILTO_REGEXP, ''));
            raw = raw.substring(i + match[0].length);
          }
          addText(raw);
          return $sanitize(html.join(''));
          function addText(text) {
            if (!text) {
              return ;
            }
            html.push(sanitizeText(text));
          }
          function addLink(url, text) {
            html.push('<a ');
            if (angular.isDefined(target)) {
              html.push('target="', target, '" ');
            }
            html.push('href="', url.replace(/"/g, '&quot;'), '">');
            addText(text);
            html.push('</a>');
          }
        };
      }]);
    })(window, window.angular);
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, false);
});

System.register("github:angular-ui/ui-router@0.2.13/angular-ui-router", ["github:angular/bower-angular@1.4.4"], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, ["github:angular/bower-angular@1.4.4"]);
  (function() {
    "format global";
    "deps angular";
    if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
      module.exports = 'ui.router';
    }
    (function(window, angular, undefined) {
      'use strict';
      var isDefined = angular.isDefined,
          isFunction = angular.isFunction,
          isString = angular.isString,
          isObject = angular.isObject,
          isArray = angular.isArray,
          forEach = angular.forEach,
          extend = angular.extend,
          copy = angular.copy;
      function inherit(parent, extra) {
        return extend(new (extend(function() {}, {prototype: parent}))(), extra);
      }
      function merge(dst) {
        forEach(arguments, function(obj) {
          if (obj !== dst) {
            forEach(obj, function(value, key) {
              if (!dst.hasOwnProperty(key))
                dst[key] = value;
            });
          }
        });
        return dst;
      }
      function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
          if (first.path[n] !== second.path[n])
            break;
          path.push(first.path[n]);
        }
        return path;
      }
      function objectKeys(object) {
        if (Object.keys) {
          return Object.keys(object);
        }
        var result = [];
        angular.forEach(object, function(val, key) {
          result.push(key);
        });
        return result;
      }
      function indexOf(array, value) {
        if (Array.prototype.indexOf) {
          return array.indexOf(value, Number(arguments[2]) || 0);
        }
        var len = array.length >>> 0,
            from = Number(arguments[2]) || 0;
        from = (from < 0) ? Math.ceil(from) : Math.floor(from);
        if (from < 0)
          from += len;
        for (; from < len; from++) {
          if (from in array && array[from] === value)
            return from;
        }
        return -1;
      }
      function inheritParams(currentParams, newParams, $current, $to) {
        var parents = ancestors($current, $to),
            parentParams,
            inherited = {},
            inheritList = [];
        for (var i in parents) {
          if (!parents[i].params)
            continue;
          parentParams = objectKeys(parents[i].params);
          if (!parentParams.length)
            continue;
          for (var j in parentParams) {
            if (indexOf(inheritList, parentParams[j]) >= 0)
              continue;
            inheritList.push(parentParams[j]);
            inherited[parentParams[j]] = currentParams[parentParams[j]];
          }
        }
        return extend({}, inherited, newParams);
      }
      function equalForKeys(a, b, keys) {
        if (!keys) {
          keys = [];
          for (var n in a)
            keys.push(n);
        }
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          if (a[k] != b[k])
            return false;
        }
        return true;
      }
      function filterByKeys(keys, values) {
        var filtered = {};
        forEach(keys, function(name) {
          filtered[name] = values[name];
        });
        return filtered;
      }
      function indexBy(array, propName) {
        var result = {};
        forEach(array, function(item) {
          result[item[propName]] = item;
        });
        return result;
      }
      function pick(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        forEach(keys, function(key) {
          if (key in obj)
            copy[key] = obj[key];
        });
        return copy;
      }
      function omit(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var key in obj) {
          if (indexOf(keys, key) == -1)
            copy[key] = obj[key];
        }
        return copy;
      }
      function pluck(collection, key) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
          result[i] = isFunction(key) ? key(val) : val[key];
        });
        return result;
      }
      function filter(collection, callback) {
        var array = isArray(collection);
        var result = array ? [] : {};
        forEach(collection, function(val, i) {
          if (callback(val, i)) {
            result[array ? result.length : i] = val;
          }
        });
        return result;
      }
      function map(collection, callback) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
          result[i] = callback(val, i);
        });
        return result;
      }
      angular.module('ui.router.util', ['ng']);
      angular.module('ui.router.router', ['ui.router.util']);
      angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);
      angular.module('ui.router', ['ui.router.state']);
      angular.module('ui.router.compat', ['ui.router']);
      $Resolve.$inject = ['$q', '$injector'];
      function $Resolve($q, $injector) {
        var VISIT_IN_PROGRESS = 1,
            VISIT_DONE = 2,
            NOTHING = {},
            NO_DEPENDENCIES = [],
            NO_LOCALS = NOTHING,
            NO_PARENT = extend($q.when(NOTHING), {
              $$promises: NOTHING,
              $$values: NOTHING
            });
        this.study = function(invocables) {
          if (!isObject(invocables))
            throw new Error("'invocables' must be an object");
          var invocableKeys = objectKeys(invocables || {});
          var plan = [],
              cycle = [],
              visited = {};
          function visit(value, key) {
            if (visited[key] === VISIT_DONE)
              return ;
            cycle.push(key);
            if (visited[key] === VISIT_IN_PROGRESS) {
              cycle.splice(0, indexOf(cycle, key));
              throw new Error("Cyclic dependency: " + cycle.join(" -> "));
            }
            visited[key] = VISIT_IN_PROGRESS;
            if (isString(value)) {
              plan.push(key, [function() {
                return $injector.get(value);
              }], NO_DEPENDENCIES);
            } else {
              var params = $injector.annotate(value);
              forEach(params, function(param) {
                if (param !== key && invocables.hasOwnProperty(param))
                  visit(invocables[param], param);
              });
              plan.push(key, value, params);
            }
            cycle.pop();
            visited[key] = VISIT_DONE;
          }
          forEach(invocables, visit);
          invocables = cycle = visited = null;
          function isResolve(value) {
            return isObject(value) && value.then && value.$$promises;
          }
          return function(locals, parent, self) {
            if (isResolve(locals) && self === undefined) {
              self = parent;
              parent = locals;
              locals = null;
            }
            if (!locals)
              locals = NO_LOCALS;
            else if (!isObject(locals)) {
              throw new Error("'locals' must be an object");
            }
            if (!parent)
              parent = NO_PARENT;
            else if (!isResolve(parent)) {
              throw new Error("'parent' must be a promise returned by $resolve.resolve()");
            }
            var resolution = $q.defer(),
                result = resolution.promise,
                promises = result.$$promises = {},
                values = extend({}, locals),
                wait = 1 + plan.length / 3,
                merged = false;
            function done() {
              if (!--wait) {
                if (!merged)
                  merge(values, parent.$$values);
                result.$$values = values;
                result.$$promises = result.$$promises || true;
                delete result.$$inheritedValues;
                resolution.resolve(values);
              }
            }
            function fail(reason) {
              result.$$failure = reason;
              resolution.reject(reason);
            }
            if (isDefined(parent.$$failure)) {
              fail(parent.$$failure);
              return result;
            }
            if (parent.$$inheritedValues) {
              merge(values, omit(parent.$$inheritedValues, invocableKeys));
            }
            extend(promises, parent.$$promises);
            if (parent.$$values) {
              merged = merge(values, omit(parent.$$values, invocableKeys));
              result.$$inheritedValues = omit(parent.$$values, invocableKeys);
              done();
            } else {
              if (parent.$$inheritedValues) {
                result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
              }
              parent.then(done, fail);
            }
            for (var i = 0,
                ii = plan.length; i < ii; i += 3) {
              if (locals.hasOwnProperty(plan[i]))
                done();
              else
                invoke(plan[i], plan[i + 1], plan[i + 2]);
            }
            function invoke(key, invocable, params) {
              var invocation = $q.defer(),
                  waitParams = 0;
              function onfailure(reason) {
                invocation.reject(reason);
                fail(reason);
              }
              forEach(params, function(dep) {
                if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                  waitParams++;
                  promises[dep].then(function(result) {
                    values[dep] = result;
                    if (!(--waitParams))
                      proceed();
                  }, onfailure);
                }
              });
              if (!waitParams)
                proceed();
              function proceed() {
                if (isDefined(result.$$failure))
                  return ;
                try {
                  invocation.resolve($injector.invoke(invocable, self, values));
                  invocation.promise.then(function(result) {
                    values[key] = result;
                    done();
                  }, onfailure);
                } catch (e) {
                  onfailure(e);
                }
              }
              promises[key] = invocation.promise;
            }
            return result;
          };
        };
        this.resolve = function(invocables, locals, parent, self) {
          return this.study(invocables)(locals, parent, self);
        };
      }
      angular.module('ui.router.util').service('$resolve', $Resolve);
      $TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
      function $TemplateFactory($http, $templateCache, $injector) {
        this.fromConfig = function(config, params, locals) {
          return (isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null);
        };
        this.fromString = function(template, params) {
          return isFunction(template) ? template(params) : template;
        };
        this.fromUrl = function(url, params) {
          if (isFunction(url))
            url = url(params);
          if (url == null)
            return null;
          else
            return $http.get(url, {
              cache: $templateCache,
              headers: {Accept: 'text/html'}
            }).then(function(response) {
              return response.data;
            });
        };
        this.fromProvider = function(provider, params, locals) {
          return $injector.invoke(provider, null, locals || {params: params});
        };
      }
      angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);
      var $$UMFP;
      function UrlMatcher(pattern, config, parentMatcher) {
        config = extend({params: {}}, isObject(config) ? config : {});
        var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            searchPlaceholder = /([:]?)([\w\[\]-]+)|\{([\w\[\]-]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            compiled = '^',
            last = 0,
            m,
            segments = this.segments = [],
            parentParams = parentMatcher ? parentMatcher.params : {},
            params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),
            paramNames = [];
        function addParameter(id, type, config, location) {
          paramNames.push(id);
          if (parentParams[id])
            return parentParams[id];
          if (!/^\w+(-+\w+)*(?:\[\])?$/.test(id))
            throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
          if (params[id])
            throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
          params[id] = new $$UMFP.Param(id, type, config, location);
          return params[id];
        }
        function quoteRegExp(string, pattern, squash) {
          var surroundPattern = ['', ''],
              result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
          if (!pattern)
            return result;
          switch (squash) {
            case false:
              surroundPattern = ['(', ')'];
              break;
            case true:
              surroundPattern = ['?(', ')?'];
              break;
            default:
              surroundPattern = ['(' + squash + "|", ')?'];
              break;
          }
          return result + surroundPattern[0] + pattern + surroundPattern[1];
        }
        this.source = pattern;
        function matchDetails(m, isSearch) {
          var id,
              regexp,
              segment,
              type,
              cfg,
              arrayMode;
          id = m[2] || m[3];
          cfg = config.params[id];
          segment = pattern.substring(last, m.index);
          regexp = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);
          type = $$UMFP.type(regexp || "string") || inherit($$UMFP.type("string"), {pattern: new RegExp(regexp)});
          return {
            id: id,
            regexp: regexp,
            segment: segment,
            type: type,
            cfg: cfg
          };
        }
        var p,
            param,
            segment;
        while ((m = placeholder.exec(pattern))) {
          p = matchDetails(m, false);
          if (p.segment.indexOf('?') >= 0)
            break;
          param = addParameter(p.id, p.type, p.cfg, "path");
          compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash);
          segments.push(p.segment);
          last = placeholder.lastIndex;
        }
        segment = pattern.substring(last);
        var i = segment.indexOf('?');
        if (i >= 0) {
          var search = this.sourceSearch = segment.substring(i);
          segment = segment.substring(0, i);
          this.sourcePath = pattern.substring(0, last + i);
          if (search.length > 0) {
            last = 0;
            while ((m = searchPlaceholder.exec(search))) {
              p = matchDetails(m, true);
              param = addParameter(p.id, p.type, p.cfg, "search");
              last = placeholder.lastIndex;
            }
          }
        } else {
          this.sourcePath = pattern;
          this.sourceSearch = '';
        }
        compiled += quoteRegExp(segment) + (config.strict === false ? '\/?' : '') + '$';
        segments.push(segment);
        this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
        this.prefix = segments[0];
        this.$$paramNames = paramNames;
      }
      UrlMatcher.prototype.concat = function(pattern, config) {
        var defaultConfig = {
          caseInsensitive: $$UMFP.caseInsensitive(),
          strict: $$UMFP.strictMode(),
          squash: $$UMFP.defaultSquashPolicy()
        };
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
      };
      UrlMatcher.prototype.toString = function() {
        return this.source;
      };
      UrlMatcher.prototype.exec = function(path, searchParams) {
        var m = this.regexp.exec(path);
        if (!m)
          return null;
        searchParams = searchParams || {};
        var paramNames = this.parameters(),
            nTotal = paramNames.length,
            nPath = this.segments.length - 1,
            values = {},
            i,
            j,
            cfg,
            paramName;
        if (nPath !== m.length - 1)
          throw new Error("Unbalanced capture group in route '" + this.source + "'");
        function decodePathArray(string) {
          function reverseString(str) {
            return str.split("").reverse().join("");
          }
          function unquoteDashes(str) {
            return str.replace(/\\-/, "-");
          }
          var split = reverseString(string).split(/-(?!\\)/);
          var allReversed = map(split, reverseString);
          return map(allReversed, unquoteDashes).reverse();
        }
        for (i = 0; i < nPath; i++) {
          paramName = paramNames[i];
          var param = this.params[paramName];
          var paramVal = m[i + 1];
          for (j = 0; j < param.replace; j++) {
            if (param.replace[j].from === paramVal)
              paramVal = param.replace[j].to;
          }
          if (paramVal && param.array === true)
            paramVal = decodePathArray(paramVal);
          values[paramName] = param.value(paramVal);
        }
        for (; i < nTotal; i++) {
          paramName = paramNames[i];
          values[paramName] = this.params[paramName].value(searchParams[paramName]);
        }
        return values;
      };
      UrlMatcher.prototype.parameters = function(param) {
        if (!isDefined(param))
          return this.$$paramNames;
        return this.params[param] || null;
      };
      UrlMatcher.prototype.validates = function(params) {
        return this.params.$$validates(params);
      };
      UrlMatcher.prototype.format = function(values) {
        values = values || {};
        var segments = this.segments,
            params = this.parameters(),
            paramset = this.params;
        if (!this.validates(values))
          return null;
        var i,
            search = false,
            nPath = segments.length - 1,
            nTotal = params.length,
            result = segments[0];
        function encodeDashes(str) {
          return encodeURIComponent(str).replace(/-/g, function(c) {
            return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase();
          });
        }
        for (i = 0; i < nTotal; i++) {
          var isPathParam = i < nPath;
          var name = params[i],
              param = paramset[name],
              value = param.value(values[name]);
          var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
          var squash = isDefaultValue ? param.squash : false;
          var encoded = param.type.encode(value);
          if (isPathParam) {
            var nextSegment = segments[i + 1];
            if (squash === false) {
              if (encoded != null) {
                if (isArray(encoded)) {
                  result += map(encoded, encodeDashes).join("-");
                } else {
                  result += encodeURIComponent(encoded);
                }
              }
              result += nextSegment;
            } else if (squash === true) {
              var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
              result += nextSegment.match(capture)[1];
            } else if (isString(squash)) {
              result += squash + nextSegment;
            }
          } else {
            if (encoded == null || (isDefaultValue && squash !== false))
              continue;
            if (!isArray(encoded))
              encoded = [encoded];
            encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
            result += (search ? '&' : '?') + (name + '=' + encoded);
            search = true;
          }
        }
        return result;
      };
      function Type(config) {
        extend(this, config);
      }
      Type.prototype.is = function(val, key) {
        return true;
      };
      Type.prototype.encode = function(val, key) {
        return val;
      };
      Type.prototype.decode = function(val, key) {
        return val;
      };
      Type.prototype.equals = function(a, b) {
        return a == b;
      };
      Type.prototype.$subPattern = function() {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
      };
      Type.prototype.pattern = /.*/;
      Type.prototype.toString = function() {
        return "{Type:" + this.name + "}";
      };
      Type.prototype.$asArray = function(mode, isSearch) {
        if (!mode)
          return this;
        if (mode === "auto" && !isSearch)
          throw new Error("'auto' array mode is for query parameters only");
        return new ArrayType(this, mode);
        function ArrayType(type, mode) {
          function bindTo(type, callbackName) {
            return function() {
              return type[callbackName].apply(type, arguments);
            };
          }
          function arrayWrap(val) {
            return isArray(val) ? val : (isDefined(val) ? [val] : []);
          }
          function arrayUnwrap(val) {
            switch (val.length) {
              case 0:
                return undefined;
              case 1:
                return mode === "auto" ? val[0] : val;
              default:
                return val;
            }
          }
          function falsey(val) {
            return !val;
          }
          function arrayHandler(callback, allTruthyMode) {
            return function handleArray(val) {
              val = arrayWrap(val);
              var result = map(val, callback);
              if (allTruthyMode === true)
                return filter(result, falsey).length === 0;
              return arrayUnwrap(result);
            };
          }
          function arrayEqualsHandler(callback) {
            return function handleArray(val1, val2) {
              var left = arrayWrap(val1),
                  right = arrayWrap(val2);
              if (left.length !== right.length)
                return false;
              for (var i = 0; i < left.length; i++) {
                if (!callback(left[i], right[i]))
                  return false;
              }
              return true;
            };
          }
          this.encode = arrayHandler(bindTo(type, 'encode'));
          this.decode = arrayHandler(bindTo(type, 'decode'));
          this.is = arrayHandler(bindTo(type, 'is'), true);
          this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
          this.pattern = type.pattern;
          this.$arrayMode = mode;
        }
      };
      function $UrlMatcherFactory() {
        $$UMFP = this;
        var isCaseInsensitive = false,
            isStrictMode = true,
            defaultSquashPolicy = false;
        function valToString(val) {
          return val != null ? val.toString().replace(/\//g, "%2F") : val;
        }
        function valFromString(val) {
          return val != null ? val.toString().replace(/%2F/g, "/") : val;
        }
        function regexpMatches(val) {
          return this.pattern.test(val);
        }
        var $types = {},
            enqueue = true,
            typeQueue = [],
            injector,
            defaultTypes = {
              string: {
                encode: valToString,
                decode: valFromString,
                is: regexpMatches,
                pattern: /[^/]*/
              },
              int: {
                encode: valToString,
                decode: function(val) {
                  return parseInt(val, 10);
                },
                is: function(val) {
                  return isDefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /\d+/
              },
              bool: {
                encode: function(val) {
                  return val ? 1 : 0;
                },
                decode: function(val) {
                  return parseInt(val, 10) !== 0;
                },
                is: function(val) {
                  return val === true || val === false;
                },
                pattern: /0|1/
              },
              date: {
                encode: function(val) {
                  if (!this.is(val))
                    return undefined;
                  return [val.getFullYear(), ('0' + (val.getMonth() + 1)).slice(-2), ('0' + val.getDate()).slice(-2)].join("-");
                },
                decode: function(val) {
                  if (this.is(val))
                    return val;
                  var match = this.capture.exec(val);
                  return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function(val) {
                  return val instanceof Date && !isNaN(val.valueOf());
                },
                equals: function(a, b) {
                  return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
              },
              json: {
                encode: angular.toJson,
                decode: angular.fromJson,
                is: angular.isObject,
                equals: angular.equals,
                pattern: /[^/]*/
              },
              any: {
                encode: angular.identity,
                decode: angular.identity,
                is: angular.identity,
                equals: angular.equals,
                pattern: /.*/
              }
            };
        function getDefaultConfig() {
          return {
            strict: isStrictMode,
            caseInsensitive: isCaseInsensitive
          };
        }
        function isInjectable(value) {
          return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));
        }
        $UrlMatcherFactory.$$getDefaultValue = function(config) {
          if (!isInjectable(config.value))
            return config.value;
          if (!injector)
            throw new Error("Injectable functions cannot be called at configuration time");
          return injector.invoke(config.value);
        };
        this.caseInsensitive = function(value) {
          if (isDefined(value))
            isCaseInsensitive = value;
          return isCaseInsensitive;
        };
        this.strictMode = function(value) {
          if (isDefined(value))
            isStrictMode = value;
          return isStrictMode;
        };
        this.defaultSquashPolicy = function(value) {
          if (!isDefined(value))
            return defaultSquashPolicy;
          if (value !== true && value !== false && !isString(value))
            throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
          defaultSquashPolicy = value;
          return value;
        };
        this.compile = function(pattern, config) {
          return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
        };
        this.isMatcher = function(o) {
          if (!isObject(o))
            return false;
          var result = true;
          forEach(UrlMatcher.prototype, function(val, name) {
            if (isFunction(val)) {
              result = result && (isDefined(o[name]) && isFunction(o[name]));
            }
          });
          return result;
        };
        this.type = function(name, definition, definitionFn) {
          if (!isDefined(definition))
            return $types[name];
          if ($types.hasOwnProperty(name))
            throw new Error("A type named '" + name + "' has already been defined.");
          $types[name] = new Type(extend({name: name}, definition));
          if (definitionFn) {
            typeQueue.push({
              name: name,
              def: definitionFn
            });
            if (!enqueue)
              flushTypeQueue();
          }
          return this;
        };
        function flushTypeQueue() {
          while (typeQueue.length) {
            var type = typeQueue.shift();
            if (type.pattern)
              throw new Error("You cannot override a type's .pattern at runtime.");
            angular.extend($types[type.name], injector.invoke(type.def));
          }
        }
        forEach(defaultTypes, function(type, name) {
          $types[name] = new Type(extend({name: name}, type));
        });
        $types = inherit($types, {});
        this.$get = ['$injector', function($injector) {
          injector = $injector;
          enqueue = false;
          flushTypeQueue();
          forEach(defaultTypes, function(type, name) {
            if (!$types[name])
              $types[name] = new Type(type);
          });
          return this;
        }];
        this.Param = function Param(id, type, config, location) {
          var self = this;
          config = unwrapShorthand(config);
          type = getType(config, type, location);
          var arrayMode = getArrayMode();
          type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
          if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined)
            config.value = "";
          var isOptional = config.value !== undefined;
          var squash = getSquashPolicy(config, isOptional);
          var replace = getReplace(config, arrayMode, isOptional, squash);
          function unwrapShorthand(config) {
            var keys = isObject(config) ? objectKeys(config) : [];
            var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
            if (isShorthand)
              config = {value: config};
            config.$$fn = isInjectable(config.value) ? config.value : function() {
              return config.value;
            };
            return config;
          }
          function getType(config, urlType, location) {
            if (config.type && urlType)
              throw new Error("Param '" + id + "' has two type configurations.");
            if (urlType)
              return urlType;
            if (!config.type)
              return (location === "config" ? $types.any : $types.string);
            return config.type instanceof Type ? config.type : new Type(config.type);
          }
          function getArrayMode() {
            var arrayDefaults = {array: (location === "search" ? "auto" : false)};
            var arrayParamNomenclature = id.match(/\[\]$/) ? {array: true} : {};
            return extend(arrayDefaults, arrayParamNomenclature, config).array;
          }
          function getSquashPolicy(config, isOptional) {
            var squash = config.squash;
            if (!isOptional || squash === false)
              return false;
            if (!isDefined(squash) || squash == null)
              return defaultSquashPolicy;
            if (squash === true || isString(squash))
              return squash;
            throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
          }
          function getReplace(config, arrayMode, isOptional, squash) {
            var replace,
                configuredKeys,
                defaultPolicy = [{
                  from: "",
                  to: (isOptional || arrayMode ? undefined : "")
                }, {
                  from: null,
                  to: (isOptional || arrayMode ? undefined : "")
                }];
            replace = isArray(config.replace) ? config.replace : [];
            if (isString(squash))
              replace.push({
                from: squash,
                to: undefined
              });
            configuredKeys = map(replace, function(item) {
              return item.from;
            });
            return filter(defaultPolicy, function(item) {
              return indexOf(configuredKeys, item.from) === -1;
            }).concat(replace);
          }
          function $$getDefaultValue() {
            if (!injector)
              throw new Error("Injectable functions cannot be called at configuration time");
            return injector.invoke(config.$$fn);
          }
          function $value(value) {
            function hasReplaceVal(val) {
              return function(obj) {
                return obj.from === val;
              };
            }
            function $replace(value) {
              var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
                return obj.to;
              });
              return replacement.length ? replacement[0] : value;
            }
            value = $replace(value);
            return isDefined(value) ? self.type.decode(value) : $$getDefaultValue();
          }
          function toString() {
            return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
          }
          extend(this, {
            id: id,
            type: type,
            location: location,
            array: arrayMode,
            squash: squash,
            replace: replace,
            isOptional: isOptional,
            value: $value,
            dynamic: undefined,
            config: config,
            toString: toString
          });
        };
        function ParamSet(params) {
          extend(this, params || {});
        }
        ParamSet.prototype = {
          $$new: function() {
            return inherit(this, extend(new ParamSet(), {$$parent: this}));
          },
          $$keys: function() {
            var keys = [],
                chain = [],
                parent = this,
                ignore = objectKeys(ParamSet.prototype);
            while (parent) {
              chain.push(parent);
              parent = parent.$$parent;
            }
            chain.reverse();
            forEach(chain, function(paramset) {
              forEach(objectKeys(paramset), function(key) {
                if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1)
                  keys.push(key);
              });
            });
            return keys;
          },
          $$values: function(paramValues) {
            var values = {},
                self = this;
            forEach(self.$$keys(), function(key) {
              values[key] = self[key].value(paramValues && paramValues[key]);
            });
            return values;
          },
          $$equals: function(paramValues1, paramValues2) {
            var equal = true,
                self = this;
            forEach(self.$$keys(), function(key) {
              var left = paramValues1 && paramValues1[key],
                  right = paramValues2 && paramValues2[key];
              if (!self[key].type.equals(left, right))
                equal = false;
            });
            return equal;
          },
          $$validates: function $$validate(paramValues) {
            var result = true,
                isOptional,
                val,
                param,
                self = this;
            forEach(this.$$keys(), function(key) {
              param = self[key];
              val = paramValues[key];
              isOptional = !val && param.isOptional;
              result = result && (isOptional || !!param.type.is(val));
            });
            return result;
          },
          $$parent: undefined
        };
        this.ParamSet = ParamSet;
      }
      angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
      angular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) {}]);
      $UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];
      function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
        var rules = [],
            otherwise = null,
            interceptDeferred = false,
            listener;
        function regExpPrefix(re) {
          var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
          return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
        }
        function interpolate(pattern, match) {
          return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
            return match[what === '$' ? 0 : Number(what)];
          });
        }
        this.rule = function(rule) {
          if (!isFunction(rule))
            throw new Error("'rule' must be a function");
          rules.push(rule);
          return this;
        };
        this.otherwise = function(rule) {
          if (isString(rule)) {
            var redirect = rule;
            rule = function() {
              return redirect;
            };
          } else if (!isFunction(rule))
            throw new Error("'rule' must be a function");
          otherwise = rule;
          return this;
        };
        function handleIfMatch($injector, handler, match) {
          if (!match)
            return false;
          var result = $injector.invoke(handler, handler, {$match: match});
          return isDefined(result) ? result : true;
        }
        this.when = function(what, handler) {
          var redirect,
              handlerIsString = isString(handler);
          if (isString(what))
            what = $urlMatcherFactory.compile(what);
          if (!handlerIsString && !isFunction(handler) && !isArray(handler))
            throw new Error("invalid 'handler' in when()");
          var strategies = {
            matcher: function(what, handler) {
              if (handlerIsString) {
                redirect = $urlMatcherFactory.compile(handler);
                handler = ['$match', function($match) {
                  return redirect.format($match);
                }];
              }
              return extend(function($injector, $location) {
                return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
              }, {prefix: isString(what.prefix) ? what.prefix : ''});
            },
            regex: function(what, handler) {
              if (what.global || what.sticky)
                throw new Error("when() RegExp must not be global or sticky");
              if (handlerIsString) {
                redirect = handler;
                handler = ['$match', function($match) {
                  return interpolate(redirect, $match);
                }];
              }
              return extend(function($injector, $location) {
                return handleIfMatch($injector, handler, what.exec($location.path()));
              }, {prefix: regExpPrefix(what)});
            }
          };
          var check = {
            matcher: $urlMatcherFactory.isMatcher(what),
            regex: what instanceof RegExp
          };
          for (var n in check) {
            if (check[n])
              return this.rule(strategies[n](what, handler));
          }
          throw new Error("invalid 'what' in when()");
        };
        this.deferIntercept = function(defer) {
          if (defer === undefined)
            defer = true;
          interceptDeferred = defer;
        };
        this.$get = $get;
        $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];
        function $get($location, $rootScope, $injector, $browser) {
          var baseHref = $browser.baseHref(),
              location = $location.url(),
              lastPushedUrl;
          function appendBasePath(url, isHtml5, absolute) {
            if (baseHref === '/')
              return url;
            if (isHtml5)
              return baseHref.slice(0, -1) + url;
            if (absolute)
              return baseHref.slice(1) + url;
            return url;
          }
          function update(evt) {
            if (evt && evt.defaultPrevented)
              return ;
            var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
            lastPushedUrl = undefined;
            if (ignoreUpdate)
              return true;
            function check(rule) {
              var handled = rule($injector, $location);
              if (!handled)
                return false;
              if (isString(handled))
                $location.replace().url(handled);
              return true;
            }
            var n = rules.length,
                i;
            for (i = 0; i < n; i++) {
              if (check(rules[i]))
                return ;
            }
            if (otherwise)
              check(otherwise);
          }
          function listen() {
            listener = listener || $rootScope.$on('$locationChangeSuccess', update);
            return listener;
          }
          if (!interceptDeferred)
            listen();
          return {
            sync: function() {
              update();
            },
            listen: function() {
              return listen();
            },
            update: function(read) {
              if (read) {
                location = $location.url();
                return ;
              }
              if ($location.url() === location)
                return ;
              $location.url(location);
              $location.replace();
            },
            push: function(urlMatcher, params, options) {
              $location.url(urlMatcher.format(params || {}));
              lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
              if (options && options.replace)
                $location.replace();
            },
            href: function(urlMatcher, params, options) {
              if (!urlMatcher.validates(params))
                return null;
              var isHtml5 = $locationProvider.html5Mode();
              if (angular.isObject(isHtml5)) {
                isHtml5 = isHtml5.enabled;
              }
              var url = urlMatcher.format(params);
              options = options || {};
              if (!isHtml5 && url !== null) {
                url = "#" + $locationProvider.hashPrefix() + url;
              }
              url = appendBasePath(url, isHtml5, options.absolute);
              if (!options.absolute || !url) {
                return url;
              }
              var slash = (!isHtml5 && url ? '/' : ''),
                  port = $location.port();
              port = (port === 80 || port === 443 ? '' : ':' + port);
              return [$location.protocol(), '://', $location.host(), port, slash, url].join('');
            }
          };
        }
      }
      angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);
      $StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];
      function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
        var root,
            states = {},
            $state,
            queue = {},
            abstractKey = 'abstract';
        var stateBuilder = {
          parent: function(state) {
            if (isDefined(state.parent) && state.parent)
              return findState(state.parent);
            var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
            return compositeName ? findState(compositeName[1]) : root;
          },
          data: function(state) {
            if (state.parent && state.parent.data) {
              state.data = state.self.data = extend({}, state.parent.data, state.data);
            }
            return state.data;
          },
          url: function(state) {
            var url = state.url,
                config = {params: state.params || {}};
            if (isString(url)) {
              if (url.charAt(0) == '^')
                return $urlMatcherFactory.compile(url.substring(1), config);
              return (state.parent.navigable || root).url.concat(url, config);
            }
            if (!url || $urlMatcherFactory.isMatcher(url))
              return url;
            throw new Error("Invalid url '" + url + "' in state '" + state + "'");
          },
          navigable: function(state) {
            return state.url ? state : (state.parent ? state.parent.navigable : null);
          },
          ownParams: function(state) {
            var params = state.url && state.url.params || new $$UMFP.ParamSet();
            forEach(state.params || {}, function(config, id) {
              if (!params[id])
                params[id] = new $$UMFP.Param(id, null, config, "config");
            });
            return params;
          },
          params: function(state) {
            return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();
          },
          views: function(state) {
            var views = {};
            forEach(isDefined(state.views) ? state.views : {'': state}, function(view, name) {
              if (name.indexOf('@') < 0)
                name += '@' + state.parent.name;
              views[name] = view;
            });
            return views;
          },
          path: function(state) {
            return state.parent ? state.parent.path.concat(state) : [];
          },
          includes: function(state) {
            var includes = state.parent ? extend({}, state.parent.includes) : {};
            includes[state.name] = true;
            return includes;
          },
          $delegates: {}
        };
        function isRelative(stateName) {
          return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
        }
        function findState(stateOrName, base) {
          if (!stateOrName)
            return undefined;
          var isStr = isString(stateOrName),
              name = isStr ? stateOrName : stateOrName.name,
              path = isRelative(name);
          if (path) {
            if (!base)
              throw new Error("No reference point given for path '" + name + "'");
            base = findState(base);
            var rel = name.split("."),
                i = 0,
                pathLength = rel.length,
                current = base;
            for (; i < pathLength; i++) {
              if (rel[i] === "" && i === 0) {
                current = base;
                continue;
              }
              if (rel[i] === "^") {
                if (!current.parent)
                  throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                current = current.parent;
                continue;
              }
              break;
            }
            rel = rel.slice(i).join(".");
            name = current.name + (current.name && rel ? "." : "") + rel;
          }
          var state = states[name];
          if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
            return state;
          }
          return undefined;
        }
        function queueState(parentName, state) {
          if (!queue[parentName]) {
            queue[parentName] = [];
          }
          queue[parentName].push(state);
        }
        function flushQueuedChildren(parentName) {
          var queued = queue[parentName] || [];
          while (queued.length) {
            registerState(queued.shift());
          }
        }
        function registerState(state) {
          state = inherit(state, {
            self: state,
            resolve: state.resolve || {},
            toString: function() {
              return this.name;
            }
          });
          var name = state.name;
          if (!isString(name) || name.indexOf('@') >= 0)
            throw new Error("State must have a valid name");
          if (states.hasOwnProperty(name))
            throw new Error("State '" + name + "'' is already defined");
          var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.')) : (isString(state.parent)) ? state.parent : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name : '';
          if (parentName && !states[parentName]) {
            return queueState(parentName, state.self);
          }
          for (var key in stateBuilder) {
            if (isFunction(stateBuilder[key]))
              state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
          }
          states[name] = state;
          if (!state[abstractKey] && state.url) {
            $urlRouterProvider.when(state.url, ['$match', '$stateParams', function($match, $stateParams) {
              if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
                $state.transitionTo(state, $match, {
                  inherit: true,
                  location: false
                });
              }
            }]);
          }
          flushQueuedChildren(name);
          return state;
        }
        function isGlob(text) {
          return text.indexOf('*') > -1;
        }
        function doesStateMatchGlob(glob) {
          var globSegments = glob.split('.'),
              segments = $state.$current.name.split('.');
          if (globSegments[0] === '**') {
            segments = segments.slice(indexOf(segments, globSegments[1]));
            segments.unshift('**');
          }
          if (globSegments[globSegments.length - 1] === '**') {
            segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
            segments.push('**');
          }
          if (globSegments.length != segments.length) {
            return false;
          }
          for (var i = 0,
              l = globSegments.length; i < l; i++) {
            if (globSegments[i] === '*') {
              segments[i] = '*';
            }
          }
          return segments.join('') === globSegments.join('');
        }
        root = registerState({
          name: '',
          url: '^',
          views: null,
          'abstract': true
        });
        root.navigable = null;
        this.decorator = decorator;
        function decorator(name, func) {
          if (isString(name) && !isDefined(func)) {
            return stateBuilder[name];
          }
          if (!isFunction(func) || !isString(name)) {
            return this;
          }
          if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
            stateBuilder.$delegates[name] = stateBuilder[name];
          }
          stateBuilder[name] = func;
          return this;
        }
        this.state = state;
        function state(name, definition) {
          if (isObject(name))
            definition = name;
          else
            definition.name = name;
          registerState(definition);
          return this;
        }
        this.$get = $get;
        $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];
        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
          var TransitionSuperseded = $q.reject(new Error('transition superseded'));
          var TransitionPrevented = $q.reject(new Error('transition prevented'));
          var TransitionAborted = $q.reject(new Error('transition aborted'));
          var TransitionFailed = $q.reject(new Error('transition failed'));
          function handleRedirect(redirect, state, params, options) {
            var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);
            if (evt.defaultPrevented) {
              $urlRouter.update();
              return TransitionAborted;
            }
            if (!evt.retry) {
              return null;
            }
            if (options.$retry) {
              $urlRouter.update();
              return TransitionFailed;
            }
            var retryTransition = $state.transition = $q.when(evt.retry);
            retryTransition.then(function() {
              if (retryTransition !== $state.transition)
                return TransitionSuperseded;
              redirect.options.$retry = true;
              return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
            }, function() {
              return TransitionAborted;
            });
            $urlRouter.update();
            return retryTransition;
          }
          root.locals = {
            resolve: null,
            globals: {$stateParams: {}}
          };
          $state = {
            params: {},
            current: root.self,
            $current: root,
            transition: null
          };
          $state.reload = function reload() {
            return $state.transitionTo($state.current, $stateParams, {
              reload: true,
              inherit: false,
              notify: true
            });
          };
          $state.go = function go(to, params, options) {
            return $state.transitionTo(to, params, extend({
              inherit: true,
              relative: $state.$current
            }, options));
          };
          $state.transitionTo = function transitionTo(to, toParams, options) {
            toParams = toParams || {};
            options = extend({
              location: true,
              inherit: false,
              relative: null,
              notify: true,
              reload: false,
              $retry: false
            }, options || {});
            var from = $state.$current,
                fromParams = $state.params,
                fromPath = from.path;
            var evt,
                toState = findState(to, options.relative);
            if (!isDefined(toState)) {
              var redirect = {
                to: to,
                toParams: toParams,
                options: options
              };
              var redirectResult = handleRedirect(redirect, from.self, fromParams, options);
              if (redirectResult) {
                return redirectResult;
              }
              to = redirect.to;
              toParams = redirect.toParams;
              options = redirect.options;
              toState = findState(to, options.relative);
              if (!isDefined(toState)) {
                if (!options.relative)
                  throw new Error("No such state '" + to + "'");
                throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
              }
            }
            if (toState[abstractKey])
              throw new Error("Cannot transition to abstract state '" + to + "'");
            if (options.inherit)
              toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
            if (!toState.params.$$validates(toParams))
              return TransitionFailed;
            toParams = toState.params.$$values(toParams);
            to = toState;
            var toPath = to.path;
            var keep = 0,
                state = toPath[keep],
                locals = root.locals,
                toLocals = [];
            if (!options.reload) {
              while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
                locals = toLocals[keep] = state.locals;
                keep++;
                state = toPath[keep];
              }
            }
            if (shouldTriggerReload(to, from, locals, options)) {
              if (to.self.reloadOnSearch !== false)
                $urlRouter.update();
              $state.transition = null;
              return $q.when($state.current);
            }
            toParams = filterByKeys(to.params.$$keys(), toParams || {});
            if (options.notify) {
              if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {
                $urlRouter.update();
                return TransitionPrevented;
              }
            }
            var resolved = $q.when(locals);
            for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
              locals = toLocals[l] = inherit(locals);
              resolved = resolveState(state, toParams, state === to, resolved, locals, options);
            }
            var transition = $state.transition = resolved.then(function() {
              var l,
                  entering,
                  exiting;
              if ($state.transition !== transition)
                return TransitionSuperseded;
              for (l = fromPath.length - 1; l >= keep; l--) {
                exiting = fromPath[l];
                if (exiting.self.onExit) {
                  $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
                }
                exiting.locals = null;
              }
              for (l = keep; l < toPath.length; l++) {
                entering = toPath[l];
                entering.locals = toLocals[l];
                if (entering.self.onEnter) {
                  $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                }
              }
              if ($state.transition !== transition)
                return TransitionSuperseded;
              $state.$current = to;
              $state.current = to.self;
              $state.params = toParams;
              copy($state.params, $stateParams);
              $state.transition = null;
              if (options.location && to.navigable) {
                $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                  $$avoidResync: true,
                  replace: options.location === 'replace'
                });
              }
              if (options.notify) {
                $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
              }
              $urlRouter.update(true);
              return $state.current;
            }, function(error) {
              if ($state.transition !== transition)
                return TransitionSuperseded;
              $state.transition = null;
              evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);
              if (!evt.defaultPrevented) {
                $urlRouter.update();
              }
              return $q.reject(error);
            });
            return transition;
          };
          $state.is = function is(stateOrName, params, options) {
            options = extend({relative: $state.$current}, options || {});
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state)) {
              return undefined;
            }
            if ($state.$current !== state) {
              return false;
            }
            return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
          };
          $state.includes = function includes(stateOrName, params, options) {
            options = extend({relative: $state.$current}, options || {});
            if (isString(stateOrName) && isGlob(stateOrName)) {
              if (!doesStateMatchGlob(stateOrName)) {
                return false;
              }
              stateOrName = $state.$current.name;
            }
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state)) {
              return undefined;
            }
            if (!isDefined($state.$current.includes[state.name])) {
              return false;
            }
            return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
          };
          $state.href = function href(stateOrName, params, options) {
            options = extend({
              lossy: true,
              inherit: true,
              absolute: false,
              relative: $state.$current
            }, options || {});
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state))
              return null;
            if (options.inherit)
              params = inheritParams($stateParams, params || {}, $state.$current, state);
            var nav = (state && options.lossy) ? state.navigable : state;
            if (!nav || nav.url === undefined || nav.url === null) {
              return null;
            }
            return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys(), params || {}), {absolute: options.absolute});
          };
          $state.get = function(stateOrName, context) {
            if (arguments.length === 0)
              return map(objectKeys(states), function(name) {
                return states[name].self;
              });
            var state = findState(stateOrName, context || $state.$current);
            return (state && state.self) ? state.self : null;
          };
          function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
            var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);
            var locals = {$stateParams: $stateParams};
            dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
            var promises = [dst.resolve.then(function(globals) {
              dst.globals = globals;
            })];
            if (inherited)
              promises.push(inherited);
            forEach(state.views, function(view, name) {
              var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
              injectables.$template = [function() {
                return $view.load(name, {
                  view: view,
                  locals: locals,
                  params: $stateParams,
                  notify: options.notify
                }) || '';
              }];
              promises.push($resolve.resolve(injectables, locals, dst.resolve, state).then(function(result) {
                if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                  var injectLocals = angular.extend({}, injectables, locals);
                  result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                } else {
                  result.$$controller = view.controller;
                }
                result.$$state = state;
                result.$$controllerAs = view.controllerAs;
                dst[name] = result;
              }));
            });
            return $q.all(promises).then(function(values) {
              return dst;
            });
          }
          return $state;
        }
        function shouldTriggerReload(to, from, locals, options) {
          if (to === from && ((locals === from.locals && !options.reload) || (to.self.reloadOnSearch === false))) {
            return true;
          }
        }
      }
      angular.module('ui.router.state').value('$stateParams', {}).provider('$state', $StateProvider);
      $ViewProvider.$inject = [];
      function $ViewProvider() {
        this.$get = $get;
        $get.$inject = ['$rootScope', '$templateFactory'];
        function $get($rootScope, $templateFactory) {
          return {load: function load(name, options) {
              var result,
                  defaults = {
                    template: null,
                    controller: null,
                    view: null,
                    locals: null,
                    notify: true,
                    async: true,
                    params: {}
                  };
              options = extend(defaults, options);
              if (options.view) {
                result = $templateFactory.fromConfig(options.view, options.params, options.locals);
              }
              if (result && options.notify) {
                $rootScope.$broadcast('$viewContentLoading', options);
              }
              return result;
            }};
        }
      }
      angular.module('ui.router.state').provider('$view', $ViewProvider);
      function $ViewScrollProvider() {
        var useAnchorScroll = false;
        this.useAnchorScroll = function() {
          useAnchorScroll = true;
        };
        this.$get = ['$anchorScroll', '$timeout', function($anchorScroll, $timeout) {
          if (useAnchorScroll) {
            return $anchorScroll;
          }
          return function($element) {
            $timeout(function() {
              $element[0].scrollIntoView();
            }, 0, false);
          };
        }];
      }
      angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);
      $ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];
      function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {
        function getService() {
          return ($injector.has) ? function(service) {
            return $injector.has(service) ? $injector.get(service) : null;
          } : function(service) {
            try {
              return $injector.get(service);
            } catch (e) {
              return null;
            }
          };
        }
        var service = getService(),
            $animator = service('$animator'),
            $animate = service('$animate');
        function getRenderer(attrs, scope) {
          var statics = function() {
            return {
              enter: function(element, target, cb) {
                target.after(element);
                cb();
              },
              leave: function(element, cb) {
                element.remove();
                cb();
              }
            };
          };
          if ($animate) {
            return {
              enter: function(element, target, cb) {
                var promise = $animate.enter(element, null, target, cb);
                if (promise && promise.then)
                  promise.then(cb);
              },
              leave: function(element, cb) {
                var promise = $animate.leave(element, cb);
                if (promise && promise.then)
                  promise.then(cb);
              }
            };
          }
          if ($animator) {
            var animate = $animator && $animator(scope, attrs);
            return {
              enter: function(element, target, cb) {
                animate.enter(element, null, target);
                cb();
              },
              leave: function(element, cb) {
                animate.leave(element);
                cb();
              }
            };
          }
          return statics();
        }
        var directive = {
          restrict: 'ECA',
          terminal: true,
          priority: 400,
          transclude: 'element',
          compile: function(tElement, tAttrs, $transclude) {
            return function(scope, $element, attrs) {
              var previousEl,
                  currentEl,
                  currentScope,
                  latestLocals,
                  onloadExp = attrs.onload || '',
                  autoScrollExp = attrs.autoscroll,
                  renderer = getRenderer(attrs, scope);
              scope.$on('$stateChangeSuccess', function() {
                updateView(false);
              });
              scope.$on('$viewContentLoading', function() {
                updateView(false);
              });
              updateView(true);
              function cleanupLastView() {
                if (previousEl) {
                  previousEl.remove();
                  previousEl = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentEl) {
                  renderer.leave(currentEl, function() {
                    previousEl = null;
                  });
                  previousEl = currentEl;
                  currentEl = null;
                }
              }
              function updateView(firstTime) {
                var newScope,
                    name = getUiViewName(scope, attrs, $element, $interpolate),
                    previousLocals = name && $state.$current && $state.$current.locals[name];
                if (!firstTime && previousLocals === latestLocals)
                  return ;
                newScope = scope.$new();
                latestLocals = $state.$current.locals[name];
                var clone = $transclude(newScope, function(clone) {
                  renderer.enter(clone, $element, function onUiViewEnter() {
                    if (currentScope) {
                      currentScope.$emit('$viewContentAnimationEnded');
                    }
                    if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                      $uiViewScroll(clone);
                    }
                  });
                  cleanupLastView();
                });
                currentEl = clone;
                currentScope = newScope;
                currentScope.$emit('$viewContentLoaded');
                currentScope.$eval(onloadExp);
              }
            };
          }
        };
        return directive;
      }
      $ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];
      function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
        return {
          restrict: 'ECA',
          priority: -400,
          compile: function(tElement) {
            var initial = tElement.html();
            return function(scope, $element, attrs) {
              var current = $state.$current,
                  name = getUiViewName(scope, attrs, $element, $interpolate),
                  locals = current && current.locals[name];
              if (!locals) {
                return ;
              }
              $element.data('$uiView', {
                name: name,
                state: locals.$$state
              });
              $element.html(locals.$template ? locals.$template : initial);
              var link = $compile($element.contents());
              if (locals.$$controller) {
                locals.$scope = scope;
                var controller = $controller(locals.$$controller, locals);
                if (locals.$$controllerAs) {
                  scope[locals.$$controllerAs] = controller;
                }
                $element.data('$ngControllerController', controller);
                $element.children().data('$ngControllerController', controller);
              }
              link(scope);
            };
          }
        };
      }
      function getUiViewName(scope, attrs, element, $interpolate) {
        var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
        var inherited = element.inheritedData('$uiView');
        return name.indexOf('@') >= 0 ? name : (name + '@' + (inherited ? inherited.state.name : ''));
      }
      angular.module('ui.router.state').directive('uiView', $ViewDirective);
      angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);
      function parseStateRef(ref, current) {
        var preparsed = ref.match(/^\s*({[^}]*})\s*$/),
            parsed;
        if (preparsed)
          ref = current + '(' + preparsed[1] + ')';
        parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
        if (!parsed || parsed.length !== 4)
          throw new Error("Invalid state ref '" + ref + "'");
        return {
          state: parsed[1],
          paramExpr: parsed[3] || null
        };
      }
      function stateContext(el) {
        var stateData = el.parent().inheritedData('$uiView');
        if (stateData && stateData.state && stateData.state.name) {
          return stateData.state;
        }
      }
      $StateRefDirective.$inject = ['$state', '$timeout'];
      function $StateRefDirective($state, $timeout) {
        var allowedOptions = ['location', 'inherit', 'reload'];
        return {
          restrict: 'A',
          require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
          link: function(scope, element, attrs, uiSrefActive) {
            var ref = parseStateRef(attrs.uiSref, $state.current.name);
            var params = null,
                url = null,
                base = stateContext(element) || $state.$current;
            var newHref = null,
                isAnchor = element.prop("tagName") === "A";
            var isForm = element[0].nodeName === "FORM";
            var attr = isForm ? "action" : "href",
                nav = true;
            var options = {
              relative: base,
              inherit: true
            };
            var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};
            angular.forEach(allowedOptions, function(option) {
              if (option in optionsOverride) {
                options[option] = optionsOverride[option];
              }
            });
            var update = function(newVal) {
              if (newVal)
                params = angular.copy(newVal);
              if (!nav)
                return ;
              newHref = $state.href(ref.state, params, options);
              var activeDirective = uiSrefActive[1] || uiSrefActive[0];
              if (activeDirective) {
                activeDirective.$$setStateInfo(ref.state, params);
              }
              if (newHref === null) {
                nav = false;
                return false;
              }
              attrs.$set(attr, newHref);
            };
            if (ref.paramExpr) {
              scope.$watch(ref.paramExpr, function(newVal, oldVal) {
                if (newVal !== params)
                  update(newVal);
              }, true);
              params = angular.copy(scope.$eval(ref.paramExpr));
            }
            update();
            if (isForm)
              return ;
            element.bind("click", function(e) {
              var button = e.which || e.button;
              if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target'))) {
                var transition = $timeout(function() {
                  $state.go(ref.state, params, options);
                });
                e.preventDefault();
                var ignorePreventDefaultCount = isAnchor && !newHref ? 1 : 0;
                e.preventDefault = function() {
                  if (ignorePreventDefaultCount-- <= 0)
                    $timeout.cancel(transition);
                };
              }
            });
          }
        };
      }
      $StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
      function $StateRefActiveDirective($state, $stateParams, $interpolate) {
        return {
          restrict: "A",
          controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {
            var state,
                params,
                activeClass;
            activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);
            this.$$setStateInfo = function(newState, newParams) {
              state = $state.get(newState, stateContext($element));
              params = newParams;
              update();
            };
            $scope.$on('$stateChangeSuccess', update);
            function update() {
              if (isMatch()) {
                $element.addClass(activeClass);
              } else {
                $element.removeClass(activeClass);
              }
            }
            function isMatch() {
              if (typeof $attrs.uiSrefActiveEq !== 'undefined') {
                return state && $state.is(state.name, params);
              } else {
                return state && $state.includes(state.name, params);
              }
            }
          }]
        };
      }
      angular.module('ui.router.state').directive('uiSref', $StateRefDirective).directive('uiSrefActive', $StateRefActiveDirective).directive('uiSrefActiveEq', $StateRefActiveDirective);
      $IsStateFilter.$inject = ['$state'];
      function $IsStateFilter($state) {
        var isFilter = function(state) {
          return $state.is(state);
        };
        isFilter.$stateful = true;
        return isFilter;
      }
      $IncludedByStateFilter.$inject = ['$state'];
      function $IncludedByStateFilter($state) {
        var includesFilter = function(state) {
          return $state.includes(state);
        };
        includesFilter.$stateful = true;
        return includesFilter;
      }
      angular.module('ui.router.state').filter('isState', $IsStateFilter).filter('includedByState', $IncludedByStateFilter);
    })(window, window.angular);
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, false);
});

(function() {
function define(){};  define.amd = {};
(function(global, factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    module.exports = global.document ? factory(global, true) : function(w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
}(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
  var arr = [];
  var slice = arr.slice;
  var concat = arr.concat;
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var support = {};
  var document = window.document,
      version = "2.1.4",
      jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
      },
      rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
      rmsPrefix = /^-ms-/,
      rdashAlpha = /-([\da-z])/gi,
      fcamelCase = function(all, letter) {
        return letter.toUpperCase();
      };
  jQuery.fn = jQuery.prototype = {
    jquery: version,
    constructor: jQuery,
    selector: "",
    length: 0,
    toArray: function() {
      return slice.call(this);
    },
    get: function(num) {
      return num != null ? (num < 0 ? this[num + this.length] : this[num]) : slice.call(this);
    },
    pushStack: function(elems) {
      var ret = jQuery.merge(this.constructor(), elems);
      ret.prevObject = this;
      ret.context = this.context;
      return ret;
    },
    each: function(callback, args) {
      return jQuery.each(this, callback, args);
    },
    map: function(callback) {
      return this.pushStack(jQuery.map(this, function(elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function() {
      return this.pushStack(slice.apply(this, arguments));
    },
    first: function() {
      return this.eq(0);
    },
    last: function() {
      return this.eq(-1);
    },
    eq: function(i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function() {
      return this.prevObject || this.constructor(null);
    },
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };
  jQuery.extend = jQuery.fn.extend = function() {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[i] || {};
      i++;
    }
    if (typeof target !== "object" && !jQuery.isFunction(target)) {
      target = {};
    }
    if (i === length) {
      target = this;
      i--;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    isReady: true,
    error: function(msg) {
      throw new Error(msg);
    },
    noop: function() {},
    isFunction: function(obj) {
      return jQuery.type(obj) === "function";
    },
    isArray: Array.isArray,
    isWindow: function(obj) {
      return obj != null && obj === obj.window;
    },
    isNumeric: function(obj) {
      return !jQuery.isArray(obj) && (obj - parseFloat(obj) + 1) >= 0;
    },
    isPlainObject: function(obj) {
      if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
        return false;
      }
      if (obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
        return false;
      }
      return true;
    },
    isEmptyObject: function(obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    type: function(obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
    },
    globalEval: function(code) {
      var script,
          indirect = eval;
      code = jQuery.trim(code);
      if (code) {
        if (code.indexOf("use strict") === 1) {
          script = document.createElement("script");
          script.text = code;
          document.head.appendChild(script).parentNode.removeChild(script);
        } else {
          indirect(code);
        }
      }
    },
    camelCase: function(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    },
    nodeName: function(elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    each: function(obj, callback, args) {
      var value,
          i = 0,
          length = obj.length,
          isArray = isArraylike(obj);
      if (args) {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        }
      } else {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        }
      }
      return obj;
    },
    trim: function(text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },
    makeArray: function(arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArraylike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    merge: function(first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;
      for (; j < len; j++) {
        first[i++] = second[j];
      }
      first.length = i;
      return first;
    },
    grep: function(elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert;
      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);
        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }
      return matches;
    },
    map: function(elems, callback, arg) {
      var value,
          i = 0,
          length = elems.length,
          isArray = isArraylike(elems),
          ret = [];
      if (isArray) {
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      }
      return concat.apply([], ret);
    },
    guid: 1,
    proxy: function(fn, context) {
      var tmp,
          args,
          proxy;
      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }
      args = slice.call(arguments, 2);
      proxy = function() {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    now: Date.now,
    support: support
  });
  jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });
  function isArraylike(obj) {
    var length = "length" in obj && obj.length,
        type = jQuery.type(obj);
    if (type === "function" || jQuery.isWindow(obj)) {
      return false;
    }
    if (obj.nodeType === 1 && length) {
      return true;
    }
    return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
  }
  var Sizzle = (function(window) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        },
        MAX_NEGATIVE = 1 << 31,
        hasOwn = ({}).hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        indexOf = function(list, elem) {
          var i = 0,
              len = list.length;
          for (; i < len; i++) {
            if (list[i] === elem) {
              return i;
            }
          }
          return -1;
        },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        whitespace = "[\\x20\\t\\r\\n\\f]",
        characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
        identifier = characterEncoding.replace("w", "w#"),
        attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + characterEncoding + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)",
        rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
          "ID": new RegExp("^#(" + characterEncoding + ")"),
          "CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
          "TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
          "ATTR": new RegExp("^" + attributes),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        },
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        rescape = /'|\\/g,
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
        funescape = function(_, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 0x10000;
          return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        },
        unloadHandler = function() {
          setDocument();
        };
    try {
      push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {apply: arr.length ? function(target, els) {
          push_native.apply(target, slice.call(els));
        } : function(target, els) {
          var j = target.length,
              i = 0;
          while ((target[j++] = els[i++])) {}
          target.length = j - 1;
        }};
    }
    function Sizzle(selector, context, results, seed) {
      var match,
          elem,
          m,
          nodeType,
          i,
          groups,
          old,
          nid,
          newContext,
          newSelector;
      if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
        setDocument(context);
      }
      context = context || document;
      results = results || [];
      nodeType = context.nodeType;
      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      }
      if (!seed && documentIsHTML) {
        if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
          if ((m = match[1])) {
            if (nodeType === 9) {
              elem = context.getElementById(m);
              if (elem && elem.parentNode) {
                if (elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              }
            } else {
              if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                results.push(elem);
                return results;
              }
            }
          } else if (match[2]) {
            push.apply(results, context.getElementsByTagName(selector));
            return results;
          } else if ((m = match[3]) && support.getElementsByClassName) {
            push.apply(results, context.getElementsByClassName(m));
            return results;
          }
        }
        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
          nid = old = expando;
          newContext = context;
          newSelector = nodeType !== 1 && selector;
          if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
            groups = tokenize(selector);
            if ((old = context.getAttribute("id"))) {
              nid = old.replace(rescape, "\\$&");
            } else {
              context.setAttribute("id", nid);
            }
            nid = "[id='" + nid + "'] ";
            i = groups.length;
            while (i--) {
              groups[i] = nid + toSelector(groups[i]);
            }
            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
            newSelector = groups.join(",");
          }
          if (newSelector) {
            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {} finally {
              if (!old) {
                context.removeAttribute("id");
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key + " ") > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return (cache[key + " "] = value);
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function assert(fn) {
      var div = document.createElement("div");
      try {
        return !!fn(div);
      } catch (e) {
        return false;
      } finally {
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
        div = null;
      }
    }
    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
          i = attrs.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
      if (diff) {
        return diff;
      }
      if (cur) {
        while ((cur = cur.nextSibling)) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function(argument) {
        argument = +argument;
        return markFunction(function(seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length;
          while (i--) {
            if (seed[(j = matchIndexes[i])]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    }
    support = Sizzle.support = {};
    isXML = Sizzle.isXML = function(elem) {
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== "HTML" : false;
    };
    setDocument = Sizzle.setDocument = function(node) {
      var hasCompare,
          parent,
          doc = node ? node.ownerDocument || node : preferredDoc;
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      document = doc;
      docElem = doc.documentElement;
      parent = doc.defaultView;
      if (parent && parent !== parent.top) {
        if (parent.addEventListener) {
          parent.addEventListener("unload", unloadHandler, false);
        } else if (parent.attachEvent) {
          parent.attachEvent("onunload", unloadHandler);
        }
      }
      documentIsHTML = !isXML(doc);
      support.attributes = assert(function(div) {
        div.className = "i";
        return !div.getAttribute("className");
      });
      support.getElementsByTagName = assert(function(div) {
        div.appendChild(doc.createComment(""));
        return !div.getElementsByTagName("*").length;
      });
      support.getElementsByClassName = rnative.test(doc.getElementsByClassName);
      support.getById = assert(function(div) {
        docElem.appendChild(div).id = expando;
        return !doc.getElementsByName || !doc.getElementsByName(expando).length;
      });
      if (support.getById) {
        Expr.find["ID"] = function(id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var m = context.getElementById(id);
            return m && m.parentNode ? [m] : [];
          }
        };
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            return elem.getAttribute("id") === attrId;
          };
        };
      } else {
        delete Expr.find["ID"];
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        };
      }
      Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag);
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function(tag, context) {
        var elem,
            tmp = [],
            i = 0,
            results = context.getElementsByTagName(tag);
        if (tag === "*") {
          while ((elem = results[i++])) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
        if (documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if ((support.qsa = rnative.test(doc.querySelectorAll))) {
        assert(function(div) {
          docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\f]' msallowcapture=''>" + "<option selected=''></option></select>";
          if (div.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          }
          if (!div.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          }
          if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          }
          if (!div.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          }
          if (!div.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          }
        });
        assert(function(div) {
          var input = doc.createElement("input");
          input.setAttribute("type", "hidden");
          div.appendChild(input).setAttribute("name", "D");
          if (div.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          }
          if (!div.querySelectorAll(":enabled").length) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          div.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }
      if ((support.matchesSelector = rnative.test((matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))) {
        assert(function(div) {
          support.disconnectedMatch = matches.call(div, "div");
          matches.call(div, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      hasCompare = rnative.test(docElem.compareDocumentPosition);
      contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function(a, b) {
        if (b) {
          while ((b = b.parentNode)) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = hasCompare ? function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
          return compare;
        }
        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
        if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
          if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
            return -1;
          }
          if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
            return 1;
          }
          return sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        }
        return compare & 4 ? -1 : 1;
      } : function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b];
        if (!aup || !bup) {
          return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while ((cur = cur.parentNode)) {
          ap.unshift(cur);
        }
        cur = b;
        while ((cur = cur.parentNode)) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return doc;
    };
    Sizzle.matches = function(expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function(elem, expr) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, "='$1']");
      if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {}
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function(context, elem) {
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function(elem, name) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()],
          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };
    Sizzle.error = function(msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    Sizzle.uniqueSort = function(results) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while ((elem = results[i++])) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      sortInput = null;
      return results;
    };
    getText = Sizzle.getText = function(elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;
      if (!nodeType) {
        while ((node = elem[i++])) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {dir: "parentNode"},
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {dir: "previousSibling"}
      },
      preFilter: {
        "ATTR": function(match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }
          return match.slice(0, 4);
        },
        "CHILD": function(match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === "nth") {
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +((match[7] + match[8]) || match[3] === "odd");
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        "PSEUDO": function(match) {
          var excess,
              unquoted = !match[6] && match[2];
          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          }
          if (match[3]) {
            match[2] = match[4] || match[5] || "";
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function(nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function() {
            return true;
          } : function(elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function(name, operator, check) {
          return function(elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === "!=";
            }
            if (!operator) {
              return true;
            }
            result += "";
            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
          };
        },
        "CHILD": function(type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
          return first === 1 && last === 0 ? function(elem) {
            return !!elem.parentNode;
          } : function(elem, context, xml) {
            var cache,
                outerCache,
                node,
                diff,
                nodeIndex,
                start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType;
            if (parent) {
              if (simple) {
                while (dir) {
                  node = elem;
                  while ((node = node[dir])) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir = type === "only" && !start && "nextSibling";
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                outerCache = parent[expando] || (parent[expando] = {});
                cache = outerCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = cache[0] === dirruns && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    outerCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                diff = cache[1];
              } else {
                while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                    if (useCache) {
                      (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                    }
                    if (node === elem) {
                      break;
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || (diff % first === 0 && diff / first >= 0);
            }
          };
        },
        "PSEUDO": function(pseudo, argument) {
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;
              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function(elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        "not": markFunction(function(selector) {
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length;
            while (i--) {
              if ((elem = unmatched[i])) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function(elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function(selector) {
          return function(elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function(text) {
          text = text.replace(runescape, funescape);
          return function(elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        "lang": markFunction(function(lang) {
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function(elem) {
            var elemLang;
            do {
              if ((elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        "target": function(elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function(elem) {
          return elem === docElem;
        },
        "focus": function(elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        "enabled": function(elem) {
          return elem.disabled === false;
        },
        "disabled": function(elem) {
          return elem.disabled === true;
        },
        "checked": function(elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
        },
        "selected": function(elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        "empty": function(elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },
        "parent": function(elem) {
          return !Expr.pseudos["empty"](elem);
        },
        "header": function(elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function(elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function(elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        "first": createPositionalPseudo(function() {
          return [0];
        }),
        "last": createPositionalPseudo(function(matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function(matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function(matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"];
    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {}
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    tokenize = Sizzle.tokenize = function(selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push((tokens = []));
        }
        matched = false;
        if ((match = rcombinators.exec(soFar))) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    };
    function toSelector(tokens) {
      var i = 0,
          len = tokens.length,
          selector = "";
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          checkNonElements = base && dir === "parentNode",
          doneName = done++;
      return combinator.first ? function(elem, context, xml) {
        while ((elem = elem[dir])) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
      } : function(elem, context, xml) {
        var oldCache,
            outerCache,
            newCache = [dirruns, doneName];
        if (xml) {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                return (newCache[2] = oldCache[2]);
              } else {
                outerCache[dir] = newCache;
                if ((newCache[2] = matcher(elem, context, xml))) {
                  return true;
                }
              }
            }
          }
        }
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function(elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;
      for (; i < len; i++) {
        if ((elem = unmatched[i])) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function(seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if ((elem = temp[i])) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i])) {
                  temp.push((matcherIn[i] = elem));
                }
              }
              postFinder(null, (matcherOut = []), temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true),
          matchAnyContext = addCombinator(function(elem) {
            return indexOf(checkContext, elem) > -1;
          }, implicitRelative, true),
          matchers = [function(elem, context, xml) {
            var ret = (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
      for (; i < len; i++) {
        if ((matcher = Expr.relative[tokens[i].type])) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function(seed, context, xml, results, outermost) {
            var elem,
                j,
                matcher,
                matchedCount = 0,
                i = "0",
                unmatched = seed && [],
                setMatched = [],
                contextBackup = outermostContext,
                elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                len = elems.length;
            if (outermost) {
              outermostContext = context !== document && context;
            }
            for (; i !== len && (elem = elems[i]) != null; i++) {
              if (byElement && elem) {
                j = 0;
                while ((matcher = elementMatchers[j++])) {
                  if (matcher(elem, context, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if ((elem = !matcher && elem)) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i;
            if (bySet && i !== matchedCount) {
              j = 0;
              while ((matcher = setMatchers[j++])) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i--) {
                    if (!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length) > 1) {
                Sizzle.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function(selector, match) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];
      if (!cached) {
        if (!match) {
          match = tokenize(selector);
        }
        i = match.length;
        while (i--) {
          cached = matcherFromTokens(match[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
        cached.selector = selector;
      }
      return cached;
    };
    select = Sizzle.select = function(selector, context, results, seed) {
      var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize((selector = compiled.selector || selector));
      results = results || [];
      if (match.length === 1) {
        tokens = match[0] = match[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
          if (!context) {
            return results;
          } else if (compiled) {
            context = context.parentNode;
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
        while (i--) {
          token = tokens[i];
          if (Expr.relative[(type = token.type)]) {
            break;
          }
          if ((find = Expr.find[type])) {
            if ((seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push.apply(results, seed);
                return results;
              }
              break;
            }
          }
        }
      }
      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    };
    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
    support.detectDuplicates = !!hasDuplicate;
    setDocument();
    support.sortDetached = assert(function(div1) {
      return div1.compareDocumentPosition(document.createElement("div")) & 1;
    });
    if (!assert(function(div) {
      div.innerHTML = "<a href='#'></a>";
      return div.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function(elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    }
    if (!support.attributes || !assert(function(div) {
      div.innerHTML = "<input/>";
      div.firstChild.setAttribute("value", "");
      return div.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function(elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    }
    if (!assert(function(div) {
      return div.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function(elem, name, isXML) {
        var val;
        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }
    return Sizzle;
  })(window);
  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  var rneedsContext = jQuery.expr.match.needsContext;
  var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);
  var risSimple = /^.[^:#\[\.,]*$/;
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function(elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function(elem) {
        return (elem === qualifier) !== not;
      });
    }
    if (typeof qualifier === "string") {
      if (risSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }
      qualifier = jQuery.filter(qualifier, elements);
    }
    return jQuery.grep(elements, function(elem) {
      return (indexOf.call(qualifier, elem) >= 0) !== not;
    });
  }
  jQuery.filter = function(expr, elems, not) {
    var elem = elems[0];
    if (not) {
      expr = ":not(" + expr + ")";
    }
    return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
      return elem.nodeType === 1;
    }));
  };
  jQuery.fn.extend({
    find: function(selector) {
      var i,
          len = this.length,
          ret = [],
          self = this;
      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function() {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + " " + selector : selector;
      return ret;
    },
    filter: function(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function(selector) {
      return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  });
  var rootjQuery,
      rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
      init = jQuery.fn.init = function(selector, context) {
        var match,
            elem;
        if (!selector) {
          return this;
        }
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          }
          if (match && (match[1] || !context)) {
            if (match[1]) {
              context = context instanceof jQuery ? context[0] : context;
              jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
              if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                for (match in context) {
                  if (jQuery.isFunction(this[match])) {
                    this[match](context[match]);
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }
              return this;
            } else {
              elem = document.getElementById(match[2]);
              if (elem && elem.parentNode) {
                this.length = 1;
                this[0] = elem;
              }
              this.context = document;
              this.selector = selector;
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || rootjQuery).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this.context = this[0] = selector;
          this.length = 1;
          return this;
        } else if (jQuery.isFunction(selector)) {
          return typeof rootjQuery.ready !== "undefined" ? rootjQuery.ready(selector) : selector(jQuery);
        }
        if (selector.selector !== undefined) {
          this.selector = selector.selector;
          this.context = selector.context;
        }
        return jQuery.makeArray(selector, this);
      };
  init.prototype = jQuery.fn;
  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
  jQuery.extend({
    dir: function(elem, dir, until) {
      var matched = [],
          truncate = until !== undefined;
      while ((elem = elem[dir]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    },
    sibling: function(n, elem) {
      var matched = [];
      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }
      return matched;
    }
  });
  jQuery.fn.extend({
    has: function(target) {
      var targets = jQuery(target, this),
          l = targets.length;
      return this.filter(function() {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function(selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
            matched.push(cur);
            break;
          }
        }
      }
      return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
    },
    index: function(elem) {
      if (!elem) {
        return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
      }
      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      }
      return indexOf.call(this, elem.jquery ? elem[0] : elem);
    },
    add: function(selector, context) {
      return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}
    return cur;
  }
  jQuery.each({
    parent: function(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function(elem) {
      return jQuery.dir(elem, "parentNode");
    },
    parentsUntil: function(elem, i, until) {
      return jQuery.dir(elem, "parentNode", until);
    },
    next: function(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function(elem) {
      return jQuery.dir(elem, "nextSibling");
    },
    prevAll: function(elem) {
      return jQuery.dir(elem, "previousSibling");
    },
    nextUntil: function(elem, i, until) {
      return jQuery.dir(elem, "nextSibling", until);
    },
    prevUntil: function(elem, i, until) {
      return jQuery.dir(elem, "previousSibling", until);
    },
    siblings: function(elem) {
      return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
    },
    children: function(elem) {
      return jQuery.sibling(elem.firstChild);
    },
    contents: function(elem) {
      return elem.contentDocument || jQuery.merge([], elem.childNodes);
    }
  }, function(name, fn) {
    jQuery.fn[name] = function(until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== "Until") {
        selector = until;
      }
      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length > 1) {
        if (!guaranteedUnique[name]) {
          jQuery.unique(matched);
        }
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  var rnotwhite = (/\S+/g);
  var optionsCache = {};
  function createOptions(options) {
    var object = optionsCache[options] = {};
    jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function(options) {
    options = typeof options === "string" ? (optionsCache[options] || createOptions(options)) : jQuery.extend({}, options);
    var memory,
        fired,
        firing,
        firingStart,
        firingLength,
        firingIndex,
        list = [],
        stack = !options.once && [],
        fire = function(data) {
          memory = options.memory && data;
          fired = true;
          firingIndex = firingStart || 0;
          firingStart = 0;
          firingLength = list.length;
          firing = true;
          for (; list && firingIndex < firingLength; firingIndex++) {
            if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
              memory = false;
              break;
            }
          }
          firing = false;
          if (list) {
            if (stack) {
              if (stack.length) {
                fire(stack.shift());
              }
            } else if (memory) {
              list = [];
            } else {
              self.disable();
            }
          }
        },
        self = {
          add: function() {
            if (list) {
              var start = list.length;
              (function add(args) {
                jQuery.each(args, function(_, arg) {
                  var type = jQuery.type(arg);
                  if (type === "function") {
                    if (!options.unique || !self.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && type !== "string") {
                    add(arg);
                  }
                });
              })(arguments);
              if (firing) {
                firingLength = list.length;
              } else if (memory) {
                firingStart = start;
                fire(memory);
              }
            }
            return this;
          },
          remove: function() {
            if (list) {
              jQuery.each(arguments, function(_, arg) {
                var index;
                while ((index = jQuery.inArray(arg, list, index)) > -1) {
                  list.splice(index, 1);
                  if (firing) {
                    if (index <= firingLength) {
                      firingLength--;
                    }
                    if (index <= firingIndex) {
                      firingIndex--;
                    }
                  }
                }
              });
            }
            return this;
          },
          has: function(fn) {
            return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
          },
          empty: function() {
            list = [];
            firingLength = 0;
            return this;
          },
          disable: function() {
            list = stack = memory = undefined;
            return this;
          },
          disabled: function() {
            return !list;
          },
          lock: function() {
            stack = undefined;
            if (!memory) {
              self.disable();
            }
            return this;
          },
          locked: function() {
            return !stack;
          },
          fireWith: function(context, args) {
            if (list && (!fired || stack)) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              if (firing) {
                stack.push(args);
              } else {
                fire(args);
              }
            }
            return this;
          },
          fire: function() {
            self.fireWith(this, arguments);
            return this;
          },
          fired: function() {
            return !!fired;
          }
        };
    return self;
  };
  jQuery.extend({
    Deferred: function(func) {
      var tuples = [["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
          state = "pending",
          promise = {
            state: function() {
              return state;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            then: function() {
              var fns = arguments;
              return jQuery.Deferred(function(newDefer) {
                jQuery.each(tuples, function(i, tuple) {
                  var fn = jQuery.isFunction(fns[i]) && fns[i];
                  deferred[tuple[1]](function() {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && jQuery.isFunction(returned.promise)) {
                      returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                    } else {
                      newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            promise: function(obj) {
              return obj != null ? jQuery.extend(obj, promise) : promise;
            }
          },
          deferred = {};
      promise.pipe = promise.then;
      jQuery.each(tuples, function(i, tuple) {
        var list = tuple[2],
            stateString = tuple[3];
        promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(function() {
            state = stateString;
          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
        }
        deferred[tuple[0]] = function() {
          deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
          return this;
        };
        deferred[tuple[0] + "With"] = list.fireWith;
      });
      promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function(subordinate) {
      var i = 0,
          resolveValues = slice.call(arguments),
          length = resolveValues.length,
          remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,
          deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
          updateFunc = function(i, contexts, values) {
            return function(value) {
              contexts[i] = this;
              values[i] = arguments.length > 1 ? slice.call(arguments) : value;
              if (values === progressValues) {
                deferred.notifyWith(contexts, values);
              } else if (!(--remaining)) {
                deferred.resolveWith(contexts, values);
              }
            };
          },
          progressValues,
          progressContexts,
          resolveContexts;
      if (length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);
        for (; i < length; i++) {
          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
          } else {
            --remaining;
          }
        }
      }
      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }
      return deferred.promise();
    }
  });
  var readyList;
  jQuery.fn.ready = function(fn) {
    jQuery.ready.promise().done(fn);
    return this;
  };
  jQuery.extend({
    isReady: false,
    readyWait: 1,
    holdReady: function(hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    ready: function(wait) {
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return ;
      }
      jQuery.isReady = true;
      if (wait !== true && --jQuery.readyWait > 0) {
        return ;
      }
      readyList.resolveWith(document, [jQuery]);
      if (jQuery.fn.triggerHandler) {
        jQuery(document).triggerHandler("ready");
        jQuery(document).off("ready");
      }
    }
  });
  function completed() {
    document.removeEventListener("DOMContentLoaded", completed, false);
    window.removeEventListener("load", completed, false);
    jQuery.ready();
  }
  jQuery.ready.promise = function(obj) {
    if (!readyList) {
      readyList = jQuery.Deferred();
      if (document.readyState === "complete") {
        setTimeout(jQuery.ready);
      } else {
        document.addEventListener("DOMContentLoaded", completed, false);
        window.addEventListener("load", completed, false);
      }
    }
    return readyList.promise(obj);
  };
  jQuery.ready.promise();
  var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        len = elems.length,
        bulk = key == null;
    if (jQuery.type(key) === "object") {
      chainable = true;
      for (i in key) {
        jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
      }
    } else if (value !== undefined) {
      chainable = true;
      if (!jQuery.isFunction(value)) {
        raw = true;
      }
      if (bulk) {
        if (raw) {
          fn.call(elems, value);
          fn = null;
        } else {
          bulk = fn;
          fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }
      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }
    return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
  };
  jQuery.acceptData = function(owner) {
    return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
  };
  function Data() {
    Object.defineProperty(this.cache = {}, 0, {get: function() {
        return {};
      }});
    this.expando = jQuery.expando + Data.uid++;
  }
  Data.uid = 1;
  Data.accepts = jQuery.acceptData;
  Data.prototype = {
    key: function(owner) {
      if (!Data.accepts(owner)) {
        return 0;
      }
      var descriptor = {},
          unlock = owner[this.expando];
      if (!unlock) {
        unlock = Data.uid++;
        try {
          descriptor[this.expando] = {value: unlock};
          Object.defineProperties(owner, descriptor);
        } catch (e) {
          descriptor[this.expando] = unlock;
          jQuery.extend(owner, descriptor);
        }
      }
      if (!this.cache[unlock]) {
        this.cache[unlock] = {};
      }
      return unlock;
    },
    set: function(owner, data, value) {
      var prop,
          unlock = this.key(owner),
          cache = this.cache[unlock];
      if (typeof data === "string") {
        cache[data] = value;
      } else {
        if (jQuery.isEmptyObject(cache)) {
          jQuery.extend(this.cache[unlock], data);
        } else {
          for (prop in data) {
            cache[prop] = data[prop];
          }
        }
      }
      return cache;
    },
    get: function(owner, key) {
      var cache = this.cache[this.key(owner)];
      return key === undefined ? cache : cache[key];
    },
    access: function(owner, key, value) {
      var stored;
      if (key === undefined || ((key && typeof key === "string") && value === undefined)) {
        stored = this.get(owner, key);
        return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function(owner, key) {
      var i,
          name,
          camel,
          unlock = this.key(owner),
          cache = this.cache[unlock];
      if (key === undefined) {
        this.cache[unlock] = {};
      } else {
        if (jQuery.isArray(key)) {
          name = key.concat(key.map(jQuery.camelCase));
        } else {
          camel = jQuery.camelCase(key);
          if (key in cache) {
            name = [key, camel];
          } else {
            name = camel;
            name = name in cache ? [name] : (name.match(rnotwhite) || []);
          }
        }
        i = name.length;
        while (i--) {
          delete cache[name[i]];
        }
      }
    },
    hasData: function(owner) {
      return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
    },
    discard: function(owner) {
      if (owner[this.expando]) {
        delete this.cache[owner[this.expando]];
      }
    }
  };
  var data_priv = new Data();
  var data_user = new Data();
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /([A-Z])/g;
  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === "string") {
        try {
          data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
        } catch (e) {}
        data_user.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    hasData: function(elem) {
      return data_user.hasData(elem) || data_priv.hasData(elem);
    },
    data: function(elem, name, data) {
      return data_user.access(elem, name, data);
    },
    removeData: function(elem, name) {
      data_user.remove(elem, name);
    },
    _data: function(elem, name, data) {
      return data_priv.access(elem, name, data);
    },
    _removeData: function(elem, name) {
      data_priv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function(key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes;
      if (key === undefined) {
        if (this.length) {
          data = data_user.get(elem);
          if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
            i = attrs.length;
            while (i--) {
              if (attrs[i]) {
                name = attrs[i].name;
                if (name.indexOf("data-") === 0) {
                  name = jQuery.camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            data_priv.set(elem, "hasDataAttrs", true);
          }
        }
        return data;
      }
      if (typeof key === "object") {
        return this.each(function() {
          data_user.set(this, key);
        });
      }
      return access(this, function(value) {
        var data,
            camelKey = jQuery.camelCase(key);
        if (elem && value === undefined) {
          data = data_user.get(elem, key);
          if (data !== undefined) {
            return data;
          }
          data = data_user.get(elem, camelKey);
          if (data !== undefined) {
            return data;
          }
          data = dataAttr(elem, camelKey, undefined);
          if (data !== undefined) {
            return data;
          }
          return ;
        }
        this.each(function() {
          var data = data_user.get(this, camelKey);
          data_user.set(this, camelKey, value);
          if (key.indexOf("-") !== -1 && data !== undefined) {
            data_user.set(this, key, value);
          }
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function(key) {
      return this.each(function() {
        data_user.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function(elem, type, data) {
      var queue;
      if (elem) {
        type = (type || "fx") + "queue";
        queue = data_priv.get(elem, type);
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = data_priv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function(elem, type) {
      type = type || "fx";
      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function() {
            jQuery.dequeue(elem, type);
          };
      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === "fx") {
          queue.unshift("inprogress");
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function(elem, type) {
      var key = type + "queueHooks";
      return data_priv.get(elem, key) || data_priv.access(elem, key, {empty: jQuery.Callbacks("once memory").add(function() {
          data_priv.remove(elem, [type + "queue", key]);
        })});
    }
  });
  jQuery.fn.extend({
    queue: function(type, data) {
      var setter = 2;
      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function() {
        var queue = jQuery.queue(this, type, data);
        jQuery._queueHooks(this, type);
        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function(type) {
      return this.each(function() {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function(type) {
      return this.queue(type || "fx", []);
    },
    promise: function(type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function() {
            if (!(--count)) {
              defer.resolveWith(elements, [elements]);
            }
          };
      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }
      type = type || "fx";
      while (i--) {
        tmp = data_priv.get(elements[i], type + "queueHooks");
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var isHidden = function(elem, el) {
    elem = el || elem;
    return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
  };
  var rcheckableType = (/^(?:checkbox|radio)$/i);
  (function() {
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input");
    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input);
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();
  var strundefined = typeof undefined;
  support.focusinBubbles = "onfocusin" in window;
  var rkeyEvent = /^key/,
      rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
      rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
      rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }
  jQuery.event = {
    global: {},
    add: function(elem, types, handler, data, selector) {
      var handleObjIn,
          eventHandle,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = data_priv.get(elem);
      if (!elemData) {
        return ;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function(e) {
          return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = jQuery.event.special[type] || {};
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn);
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle, false);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        jQuery.event.global[type] = true;
      }
    },
    remove: function(elem, types, handler, selector, mappedTypes) {
      var j,
          origCount,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = data_priv.hasData(elem) && data_priv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return ;
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (jQuery.isEmptyObject(events)) {
        delete elemData.handle;
        data_priv.remove(elem, "events");
      }
    },
    trigger: function(event, data, elem, onlyHandlers) {
      var i,
          cur,
          tmp,
          bubbleType,
          ontype,
          handle,
          special,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return ;
      }
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return ;
      }
      if (type.indexOf(".") >= 0) {
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(":") < 0 && "on" + type;
      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] : jQuery.makeArray(data, [event]);
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return ;
      }
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type;
        handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype && cur[ontype];
        if (handle && handle.apply && jQuery.acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if (event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
          if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    dispatch: function(event) {
      event = jQuery.event.fix(event);
      var i,
          j,
          ret,
          matched,
          handleObj,
          handlerQueue = [],
          args = slice.call(arguments),
          handlers = (data_priv.get(this, "events") || {})[event.type] || [],
          special = jQuery.event.special[event.type] || {};
      args[0] = event;
      event.delegateTarget = this;
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return ;
      }
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function(event, handlers) {
      var i,
          matches,
          sel,
          handleObj,
          handlerQueue = [],
          delegateCount = handlers.delegateCount,
          cur = event.target;
      if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.disabled !== true || event.type !== "click") {
            matches = [];
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector + " ";
              if (matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matches[sel]) {
                matches.push(handleObj);
              }
            }
            if (matches.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matches
              });
            }
          }
        }
      }
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: this,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function(event, original) {
        if (event.which == null) {
          event.which = original.charCode != null ? original.charCode : original.keyCode;
        }
        return event;
      }
    },
    mouseHooks: {
      props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
      filter: function(event, original) {
        var eventDoc,
            doc,
            body,
            button = original.button;
        if (event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        if (!event.which && button !== undefined) {
          event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
        }
        return event;
      }
    },
    fix: function(event) {
      if (event[jQuery.expando]) {
        return event;
      }
      var i,
          prop,
          copy,
          type = event.type,
          originalEvent = event,
          fixHook = this.fixHooks[type];
      if (!fixHook) {
        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
      }
      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
      event = new jQuery.Event(originalEvent);
      i = copy.length;
      while (i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      }
      if (!event.target) {
        event.target = document;
      }
      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      }
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },
    special: {
      load: {noBubble: true},
      focus: {
        trigger: function() {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
            this.click();
            return false;
          }
        },
        _default: function(event) {
          return jQuery.nodeName(event.target, "a");
        }
      },
      beforeunload: {postDispatch: function(event) {
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }}
    },
    simulate: function(type, elem, event, bubble) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true,
        originalEvent: {}
      });
      if (bubble) {
        jQuery.event.trigger(e, null, elem);
      } else {
        jQuery.event.dispatch.call(elem, e);
      }
      if (e.isDefaultPrevented()) {
        event.preventDefault();
      }
    }
  };
  jQuery.removeEvent = function(elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle, false);
    }
  };
  jQuery.Event = function(src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = src && src.timeStamp || jQuery.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    preventDefault: function() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e && e.preventDefault) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e && e.stopPropagation) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;
      if (e && e.stopImmediatePropagation) {
        e.stopImmediatePropagation();
      }
      this.stopPropagation();
    }
  };
  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function(orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function(event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj;
        if (!related || (related !== target && !jQuery.contains(target, related))) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  if (!support.focusinBubbles) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function(orig, fix) {
      var handler = function(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
      };
      jQuery.event.special[fix] = {
        setup: function() {
          var doc = this.ownerDocument || this,
              attaches = data_priv.access(doc, fix);
          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          data_priv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function() {
          var doc = this.ownerDocument || this,
              attaches = data_priv.access(doc, fix) - 1;
          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            data_priv.remove(doc, fix);
          } else {
            data_priv.access(doc, fix, attaches);
          }
        }
      };
    });
  }
  jQuery.fn.extend({
    on: function(types, selector, data, fn, one) {
      var origFn,
          type;
      if (typeof types === "object") {
        if (typeof selector !== "string") {
          data = data || selector;
          selector = undefined;
        }
        for (type in types) {
          this.on(type, selector, data, types[type], one);
        }
        return this;
      }
      if (data == null && fn == null) {
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === "string") {
          fn = data;
          data = undefined;
        } else {
          fn = data;
          data = selector;
          selector = undefined;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return this;
      }
      if (one === 1) {
        origFn = fn;
        fn = function(event) {
          jQuery().off(event);
          return origFn.apply(this, arguments);
        };
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return this.each(function() {
        jQuery.event.add(this, types, fn, data, selector);
      });
    },
    one: function(types, selector, data, fn) {
      return this.on(types, selector, data, fn, 1);
    },
    off: function(types, selector, fn) {
      var handleObj,
          type;
      if (types && types.preventDefault && types.handleObj) {
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (typeof types === "object") {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === "function") {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function() {
        jQuery.event.remove(this, types, fn, selector);
      });
    },
    trigger: function(type, data) {
      return this.each(function() {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function(type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
      rtagName = /<([\w:]+)/,
      rhtml = /<|&#?\w+;/,
      rnoInnerhtml = /<(?:script|style|link)/i,
      rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rscriptType = /^$|\/(?:java|ecma)script/i,
      rscriptTypeMasked = /^true\/(.*)/,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
      wrapMap = {
        option: [1, "<select multiple='multiple'>", "</select>"],
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
      };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
  }
  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute("type");
    }
    return elem;
  }
  function setGlobalEval(elems, refElements) {
    var i = 0,
        l = elems.length;
    for (; i < l; i++) {
      data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"));
    }
  }
  function cloneCopyEvent(src, dest) {
    var i,
        l,
        type,
        pdataOld,
        pdataCur,
        udataOld,
        udataCur,
        events;
    if (dest.nodeType !== 1) {
      return ;
    }
    if (data_priv.hasData(src)) {
      pdataOld = data_priv.access(src);
      pdataCur = data_priv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (data_user.hasData(src)) {
      udataOld = data_user.access(src);
      udataCur = jQuery.extend({}, udataOld);
      data_user.set(dest, udataCur);
    }
  }
  function getAll(context, tag) {
    var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
  }
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }
  jQuery.extend({
    clone: function(elem, dataAndEvents, deepDataAndEvents) {
      var i,
          l,
          srcElements,
          destElements,
          clone = elem.cloneNode(true),
          inPage = jQuery.contains(elem.ownerDocument, elem);
      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, "script");
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      }
      return clone;
    },
    buildFragment: function(elems, context, scripts, selection) {
      var elem,
          tmp,
          tag,
          wrap,
          contains,
          j,
          fragment = context.createDocumentFragment(),
          nodes = [],
          i = 0,
          l = elems.length;
      for (; i < l; i++) {
        elem = elems[i];
        if (elem || elem === 0) {
          if (jQuery.type(elem) === "object") {
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));
          } else {
            tmp = tmp || fragment.appendChild(context.createElement("div"));
            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            jQuery.merge(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
          }
        }
      }
      fragment.textContent = "";
      i = 0;
      while ((elem = nodes[i++])) {
        if (selection && jQuery.inArray(elem, selection) !== -1) {
          continue;
        }
        contains = jQuery.contains(elem.ownerDocument, elem);
        tmp = getAll(fragment.appendChild(elem), "script");
        if (contains) {
          setGlobalEval(tmp);
        }
        if (scripts) {
          j = 0;
          while ((elem = tmp[j++])) {
            if (rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }
      return fragment;
    },
    cleanData: function(elems) {
      var data,
          elem,
          type,
          key,
          special = jQuery.event.special,
          i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (jQuery.acceptData(elem)) {
          key = elem[data_priv.expando];
          if (key && (data = data_priv.cache[key])) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            if (data_priv.cache[key]) {
              delete data_priv.cache[key];
            }
          }
        }
        delete data_user.cache[elem[data_user.expando]];
      }
    }
  });
  jQuery.fn.extend({
    text: function(value) {
      return access(this, function(value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function() {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function() {
      return this.domManip(arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function() {
      return this.domManip(arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function() {
      return this.domManip(arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function() {
      return this.domManip(arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    remove: function(selector, keepData) {
      var elem,
          elems = selector ? jQuery.filter(selector, this) : this,
          i = 0;
      for (; (elem = elems[i]) != null; i++) {
        if (!keepData && elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem));
        }
        if (elem.parentNode) {
          if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
            setGlobalEval(getAll(elem, "script"));
          }
          elem.parentNode.removeChild(elem);
        }
      }
      return this;
    },
    empty: function() {
      var elem,
          i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
          elem.textContent = "";
        }
      }
      return this;
    },
    clone: function(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function() {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function(value) {
      return access(this, function(value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }
        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = value.replace(rxhtmlTag, "<$1></$2>");
          try {
            for (; i < l; i++) {
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;
          } catch (e) {}
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function() {
      var arg = arguments[0];
      this.domManip(arguments, function(elem) {
        arg = this.parentNode;
        jQuery.cleanData(getAll(this));
        if (arg) {
          arg.replaceChild(elem, this);
        }
      });
      return arg && (arg.length || arg.nodeType) ? this : this.remove();
    },
    detach: function(selector) {
      return this.remove(selector, true);
    },
    domManip: function(args, callback) {
      args = concat.apply([], args);
      var fragment,
          first,
          scripts,
          hasScripts,
          node,
          doc,
          i = 0,
          l = this.length,
          set = this,
          iNoClone = l - 1,
          value = args[0],
          isFunction = jQuery.isFunction(value);
      if (isFunction || (l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value))) {
        return this.each(function(index) {
          var self = set.eq(index);
          if (isFunction) {
            args[0] = value.call(this, index, self.html());
          }
          self.domManip(args, callback);
        });
      }
      if (l) {
        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first) {
          scripts = jQuery.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length;
          for (; i < l; i++) {
            node = fragment;
            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true);
              if (hasScripts) {
                jQuery.merge(scripts, getAll(node, "script"));
              }
            }
            callback.call(this[i], node, i);
          }
          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;
            jQuery.map(scripts, restoreScript);
            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];
              if (rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                if (node.src) {
                  if (jQuery._evalUrl) {
                    jQuery._evalUrl(node.src);
                  }
                } else {
                  jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                }
              }
            }
          }
        }
      }
      return this;
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(name, original) {
    jQuery.fn[name] = function(selector) {
      var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  var iframe,
      elemdisplay = {};
  function actualDisplay(name, doc) {
    var style,
        elem = jQuery(doc.createElement(name)).appendTo(doc.body),
        display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display : jQuery.css(elem[0], "display");
    elem.detach();
    return display;
  }
  function defaultDisplay(nodeName) {
    var doc = document,
        display = elemdisplay[nodeName];
    if (!display) {
      display = actualDisplay(nodeName, doc);
      if (display === "none" || !display) {
        iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
        doc = iframe[0].contentDocument;
        doc.write();
        doc.close();
        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }
      elemdisplay[nodeName] = display;
    }
    return display;
  }
  var rmargin = (/^margin/);
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
  var getStyles = function(elem) {
    if (elem.ownerDocument.defaultView.opener) {
      return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
    }
    return window.getComputedStyle(elem, null);
  };
  function curCSS(elem, name, computed) {
    var width,
        minWidth,
        maxWidth,
        ret,
        style = elem.style;
    computed = computed || getStyles(elem);
    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];
    }
    if (computed) {
      if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      }
      if (rnumnonpx.test(ret) && rmargin.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret !== undefined ? ret + "" : ret;
  }
  function addGetHookIf(conditionFn, hookFn) {
    return {get: function() {
        if (conditionFn()) {
          delete this.get;
          return ;
        }
        return (this.get = hookFn).apply(this, arguments);
      }};
  }
  (function() {
    var pixelPositionVal,
        boxSizingReliableVal,
        docElem = document.documentElement,
        container = document.createElement("div"),
        div = document.createElement("div");
    if (!div.style) {
      return ;
    }
    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" + "position:absolute";
    container.appendChild(div);
    function computePixelPositionAndBoxSizingReliable() {
      div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" + "box-sizing:border-box;display:block;margin-top:1%;top:1%;" + "border:1px;padding:1px;width:4px;position:absolute";
      div.innerHTML = "";
      docElem.appendChild(container);
      var divStyle = window.getComputedStyle(div, null);
      pixelPositionVal = divStyle.top !== "1%";
      boxSizingReliableVal = divStyle.width === "4px";
      docElem.removeChild(container);
    }
    if (window.getComputedStyle) {
      jQuery.extend(support, {
        pixelPosition: function() {
          computePixelPositionAndBoxSizingReliable();
          return pixelPositionVal;
        },
        boxSizingReliable: function() {
          if (boxSizingReliableVal == null) {
            computePixelPositionAndBoxSizingReliable();
          }
          return boxSizingReliableVal;
        },
        reliableMarginRight: function() {
          var ret,
              marginDiv = div.appendChild(document.createElement("div"));
          marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" + "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
          marginDiv.style.marginRight = marginDiv.style.width = "0";
          div.style.width = "1px";
          docElem.appendChild(container);
          ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);
          docElem.removeChild(container);
          div.removeChild(marginDiv);
          return ret;
        }
      });
    }
  })();
  jQuery.swap = function(elem, options, callback, args) {
    var ret,
        name,
        old = {};
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }
    ret = callback.apply(elem, args || []);
    for (name in options) {
      elem.style[name] = old[name];
    }
    return ret;
  };
  var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
      rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),
      cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
      },
      cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      },
      cssPrefixes = ["Webkit", "O", "Moz", "ms"];
  function vendorPropName(style, name) {
    if (name in style) {
      return name;
    }
    var capName = name[0].toUpperCase() + name.slice(1),
        origName = name,
        i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in style) {
        return name;
      }
    }
    return origName;
  }
  function setPositiveNumber(elem, value, subtract) {
    var matches = rnumsplit.exec(value);
    return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
  }
  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0,
        val = 0;
    for (; i < 4; i += 2) {
      if (extra === "margin") {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        if (extra === "content") {
          val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        }
        if (extra !== "margin") {
          val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      } else {
        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        if (extra !== "padding") {
          val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    }
    return val;
  }
  function getWidthOrHeight(elem, name, extra) {
    var valueIsBorderBox = true,
        val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
        styles = getStyles(elem),
        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
    if (val <= 0 || val == null) {
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }
      if (rnumnonpx.test(val)) {
        return val;
      }
      valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
      val = parseFloat(val) || 0;
    }
    return (val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles)) + "px";
  }
  function showHide(elements, show) {
    var display,
        elem,
        hidden,
        values = [],
        index = 0,
        length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      values[index] = data_priv.get(elem, "olddisplay");
      display = elem.style.display;
      if (show) {
        if (!values[index] && display === "none") {
          elem.style.display = "";
        }
        if (elem.style.display === "" && isHidden(elem)) {
          values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
        }
      } else {
        hidden = isHidden(elem);
        if (display !== "none" || !hidden) {
          data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
        }
      }
    }
    for (index = 0; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      if (!show || elem.style.display === "none" || elem.style.display === "") {
        elem.style.display = show ? values[index] || "" : "none";
      }
    }
    return elements;
  }
  jQuery.extend({
    cssHooks: {opacity: {get: function(elem, computed) {
          if (computed) {
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }}},
    cssNumber: {
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    cssProps: {"float": "cssFloat"},
    style: function(elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return ;
      }
      var ret,
          type,
          hooks,
          origName = jQuery.camelCase(name),
          style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === "string" && (ret = rrelNum.exec(value))) {
          value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
          type = "number";
        }
        if (value == null || value !== value) {
          return ;
        }
        if (type === "number" && !jQuery.cssNumber[origName]) {
          value += "px";
        }
        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        }
        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          style[name] = value;
        }
      } else {
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        return style[name];
      }
    },
    css: function(elem, name, extra, styles) {
      var val,
          num,
          hooks,
          origName = jQuery.camelCase(name);
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
      }
      return val;
    }
  });
  jQuery.each(["height", "width"], function(i, name) {
    jQuery.cssHooks[name] = {
      get: function(elem, computed, extra) {
        if (computed) {
          return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function() {
            return getWidthOrHeight(elem, name, extra);
          }) : getWidthOrHeight(elem, name, extra);
        }
      },
      set: function(elem, value, extra) {
        var styles = extra && getStyles(elem);
        return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles) : 0);
      }
    };
  });
  jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
    if (computed) {
      return jQuery.swap(elem, {"display": "inline-block"}, curCSS, [elem, "marginRight"]);
    }
  });
  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {expand: function(value) {
        var i = 0,
            expanded = {},
            parts = typeof value === "string" ? value.split(" ") : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }};
    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function(name, value) {
      return access(this, function(elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;
        if (jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    },
    show: function() {
      return showHide(this, true);
    },
    hide: function() {
      return showHide(this);
    },
    toggle: function(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }
      return this.each(function() {
        if (isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || "swing";
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function(percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {_default: {
      get: function(tween) {
        var result;
        if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
          return tween.elem[tween.prop];
        }
        result = jQuery.css(tween.elem, tween.prop, "");
        return !result || result === "auto" ? 0 : result;
      },
      set: function(tween) {
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }};
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {set: function(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }};
  jQuery.easing = {
    linear: function(p) {
      return p;
    },
    swing: function(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    }
  };
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.step = {};
  var fxNow,
      timerId,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
      rrun = /queueHooks$/,
      animationPrefilters = [defaultPrefilter],
      tweeners = {"*": [function(prop, value) {
          var tween = this.createTween(prop, value),
              target = tween.cur(),
              parts = rfxnum.exec(value),
              unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
              start = (jQuery.cssNumber[prop] || unit !== "px" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)),
              scale = 1,
              maxIterations = 20;
          if (start && start[3] !== unit) {
            unit = unit || start[3];
            parts = parts || [];
            start = +target || 1;
            do {
              scale = scale || ".5";
              start = start / scale;
              jQuery.style(tween.elem, prop, start + unit);
            } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
          }
          if (parts) {
            start = tween.start = +start || +target || 0;
            tween.unit = unit;
            tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
          }
          return tween;
        }]};
  function createFxNow() {
    setTimeout(function() {
      fxNow = undefined;
    });
    return (fxNow = jQuery.now());
  }
  function genFx(type, includeWidth) {
    var which,
        i = 0,
        attrs = {height: type};
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  function createTween(value, prop, animation) {
    var tween,
        collection = (tweeners[prop] || []).concat(tweeners["*"]),
        index = 0,
        length = collection.length;
    for (; index < length; index++) {
      if ((tween = collection[index].call(animation, prop, value))) {
        return tween;
      }
    }
  }
  function defaultPrefilter(elem, props, opts) {
    var prop,
        value,
        toggle,
        tween,
        hooks,
        oldfire,
        display,
        checkDisplay,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHidden(elem),
        dataShow = data_priv.get(elem, "fxshow");
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function() {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function() {
        anim.always(function() {
          hooks.unqueued--;
          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    }
    if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];
      display = jQuery.css(elem, "display");
      checkDisplay = display === "none" ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
      if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
        style.display = "inline-block";
      }
    }
    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function() {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";
        if (value === (hidden ? "hide" : "show")) {
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      } else {
        display = undefined;
      }
    }
    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ("hidden" in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = data_priv.access(elem, "fxshow", {});
      }
      if (toggle) {
        dataShow.hidden = !hidden;
      }
      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function() {
          jQuery(elem).hide();
        });
      }
      anim.done(function() {
        var prop;
        data_priv.remove(elem, "fxshow");
        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === "width" || prop === "height" ? 1 : 0;
          }
        }
      }
    } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
      style.display = display;
    }
  }
  function propFilter(props, specialEasing) {
    var index,
        name,
        easing,
        value,
        hooks;
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = animationPrefilters.length,
        deferred = jQuery.Deferred().always(function() {
          delete tick.elem;
        }),
        tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(),
              remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
              temp = remaining / animation.duration || 0,
              percent = 1 - temp,
              index = 0,
              length = animation.tweens.length;
          for (; index < length; index++) {
            animation.tweens[index].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length) {
            return remaining;
          } else {
            deferred.resolveWith(elem, [animation]);
            return false;
          }
        },
        animation = deferred.promise({
          elem: elem,
          props: jQuery.extend({}, properties),
          opts: jQuery.extend(true, {specialEasing: {}}, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function(prop, end) {
            var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
            animation.tweens.push(tween);
            return tween;
          },
          stop: function(gotoEnd) {
            var index = 0,
                length = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index < length; index++) {
              animation.tweens[index].run(1);
            }
            if (gotoEnd) {
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }),
        props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = animationPrefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweener: function(props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.split(" ");
      }
      var prop,
          index = 0,
          length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        tweeners[prop] = tweeners[prop] || [];
        tweeners[prop].unshift(callback);
      }
    },
    prefilter: function(callback, prepend) {
      if (prepend) {
        animationPrefilters.unshift(callback);
      } else {
        animationPrefilters.push(callback);
      }
    }
  });
  jQuery.speed = function(speed, easing, fn) {
    var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
    };
    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    }
    opt.old = opt.complete;
    opt.complete = function() {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.fn.extend({
    fadeTo: function(speed, to, easing, callback) {
      return this.filter(isHidden).css("opacity", 0).show().end().animate({opacity: to}, speed, easing, callback);
    },
    animate: function(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function() {
            var anim = Animation(this, jQuery.extend({}, prop), optall);
            if (empty || data_priv.get(this, "finish")) {
              anim.stop(true);
            }
          };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function(type, clearQueue, gotoEnd) {
      var stopQueue = function(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }
      return this.each(function() {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = data_priv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function(type) {
      if (type !== false) {
        type = type || "fx";
      }
      return this.each(function() {
        var index,
            data = data_priv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0;
        data.finish = true;
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function(i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function(speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {opacity: "show"},
    fadeOut: {opacity: "hide"},
    fadeToggle: {opacity: "toggle"}
  }, function(name, props) {
    jQuery.fn[name] = function(speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];
  jQuery.fx.tick = function() {
    var timer,
        i = 0,
        timers = jQuery.timers;
    fxNow = jQuery.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function(timer) {
    jQuery.timers.push(timer);
    if (timer()) {
      jQuery.fx.start();
    } else {
      jQuery.timers.pop();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function() {
    if (!timerId) {
      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function() {
    clearInterval(timerId);
    timerId = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  jQuery.fn.delay = function(time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function(next, hooks) {
      var timeout = setTimeout(next, time);
      hooks.stop = function() {
        clearTimeout(timeout);
      };
    });
  };
  (function() {
    var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox";
    support.checkOn = input.value !== "";
    support.optSelected = opt.selected;
    select.disabled = true;
    support.optDisabled = !opt.disabled;
    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();
  var nodeHook,
      boolHook,
      attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function(name) {
      return this.each(function() {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function(elem, name, value) {
      var hooks,
          ret,
          nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return ;
      }
      if (typeof elem.getAttribute === strundefined) {
        return jQuery.prop(elem, name, value);
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
        } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        } else {
          elem.setAttribute(name, value + "");
          return value;
        }
      } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      } else {
        ret = jQuery.find.attr(elem, name);
        return ret == null ? undefined : ret;
      }
    },
    removeAttr: function(elem, value) {
      var name,
          propName,
          i = 0,
          attrNames = value && value.match(rnotwhite);
      if (attrNames && elem.nodeType === 1) {
        while ((name = attrNames[i++])) {
          propName = jQuery.propFix[name] || name;
          if (jQuery.expr.match.bool.test(name)) {
            elem[propName] = false;
          }
          elem.removeAttribute(name);
        }
      }
    },
    attrHooks: {type: {set: function(elem, value) {
          if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }}}
  });
  boolHook = {set: function(elem, value, name) {
      if (value === false) {
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }};
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;
    attrHandle[name] = function(elem, name, isXML) {
      var ret,
          handle;
      if (!isXML) {
        handle = attrHandle[name];
        attrHandle[name] = ret;
        ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
        attrHandle[name] = handle;
      }
      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i;
  jQuery.fn.extend({
    prop: function(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function(name) {
      return this.each(function() {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    propFix: {
      "for": "htmlFor",
      "class": "className"
    },
    prop: function(elem, name, value) {
      var ret,
          hooks,
          notxml,
          nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return ;
      }
      notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
      if (notxml) {
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : (elem[name] = value);
      } else {
        return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
      }
    },
    propHooks: {tabIndex: {get: function(elem) {
          return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
        }}}
  });
  if (!support.optSelected) {
    jQuery.propHooks.selected = {get: function(elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      }};
  }
  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  var rclass = /[\t\r\n\f]/g;
  jQuery.fn.extend({
    addClass: function(value) {
      var classes,
          elem,
          cur,
          clazz,
          j,
          finalValue,
          proceed = typeof value === "string" && value,
          i = 0,
          len = this.length;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).addClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || "").match(rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            }
            finalValue = jQuery.trim(cur);
            if (elem.className !== finalValue) {
              elem.className = finalValue;
            }
          }
        }
      }
      return this;
    },
    removeClass: function(value) {
      var classes,
          elem,
          cur,
          clazz,
          j,
          finalValue,
          proceed = arguments.length === 0 || typeof value === "string" && value,
          i = 0,
          len = this.length;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).removeClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || "").match(rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              while (cur.indexOf(" " + clazz + " ") >= 0) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            }
            finalValue = value ? jQuery.trim(cur) : "";
            if (elem.className !== finalValue) {
              elem.className = finalValue;
            }
          }
        }
      }
      return this;
    },
    toggleClass: function(value, stateVal) {
      var type = typeof value;
      if (typeof stateVal === "boolean" && type === "string") {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (jQuery.isFunction(value)) {
        return this.each(function(i) {
          jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
        });
      }
      return this.each(function() {
        if (type === "string") {
          var className,
              i = 0,
              self = jQuery(this),
              classNames = value.match(rnotwhite) || [];
          while ((className = classNames[i++])) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (type === strundefined || type === "boolean") {
          if (this.className) {
            data_priv.set(this, "__className__", this.className);
          }
          this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
        }
      });
    },
    hasClass: function(selector) {
      var className = " " + selector + " ",
          i = 0,
          l = this.length;
      for (; i < l; i++) {
        if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
          return true;
        }
      }
      return false;
    }
  });
  var rreturn = /\r/g;
  jQuery.fn.extend({val: function(value) {
      var hooks,
          ret,
          isFunction,
          elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }
          ret = elem.value;
          return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
        }
        return ;
      }
      isFunction = jQuery.isFunction(value);
      return this.each(function(i) {
        var val;
        if (this.nodeType !== 1) {
          return ;
        }
        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function(value) {
            return value == null ? "" : value + "";
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }});
  jQuery.extend({valHooks: {
      option: {get: function(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : jQuery.trim(jQuery.text(elem));
        }},
      select: {
        get: function(elem) {
          var value,
              option,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one" || index < 0,
              values = one ? null : [],
              max = one ? index + 1 : options.length,
              i = index < 0 ? max : one ? index : 0;
          for (; i < max; i++) {
            option = options[i];
            if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
              value = jQuery(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function(elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;
          while (i--) {
            option = options[i];
            if ((option.selected = jQuery.inArray(option.value, values) >= 0)) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    }});
  jQuery.each(["radio", "checkbox"], function() {
    jQuery.valHooks[this] = {set: function(elem, value) {
        if (jQuery.isArray(value)) {
          return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0);
        }
      }};
    if (!support.checkOn) {
      jQuery.valHooks[this].get = function(elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });
  jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
    jQuery.fn[name] = function(data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({
    hover: function(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    },
    bind: function(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function(selector, types, fn) {
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    }
  });
  var nonce = jQuery.now();
  var rquery = (/\?/);
  jQuery.parseJSON = function(data) {
    return JSON.parse(data + "");
  };
  jQuery.parseXML = function(data) {
    var xml,
        tmp;
    if (!data || typeof data !== "string") {
      return null;
    }
    try {
      tmp = new DOMParser();
      xml = tmp.parseFromString(data, "text/xml");
    } catch (e) {
      xml = undefined;
    }
    if (!xml || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }
    return xml;
  };
  var rhash = /#.*$/,
      rts = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
      rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,
      rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
      prefilters = {},
      transports = {},
      allTypes = "*/".concat("*"),
      ajaxLocation = window.location.href,
      ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
  function addToPrefiltersOrTransports(structure) {
    return function(dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }
      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
      if (jQuery.isFunction(func)) {
        while ((dataType = dataTypes[i++])) {
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = (structure === transports);
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  }
  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes;
    while (dataTypes[0] === "*") {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === "*") {
          current = prev;
        } else if (prev !== "*" && prev !== current) {
          conv = converters[prev + " " + current] || converters["* " + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(" ");
              if (tmp[1] === current) {
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv && s["throws"]) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: "success",
      data: response
    };
  }
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: ajaxLocation,
      type: "GET",
      isLocal: rlocalProtocol.test(ajaxLocParts[1]),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": true,
        "text json": jQuery.parseJSON,
        "text xml": jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function(target, settings) {
      return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function(url, options) {
      if (typeof url === "object") {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport,
          cacheURL,
          responseHeadersString,
          responseHeaders,
          timeoutTimer,
          parts,
          fireGlobals,
          i,
          s = jQuery.ajaxSetup({}, options),
          callbackContext = s.context || s,
          globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          statusCode = s.statusCode || {},
          requestHeaders = {},
          requestHeadersNames = {},
          state = 0,
          strAbort = "canceled",
          jqXHR = {
            readyState: 0,
            getResponseHeader: function(key) {
              var match;
              if (state === 2) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while ((match = rheaders.exec(responseHeadersString))) {
                    responseHeaders[match[1].toLowerCase()] = match[2];
                  }
                }
                match = responseHeaders[key.toLowerCase()];
              }
              return match == null ? null : match;
            },
            getAllResponseHeaders: function() {
              return state === 2 ? responseHeadersString : null;
            },
            setRequestHeader: function(name, value) {
              var lname = name.toLowerCase();
              if (!state) {
                name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                requestHeaders[name] = value;
              }
              return this;
            },
            overrideMimeType: function(type) {
              if (!state) {
                s.mimeType = type;
              }
              return this;
            },
            statusCode: function(map) {
              var code;
              if (map) {
                if (state < 2) {
                  for (code in map) {
                    statusCode[code] = [statusCode[code], map[code]];
                  }
                } else {
                  jqXHR.always(map[jqXHR.status]);
                }
              }
              return this;
            },
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;
      s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];
      if (s.crossDomain == null) {
        parts = rurl.exec(s.url.toLowerCase());
        s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))));
      }
      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (state === 2) {
        return jqXHR;
      }
      fireGlobals = jQuery.event && s.global;
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url;
      if (!s.hasContent) {
        if (s.data) {
          cacheURL = (s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data);
          delete s.data;
        }
        if (s.cache === false) {
          s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
        }
      }
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      }
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      }
      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
        return jqXHR.abort();
      }
      strAbort = "abort";
      for (i in {
        success: 1,
        error: 1,
        complete: 1
      }) {
        jqXHR[i](s[i]);
      }
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        }
        if (s.async && s.timeout > 0) {
          timeoutTimer = setTimeout(function() {
            jqXHR.abort("timeout");
          }, s.timeout);
        }
        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (state < 2) {
            done(-1, e);
          } else {
            throw e;
          }
        }
      }
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText;
        if (state === 2) {
          return ;
        }
        state = 2;
        if (timeoutTimer) {
          clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || "";
        jqXHR.readyState = status > 0 ? 4 : 0;
        isSuccess = status >= 200 && status < 300 || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader("etag");
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent";
          } else if (status === 304) {
            statusText = "notmodified";
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = "error";
            if (status < 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + "";
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        }
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        }
        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
          if (!(--jQuery.active)) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }
      return jqXHR;
    },
    getJSON: function(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function(i, method) {
    jQuery[method] = function(url, data, callback, type) {
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      });
    };
  });
  jQuery._evalUrl = function(url) {
    return jQuery.ajax({
      url: url,
      type: "GET",
      dataType: "script",
      async: false,
      global: false,
      "throws": true
    });
  };
  jQuery.fn.extend({
    wrapAll: function(html) {
      var wrap;
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }
      if (this[0]) {
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function() {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function(html) {
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function() {
        var self = jQuery(this),
            contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function(html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function(i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function() {
      return this.parent().each(function() {
        if (!jQuery.nodeName(this, "body")) {
          jQuery(this).replaceWith(this.childNodes);
        }
      }).end();
    }
  });
  jQuery.expr.filters.hidden = function(elem) {
    return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
  };
  jQuery.expr.filters.visible = function(elem) {
    return !jQuery.expr.filters.hidden(elem);
  };
  var r20 = /%20/g,
      rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      jQuery.each(obj, function(i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && jQuery.type(obj) === "object") {
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  jQuery.param = function(a, traditional) {
    var prefix,
        s = [],
        add = function(key, value) {
          value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
          s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };
    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }
    if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
      jQuery.each(a, function() {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join("&").replace(r20, "+");
  };
  jQuery.fn.extend({
    serialize: function() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function() {
      return this.map(function() {
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function() {
        var type = this.type;
        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function(i, elem) {
        var val = jQuery(this).val();
        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
          return {
            name: elem.name,
            value: val.replace(rCRLF, "\r\n")
          };
        }) : {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  jQuery.ajaxSettings.xhr = function() {
    try {
      return new XMLHttpRequest();
    } catch (e) {}
  };
  var xhrId = 0,
      xhrCallbacks = {},
      xhrSuccessStatus = {
        0: 200,
        1223: 204
      },
      xhrSupported = jQuery.ajaxSettings.xhr();
  if (window.attachEvent) {
    window.attachEvent("onunload", function() {
      for (var key in xhrCallbacks) {
        xhrCallbacks[key]();
      }
    });
  }
  support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function(options) {
    var callback;
    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function(headers, complete) {
          var i,
              xhr = options.xhr(),
              id = ++xhrId;
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          callback = function(type) {
            return function() {
              if (callback) {
                delete xhrCallbacks[id];
                callback = xhr.onload = xhr.onerror = null;
                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  complete(xhr.status, xhr.statusText);
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === "string" ? {text: xhr.responseText} : undefined, xhr.getAllResponseHeaders());
                }
              }
            };
          };
          xhr.onload = callback();
          xhr.onerror = callback("error");
          callback = xhrCallbacks[id] = callback("abort");
          try {
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            if (callback) {
              throw e;
            }
          }
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  jQuery.ajaxSetup({
    accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},
    contents: {script: /(?:java|ecma)script/},
    converters: {"text script": function(text) {
        jQuery.globalEval(text);
        return text;
      }}
  });
  jQuery.ajaxPrefilter("script", function(s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = "GET";
    }
  });
  jQuery.ajaxTransport("script", function(s) {
    if (s.crossDomain) {
      var script,
          callback;
      return {
        send: function(_, complete) {
          script = jQuery("<script>").prop({
            async: true,
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", callback = function(evt) {
            script.remove();
            callback = null;
            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          });
          document.head.appendChild(script[0]);
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/;
  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
      this[callback] = true;
      return callback;
    }
  });
  jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
    if (jsonProp || s.dataTypes[0] === "jsonp") {
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      }
      s.converters["script json"] = function() {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = "json";
      overwritten = window[callbackName];
      window[callbackName] = function() {
        responseContainer = arguments;
      };
      jqXHR.always(function() {
        window[callbackName] = overwritten;
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return "script";
    }
  });
  jQuery.parseHTML = function(data, context, keepScripts) {
    if (!data || typeof data !== "string") {
      return null;
    }
    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }
    context = context || document;
    var parsed = rsingleTag.exec(data),
        scripts = !keepScripts && [];
    if (parsed) {
      return [context.createElement(parsed[1])];
    }
    parsed = jQuery.buildFragment([data], context, scripts);
    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }
    return jQuery.merge([], parsed.childNodes);
  };
  var _load = jQuery.fn.load;
  jQuery.fn.load = function(url, params, callback) {
    if (typeof url !== "string" && _load) {
      return _load.apply(this, arguments);
    }
    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");
    if (off >= 0) {
      selector = jQuery.trim(url.slice(off));
      url = url.slice(0, off);
    }
    if (jQuery.isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params && typeof params === "object") {
      type = "POST";
    }
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        type: type,
        dataType: "html",
        data: params
      }).done(function(responseText) {
        response = arguments;
        self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
      }).complete(callback && function(jqXHR, status) {
        self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
      });
    }
    return this;
  };
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
    jQuery.fn[type] = function(fn) {
      return this.on(type, fn);
    };
  });
  jQuery.expr.filters.animated = function(elem) {
    return jQuery.grep(jQuery.timers, function(fn) {
      return elem === fn.elem;
    }).length;
  };
  var docElem = window.document.documentElement;
  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
  }
  jQuery.offset = {setOffset: function(elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {};
      if (position === "static") {
        elem.style.position = "relative";
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, curOffset);
      }
      if (options.top != null) {
        props.top = (options.top - curOffset.top) + curTop;
      }
      if (options.left != null) {
        props.left = (options.left - curOffset.left) + curLeft;
      }
      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }};
  jQuery.fn.extend({
    offset: function(options) {
      if (arguments.length) {
        return options === undefined ? this : this.each(function(i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }
      var docElem,
          win,
          elem = this[0],
          box = {
            top: 0,
            left: 0
          },
          doc = elem && elem.ownerDocument;
      if (!doc) {
        return ;
      }
      docElem = doc.documentElement;
      if (!jQuery.contains(docElem, elem)) {
        return box;
      }
      if (typeof elem.getBoundingClientRect !== strundefined) {
        box = elem.getBoundingClientRect();
      }
      win = getWindow(doc);
      return {
        top: box.top + win.pageYOffset - docElem.clientTop,
        left: box.left + win.pageXOffset - docElem.clientLeft
      };
    },
    position: function() {
      if (!this[0]) {
        return ;
      }
      var offsetParent,
          offset,
          elem = this[0],
          parentOffset = {
            top: 0,
            left: 0
          };
      if (jQuery.css(elem, "position") === "fixed") {
        offset = elem.getBoundingClientRect();
      } else {
        offsetParent = this.offsetParent();
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], "html")) {
          parentOffset = offsetParent.offset();
        }
        parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
        parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
      }
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    offsetParent: function() {
      return this.map(function() {
        var offsetParent = this.offsetParent || docElem;
        while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docElem;
      });
    }
  });
  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function(method, prop) {
    var top = "pageYOffset" === prop;
    jQuery.fn[method] = function(val) {
      return access(this, function(elem, method, val) {
        var win = getWindow(elem);
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length, null);
    };
  });
  jQuery.each(["top", "left"], function(i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop);
        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  });
  jQuery.each({
    Height: "height",
    Width: "width"
  }, function(name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function(defaultExtra, funcName) {
      jQuery.fn[funcName] = function(margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function(elem, type, value) {
          var doc;
          if (jQuery.isWindow(elem)) {
            return elem.document.documentElement["client" + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }
          return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  });
  jQuery.fn.size = function() {
    return this.length;
  };
  jQuery.fn.andSelf = jQuery.fn.addBack;
  if (typeof define === "function" && define.amd) {
    System.register("github:components/jquery@2.1.4/jquery", [], false, function(__require, __exports, __module) {
      return (function() {
        return jQuery;
      }).call(this);
    });
  }
  var _jQuery = window.jQuery,
      _$ = window.$;
  jQuery.noConflict = function(deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }
    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }
    return jQuery;
  };
  if (typeof noGlobal === strundefined) {
    window.jQuery = window.$ = jQuery;
  }
  return jQuery;
}));
})();
System.register("github:angular/bower-angular-resource@1.4.4/angular-resource", [], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, []);
  (function() {
    (function(window, angular, undefined) {
      'use strict';
      var $resourceMinErr = angular.$$minErr('$resource');
      var MEMBER_NAME_REGEX = /^(\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;
      function isValidDottedPath(path) {
        return (path != null && path !== '' && path !== 'hasOwnProperty' && MEMBER_NAME_REGEX.test('.' + path));
      }
      function lookupDottedPath(obj, path) {
        if (!isValidDottedPath(path)) {
          throw $resourceMinErr('badmember', 'Dotted member path "@{0}" is invalid.', path);
        }
        var keys = path.split('.');
        for (var i = 0,
            ii = keys.length; i < ii && obj !== undefined; i++) {
          var key = keys[i];
          obj = (obj !== null) ? obj[key] : undefined;
        }
        return obj;
      }
      function shallowClearAndCopy(src, dst) {
        dst = dst || {};
        angular.forEach(dst, function(value, key) {
          delete dst[key];
        });
        for (var key in src) {
          if (src.hasOwnProperty(key) && !(key.charAt(0) === '$' && key.charAt(1) === '$')) {
            dst[key] = src[key];
          }
        }
        return dst;
      }
      angular.module('ngResource', ['ng']).provider('$resource', function() {
        var provider = this;
        this.defaults = {
          stripTrailingSlashes: true,
          actions: {
            'get': {method: 'GET'},
            'save': {method: 'POST'},
            'query': {
              method: 'GET',
              isArray: true
            },
            'remove': {method: 'DELETE'},
            'delete': {method: 'DELETE'}
          }
        };
        this.$get = ['$http', '$q', function($http, $q) {
          var noop = angular.noop,
              forEach = angular.forEach,
              extend = angular.extend,
              copy = angular.copy,
              isFunction = angular.isFunction;
          function encodeUriSegment(val) {
            return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
          }
          function encodeUriQuery(val, pctEncodeSpaces) {
            return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
          }
          function Route(template, defaults) {
            this.template = template;
            this.defaults = extend({}, provider.defaults, defaults);
            this.urlParams = {};
          }
          Route.prototype = {setUrlParams: function(config, params, actionUrl) {
              var self = this,
                  url = actionUrl || self.template,
                  val,
                  encodedVal;
              var urlParams = self.urlParams = {};
              forEach(url.split(/\W/), function(param) {
                if (param === 'hasOwnProperty') {
                  throw $resourceMinErr('badname', "hasOwnProperty is not a valid parameter name.");
                }
                if (!(new RegExp("^\\d+$").test(param)) && param && (new RegExp("(^|[^\\\\]):" + param + "(\\W|$)").test(url))) {
                  urlParams[param] = true;
                }
              });
              url = url.replace(/\\:/g, ':');
              params = params || {};
              forEach(self.urlParams, function(_, urlParam) {
                val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam];
                if (angular.isDefined(val) && val !== null) {
                  encodedVal = encodeUriSegment(val);
                  url = url.replace(new RegExp(":" + urlParam + "(\\W|$)", "g"), function(match, p1) {
                    return encodedVal + p1;
                  });
                } else {
                  url = url.replace(new RegExp("(\/?):" + urlParam + "(\\W|$)", "g"), function(match, leadingSlashes, tail) {
                    if (tail.charAt(0) == '/') {
                      return tail;
                    } else {
                      return leadingSlashes + tail;
                    }
                  });
                }
              });
              if (self.defaults.stripTrailingSlashes) {
                url = url.replace(/\/+$/, '') || '/';
              }
              url = url.replace(/\/\.(?=\w+($|\?))/, '.');
              config.url = url.replace(/\/\\\./, '/.');
              forEach(params, function(value, key) {
                if (!self.urlParams[key]) {
                  config.params = config.params || {};
                  config.params[key] = value;
                }
              });
            }};
          function resourceFactory(url, paramDefaults, actions, options) {
            var route = new Route(url, options);
            actions = extend({}, provider.defaults.actions, actions);
            function extractParams(data, actionParams) {
              var ids = {};
              actionParams = extend({}, paramDefaults, actionParams);
              forEach(actionParams, function(value, key) {
                if (isFunction(value)) {
                  value = value();
                }
                ids[key] = value && value.charAt && value.charAt(0) == '@' ? lookupDottedPath(data, value.substr(1)) : value;
              });
              return ids;
            }
            function defaultResponseInterceptor(response) {
              return response.resource;
            }
            function Resource(value) {
              shallowClearAndCopy(value || {}, this);
            }
            Resource.prototype.toJSON = function() {
              var data = extend({}, this);
              delete data.$promise;
              delete data.$resolved;
              return data;
            };
            forEach(actions, function(action, name) {
              var hasBody = /^(POST|PUT|PATCH)$/i.test(action.method);
              Resource[name] = function(a1, a2, a3, a4) {
                var params = {},
                    data,
                    success,
                    error;
                switch (arguments.length) {
                  case 4:
                    error = a4;
                    success = a3;
                  case 3:
                  case 2:
                    if (isFunction(a2)) {
                      if (isFunction(a1)) {
                        success = a1;
                        error = a2;
                        break;
                      }
                      success = a2;
                      error = a3;
                    } else {
                      params = a1;
                      data = a2;
                      success = a3;
                      break;
                    }
                  case 1:
                    if (isFunction(a1))
                      success = a1;
                    else if (hasBody)
                      data = a1;
                    else
                      params = a1;
                    break;
                  case 0:
                    break;
                  default:
                    throw $resourceMinErr('badargs', "Expected up to 4 arguments [params, data, success, error], got {0} arguments", arguments.length);
                }
                var isInstanceCall = this instanceof Resource;
                var value = isInstanceCall ? data : (action.isArray ? [] : new Resource(data));
                var httpConfig = {};
                var responseInterceptor = action.interceptor && action.interceptor.response || defaultResponseInterceptor;
                var responseErrorInterceptor = action.interceptor && action.interceptor.responseError || undefined;
                forEach(action, function(value, key) {
                  if (key != 'params' && key != 'isArray' && key != 'interceptor') {
                    httpConfig[key] = copy(value);
                  }
                });
                if (hasBody)
                  httpConfig.data = data;
                route.setUrlParams(httpConfig, extend({}, extractParams(data, action.params || {}), params), action.url);
                var promise = $http(httpConfig).then(function(response) {
                  var data = response.data,
                      promise = value.$promise;
                  if (data) {
                    if (angular.isArray(data) !== (!!action.isArray)) {
                      throw $resourceMinErr('badcfg', 'Error in resource configuration for action `{0}`. Expected response to ' + 'contain an {1} but got an {2} (Request: {3} {4})', name, action.isArray ? 'array' : 'object', angular.isArray(data) ? 'array' : 'object', httpConfig.method, httpConfig.url);
                    }
                    if (action.isArray) {
                      value.length = 0;
                      forEach(data, function(item) {
                        if (typeof item === "object") {
                          value.push(new Resource(item));
                        } else {
                          value.push(item);
                        }
                      });
                    } else {
                      shallowClearAndCopy(data, value);
                      value.$promise = promise;
                    }
                  }
                  value.$resolved = true;
                  response.resource = value;
                  return response;
                }, function(response) {
                  value.$resolved = true;
                  (error || noop)(response);
                  return $q.reject(response);
                });
                promise = promise.then(function(response) {
                  var value = responseInterceptor(response);
                  (success || noop)(value, response.headers);
                  return value;
                }, responseErrorInterceptor);
                if (!isInstanceCall) {
                  value.$promise = promise;
                  value.$resolved = false;
                  return value;
                }
                return promise;
              };
              Resource.prototype['$' + name] = function(params, success, error) {
                if (isFunction(params)) {
                  error = success;
                  success = params;
                  params = {};
                }
                var result = Resource[name].call(this, params, this, success, error);
                return result.$promise || result;
              };
            });
            Resource.bind = function(additionalParamDefaults) {
              return resourceFactory(url, extend({}, paramDefaults, additionalParamDefaults), actions);
            };
            return Resource;
          }
          return resourceFactory;
        }];
      });
    })(window, window.angular);
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, false);
});

System.register("webapp/js/states/layout/layout.html!github:systemjs/plugin-text@0.0.2", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-tabs class=\"tabs-positive tabs-icon-only\">\n\n  <ion-tab\n    icon-on=\"ion-ios-people\"\n    icon-off=\"ion-ios-people-outline\">\n\n    <ion-view>\n    <!--<ion-nav-view></ion-nav-view>-->\n      <div ng-include=\"'template:people'\"></div>\n    </ion-view>\n  </ion-tab>\n\n  <ion-tab\n    icon-on=\"ion-ios-world\"\n    icon-off=\"ion-ios-world-outline\">\n\n    <ion-view>\n    <!--<ion-nav-view></ion-nav-view>-->\n      <div ng-include=\"'template:places'\"></div>\n    </ion-view>\n  </ion-tab>\n\n  <!--<ion-tab icon-on=\"ion-ios-gear\" icon-off=\"ion-ios-gear-outline\">\n    <p>set</p>\n  </ion-tab>-->\n\n</ion-tabs>\n";
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.8.20/helpers/class-call-check", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  exports["default"] = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.register("webapp/js/states/auth/auth.html!github:systemjs/plugin-text@0.0.2", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-view ng-controller=\"AuthController as authCtrl\">\n  <ion-content>\n    <button class=\"button button-block button-calm\" ng-click=\"authCtrl.login()\">Login</button>\n    <buttton class=\"button button-block button-calm\" ng-click=\"authCtrl.signup()\">Sign up</buttton>\n  </ion-content>\n</ion-view>\n";
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.18/library/modules/$.fw", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = function($) {
    $.FW = false;
    $.path = $.core;
    return $;
  };
  global.define = __define;
  return module.exports;
});

System.register("webapp/js/states/auth/login/login.html!github:systemjs/plugin-text@0.0.2", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-modal-view ng-controller=\"LoginController as loginCtrl\">\n  <ion-header-bar>\n    <h1 class=\"title\">Login</h1>\n\n    <div class=\"buttons\">\n      <button class=\"button button-clear\" ng-click=\"loginCtrl.close()\">Close</button>\n    </div>\n  </ion-header-bar>\n  <ion-content>\n    <form ng-submit=\"loginCtrl.doLogin()\">\n      <div class=\"list\">\n        <label class=\"item item-input\">\n          <span class=\"input-label\">Username</span>\n          <input type=\"text\" ng-model=\"loginCtrl.model.username\">\n        </label>\n        <label class=\"item item-input\">\n          <span class=\"input-label\">Password</span>\n          <input type=\"password\" ng-model=\"loginCtrl.model.password\">\n        </label>\n        <label class=\"item\">\n          <button class=\"button button-block button-positive\" type=\"submit\">Log in</button>\n        </label>\n      </div>\n    </form>\n  </ion-content>\n</ion-modal-view>\n";
  global.define = __define;
  return module.exports;
});

System.register("webapp/js/states/auth/signup/signup.html!github:systemjs/plugin-text@0.0.2", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-modal-view ng-controller=\"SignupController as signupCtrl\">\n  <ion-header-bar>\n    <h1 class=\"title\">Sign up</h1>\n\n    <div class=\"buttons\">\n      <button class=\"button button-clear\" ng-click=\"signupCtrl.close()\">Close</button>\n    </div>\n  </ion-header-bar>\n  <ion-content>\n    <form ng-submit=\"signupCtrl.doSignup()\">\n      <div class=\"list\">\n        <label class=\"item item-input\">\n          <span class=\"input-label\">Username</span>\n          <input type=\"text\" ng-model=\"signupCtrl.model.username\">\n        </label>\n        <label class=\"item item-input\">\n          <span class=\"input-label\">Password</span>\n          <input type=\"email\" ng-model=\"signupCtrl.model.email\">\n        </label>\n        <label class=\"item item-input\">\n          <span class=\"input-label\">Password</span>\n          <input type=\"password\" ng-model=\"signupCtrl.model.password\">\n        </label>\n        <label class=\"item\">\n          <button class=\"button button-block button-positive\" type=\"submit\">Sign up</button>\n        </label>\n      </div>\n    </form>\n  </ion-content>\n</ion-modal-view>\n";
  global.define = __define;
  return module.exports;
});

System.register("./webapp/app.config.json!github:systemjs/plugin-text@0.0.2", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = "{\"env\":\"development\",\"serviceUrl\":\"http://whoappbackend-jbubsk.rhcloud.com\"}";
  global.define = __define;
  return module.exports;
});

System.register("webapp/js/states/people/people.html!github:systemjs/plugin-text@0.0.2", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-view title=\"People\" ng-controller=\"PeopleController as peopleCtrl\">\n  <ion-content>\n    <div collection-repeat=\"person in peopleCtrl.people\">\n      <a class=\"item item-icon-left\" href=\"#\">\n        <i class=\"icon ion-person\"></i>\n          <span ng-bind=\"person.username\"></span>\n          <span class=\"item-note\">\n            <span ng-bind=\"person.distance\"></span>\n          </span>\n      </a>\n    </div>\n  </ion-content>\n</ion-view>\n";
  global.define = __define;
  return module.exports;
});

System.register("webapp/js/states/places/places.html!github:systemjs/plugin-text@0.0.2", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = "<ion-view title=\"Places\" ng-controller=\"PlacesController as placesCtrl\">\n  <ion-content>\n    <div collection-repeat=\"place in placesCtrl.places\">\n      <a class=\"item item-icon-left\" href=\"#\">\n        <i class=\"icon ion-world\"></i>\n        <span ng-bind=\"place.name\"></span>\n          <span class=\"item-note\">\n            <span ng-bind=\"place.distance\"></span>\n          </span>\n      </a>\n    </div>\n  </ion-content>\n</ion-view>\n";
  global.define = __define;
  return module.exports;
});

System.register("github:angular/bower-angular@1.4.4", ["github:angular/bower-angular@1.4.4/angular"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:angular/bower-angular@1.4.4/angular");
  global.define = __define;
  return module.exports;
});

System.register("github:angular/bower-angular-animate@1.4.4", ["github:angular/bower-angular-animate@1.4.4/angular-animate"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:angular/bower-angular-animate@1.4.4/angular-animate");
  global.define = __define;
  return module.exports;
});

System.register("github:angular/bower-angular-sanitize@1.4.4", ["github:angular/bower-angular-sanitize@1.4.4/angular-sanitize"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:angular/bower-angular-sanitize@1.4.4/angular-sanitize");
  global.define = __define;
  return module.exports;
});

System.register("github:angular-ui/ui-router@0.2.13", ["github:angular-ui/ui-router@0.2.13/angular-ui-router"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:angular-ui/ui-router@0.2.13/angular-ui-router");
  global.define = __define;
  return module.exports;
});

(function() {
function define(){};  define.amd = {};
System.register("github:components/jquery@2.1.4", ["github:components/jquery@2.1.4/jquery"], false, function(__require, __exports, __module) {
  return (function(main) {
    return main;
  }).call(this, __require('github:components/jquery@2.1.4/jquery'));
});
})();
System.register("github:angular/bower-angular-resource@1.4.4/index", ["github:angular/bower-angular-resource@1.4.4/angular-resource"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  require("github:angular/bower-angular-resource@1.4.4/angular-resource");
  module.exports = 'ngResource';
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.18/library/modules/$", ["npm:core-js@0.9.18/library/modules/$.fw"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var global = typeof self != 'undefined' ? self : Function('return this')(),
      core = {},
      defineProperty = Object.defineProperty,
      hasOwnProperty = {}.hasOwnProperty,
      ceil = Math.ceil,
      floor = Math.floor,
      max = Math.max,
      min = Math.min;
  var DESC = !!function() {
    try {
      return defineProperty({}, 'a', {get: function() {
          return 2;
        }}).a == 2;
    } catch (e) {}
  }();
  var hide = createDefiner(1);
  function toInteger(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  }
  function desc(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  }
  function simpleSet(object, key, value) {
    object[key] = value;
    return object;
  }
  function createDefiner(bitmap) {
    return DESC ? function(object, key, value) {
      return $.setDesc(object, key, desc(bitmap, value));
    } : simpleSet;
  }
  function isObject(it) {
    return it !== null && (typeof it == 'object' || typeof it == 'function');
  }
  function isFunction(it) {
    return typeof it == 'function';
  }
  function assertDefined(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  }
  var $ = module.exports = require("npm:core-js@0.9.18/library/modules/$.fw")({
    g: global,
    core: core,
    html: global.document && document.documentElement,
    isObject: isObject,
    isFunction: isFunction,
    that: function() {
      return this;
    },
    toInteger: toInteger,
    toLength: function(it) {
      return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
    },
    toIndex: function(index, length) {
      index = toInteger(index);
      return index < 0 ? max(index + length, 0) : min(index, length);
    },
    has: function(it, key) {
      return hasOwnProperty.call(it, key);
    },
    create: Object.create,
    getProto: Object.getPrototypeOf,
    DESC: DESC,
    desc: desc,
    getDesc: Object.getOwnPropertyDescriptor,
    setDesc: defineProperty,
    setDescs: Object.defineProperties,
    getKeys: Object.keys,
    getNames: Object.getOwnPropertyNames,
    getSymbols: Object.getOwnPropertySymbols,
    assertDefined: assertDefined,
    ES5Object: Object,
    toObject: function(it) {
      return $.ES5Object(assertDefined(it));
    },
    hide: hide,
    def: createDefiner(0),
    set: global.Symbol ? simpleSet : hide,
    each: [].forEach
  });
  if (typeof __e != 'undefined')
    __e = core;
  if (typeof __g != 'undefined')
    __g = global;
  global.define = __define;
  return module.exports;
});

System.register("github:driftyco/ionic-bower@1.1.0/js/ionic-angular", ["github:driftyco/ionic-bower@1.1.0/css/ionic.css!github:systemjs/plugin-css@0.1.14", "github:driftyco/ionic-bower@1.1.0/js/ionic", "github:angular/bower-angular@1.4.4", "github:angular/bower-angular-animate@1.4.4", "github:angular/bower-angular-sanitize@1.4.4", "github:angular-ui/ui-router@0.2.13"], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, ["github:driftyco/ionic-bower@1.1.0/css/ionic.css!github:systemjs/plugin-css@0.1.14", "github:driftyco/ionic-bower@1.1.0/js/ionic", "github:angular/bower-angular@1.4.4", "github:angular/bower-angular-animate@1.4.4", "github:angular/bower-angular-sanitize@1.4.4", "github:angular-ui/ui-router@0.2.13"]);
  (function() {
    "format global";
    "deps ../css/ionic.css!";
    "deps ./ionic";
    "deps angular";
    "deps angular-animate";
    "deps angular-sanitize";
    "deps angular-ui-router";
    (function() {
      var IonicModule = angular.module('ionic', ['ngAnimate', 'ngSanitize', 'ui.router']),
          extend = angular.extend,
          forEach = angular.forEach,
          isDefined = angular.isDefined,
          isNumber = angular.isNumber,
          isString = angular.isString,
          jqLite = angular.element,
          noop = angular.noop;
      IonicModule.factory('$ionicActionSheet', ['$rootScope', '$compile', '$animate', '$timeout', '$ionicTemplateLoader', '$ionicPlatform', '$ionicBody', 'IONIC_BACK_PRIORITY', function($rootScope, $compile, $animate, $timeout, $ionicTemplateLoader, $ionicPlatform, $ionicBody, IONIC_BACK_PRIORITY) {
        return {show: actionSheet};
        function actionSheet(opts) {
          var scope = $rootScope.$new(true);
          extend(scope, {
            cancel: noop,
            destructiveButtonClicked: noop,
            buttonClicked: noop,
            $deregisterBackButton: noop,
            buttons: [],
            cancelOnStateChange: true
          }, opts || {});
          function textForIcon(text) {
            if (text && /icon/.test(text)) {
              scope.$actionSheetHasIcon = true;
            }
          }
          for (var x = 0; x < scope.buttons.length; x++) {
            textForIcon(scope.buttons[x].text);
          }
          textForIcon(scope.cancelText);
          textForIcon(scope.destructiveText);
          var element = scope.element = $compile('<ion-action-sheet ng-class="cssClass" buttons="buttons"></ion-action-sheet>')(scope);
          var sheetEl = jqLite(element[0].querySelector('.action-sheet-wrapper'));
          var stateChangeListenDone = scope.cancelOnStateChange ? $rootScope.$on('$stateChangeSuccess', function() {
            scope.cancel();
          }) : noop;
          scope.removeSheet = function(done) {
            if (scope.removed)
              return ;
            scope.removed = true;
            sheetEl.removeClass('action-sheet-up');
            $timeout(function() {
              $ionicBody.removeClass('action-sheet-open');
            }, 400);
            scope.$deregisterBackButton();
            stateChangeListenDone();
            $animate.removeClass(element, 'active').then(function() {
              scope.$destroy();
              element.remove();
              scope.cancel.$scope = sheetEl = null;
              (done || noop)();
            });
          };
          scope.showSheet = function(done) {
            if (scope.removed)
              return ;
            $ionicBody.append(element).addClass('action-sheet-open');
            $animate.addClass(element, 'active').then(function() {
              if (scope.removed)
                return ;
              (done || noop)();
            });
            $timeout(function() {
              if (scope.removed)
                return ;
              sheetEl.addClass('action-sheet-up');
            }, 20, false);
          };
          scope.$deregisterBackButton = $ionicPlatform.registerBackButtonAction(function() {
            $timeout(scope.cancel);
          }, IONIC_BACK_PRIORITY.actionSheet);
          scope.cancel = function() {
            scope.removeSheet(opts.cancel);
          };
          scope.buttonClicked = function(index) {
            if (opts.buttonClicked(index, opts.buttons[index]) === true) {
              scope.removeSheet();
            }
          };
          scope.destructiveButtonClicked = function() {
            if (opts.destructiveButtonClicked() === true) {
              scope.removeSheet();
            }
          };
          scope.showSheet();
          scope.cancel.$scope = scope;
          return scope.cancel;
        }
      }]);
      jqLite.prototype.addClass = function(cssClasses) {
        var x,
            y,
            cssClass,
            el,
            splitClasses,
            existingClasses;
        if (cssClasses && cssClasses != 'ng-scope' && cssClasses != 'ng-isolate-scope') {
          for (x = 0; x < this.length; x++) {
            el = this[x];
            if (el.setAttribute) {
              if (cssClasses.indexOf(' ') < 0 && el.classList.add) {
                el.classList.add(cssClasses);
              } else {
                existingClasses = (' ' + (el.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
                splitClasses = cssClasses.split(' ');
                for (y = 0; y < splitClasses.length; y++) {
                  cssClass = splitClasses[y].trim();
                  if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
                    existingClasses += cssClass + ' ';
                  }
                }
                el.setAttribute('class', existingClasses.trim());
              }
            }
          }
        }
        return this;
      };
      jqLite.prototype.removeClass = function(cssClasses) {
        var x,
            y,
            splitClasses,
            cssClass,
            el;
        if (cssClasses) {
          for (x = 0; x < this.length; x++) {
            el = this[x];
            if (el.getAttribute) {
              if (cssClasses.indexOf(' ') < 0 && el.classList.remove) {
                el.classList.remove(cssClasses);
              } else {
                splitClasses = cssClasses.split(' ');
                for (y = 0; y < splitClasses.length; y++) {
                  cssClass = splitClasses[y];
                  el.setAttribute('class', ((" " + (el.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + cssClass.trim() + " ", " ")).trim());
                }
              }
            }
          }
        }
        return this;
      };
      IonicModule.factory('$ionicBackdrop', ['$document', '$timeout', '$$rAF', function($document, $timeout, $$rAF) {
        var el = jqLite('<div class="backdrop">');
        var backdropHolds = 0;
        $document[0].body.appendChild(el[0]);
        return {
          retain: retain,
          release: release,
          getElement: getElement,
          _element: el
        };
        function retain() {
          backdropHolds++;
          if (backdropHolds === 1) {
            el.addClass('visible');
            $$rAF(function() {
              if (backdropHolds >= 1)
                el.addClass('active');
            });
          }
        }
        function release() {
          if (backdropHolds === 1) {
            el.removeClass('active');
            $timeout(function() {
              if (backdropHolds === 0)
                el.removeClass('visible');
            }, 400, false);
          }
          backdropHolds = Math.max(0, backdropHolds - 1);
        }
        function getElement() {
          return el;
        }
      }]);
      IonicModule.factory('$ionicBind', ['$parse', '$interpolate', function($parse, $interpolate) {
        var LOCAL_REGEXP = /^\s*([@=&])(\??)\s*(\w*)\s*$/;
        return function(scope, attrs, bindDefinition) {
          forEach(bindDefinition || {}, function(definition, scopeName) {
            var match = definition.match(LOCAL_REGEXP) || [],
                attrName = match[3] || scopeName,
                mode = match[1],
                parentGet,
                unwatch;
            switch (mode) {
              case '@':
                if (!attrs[attrName]) {
                  return ;
                }
                attrs.$observe(attrName, function(value) {
                  scope[scopeName] = value;
                });
                if (attrs[attrName]) {
                  scope[scopeName] = $interpolate(attrs[attrName])(scope);
                }
                break;
              case '=':
                if (!attrs[attrName]) {
                  return ;
                }
                unwatch = scope.$watch(attrs[attrName], function(value) {
                  scope[scopeName] = value;
                });
                scope.$on('$destroy', unwatch);
                break;
              case '&':
                if (attrs[attrName] && attrs[attrName].match(RegExp(scopeName + '\(.*?\)'))) {
                  throw new Error('& expression binding "' + scopeName + '" looks like it will recursively call "' + attrs[attrName] + '" and cause a stack overflow! Please choose a different scopeName.');
                }
                parentGet = $parse(attrs[attrName]);
                scope[scopeName] = function(locals) {
                  return parentGet(scope, locals);
                };
                break;
            }
          });
        };
      }]);
      IonicModule.factory('$ionicBody', ['$document', function($document) {
        return {
          addClass: function() {
            for (var x = 0; x < arguments.length; x++) {
              $document[0].body.classList.add(arguments[x]);
            }
            return this;
          },
          removeClass: function() {
            for (var x = 0; x < arguments.length; x++) {
              $document[0].body.classList.remove(arguments[x]);
            }
            return this;
          },
          enableClass: function(shouldEnableClass) {
            var args = Array.prototype.slice.call(arguments).slice(1);
            if (shouldEnableClass) {
              this.addClass.apply(this, args);
            } else {
              this.removeClass.apply(this, args);
            }
            return this;
          },
          append: function(ele) {
            $document[0].body.appendChild(ele.length ? ele[0] : ele);
            return this;
          },
          get: function() {
            return $document[0].body;
          }
        };
      }]);
      IonicModule.factory('$ionicClickBlock', ['$document', '$ionicBody', '$timeout', function($document, $ionicBody, $timeout) {
        var CSS_HIDE = 'click-block-hide';
        var cbEle,
            fallbackTimer,
            pendingShow;
        function preventClick(ev) {
          ev.preventDefault();
          ev.stopPropagation();
        }
        function addClickBlock() {
          if (pendingShow) {
            if (cbEle) {
              cbEle.classList.remove(CSS_HIDE);
            } else {
              cbEle = $document[0].createElement('div');
              cbEle.className = 'click-block';
              $ionicBody.append(cbEle);
              cbEle.addEventListener('touchstart', preventClick);
              cbEle.addEventListener('mousedown', preventClick);
            }
            pendingShow = false;
          }
        }
        function removeClickBlock() {
          cbEle && cbEle.classList.add(CSS_HIDE);
        }
        return {
          show: function(autoExpire) {
            pendingShow = true;
            $timeout.cancel(fallbackTimer);
            fallbackTimer = $timeout(this.hide, autoExpire || 310, false);
            addClickBlock();
          },
          hide: function() {
            pendingShow = false;
            $timeout.cancel(fallbackTimer);
            removeClickBlock();
          }
        };
      }]);
      IonicModule.factory('$ionicGesture', [function() {
        return {
          on: function(eventType, cb, $element, options) {
            return window.ionic.onGesture(eventType, cb, $element[0], options);
          },
          off: function(gesture, eventType, cb) {
            return window.ionic.offGesture(gesture, eventType, cb);
          }
        };
      }]);
      IonicModule.factory('$ionicHistory', ['$rootScope', '$state', '$location', '$window', '$timeout', '$ionicViewSwitcher', '$ionicNavViewDelegate', function($rootScope, $state, $location, $window, $timeout, $ionicViewSwitcher, $ionicNavViewDelegate) {
        var ACTION_INITIAL_VIEW = 'initialView';
        var ACTION_NEW_VIEW = 'newView';
        var ACTION_MOVE_BACK = 'moveBack';
        var ACTION_MOVE_FORWARD = 'moveForward';
        var DIRECTION_BACK = 'back';
        var DIRECTION_FORWARD = 'forward';
        var DIRECTION_ENTER = 'enter';
        var DIRECTION_EXIT = 'exit';
        var DIRECTION_SWAP = 'swap';
        var DIRECTION_NONE = 'none';
        var stateChangeCounter = 0;
        var lastStateId,
            nextViewOptions,
            deregisterStateChangeListener,
            nextViewExpireTimer,
            forcedNav;
        var viewHistory = {
          histories: {root: {
              historyId: 'root',
              parentHistoryId: null,
              stack: [],
              cursor: -1
            }},
          views: {},
          backView: null,
          forwardView: null,
          currentView: null
        };
        var View = function() {};
        View.prototype.initialize = function(data) {
          if (data) {
            for (var name in data)
              this[name] = data[name];
            return this;
          }
          return null;
        };
        View.prototype.go = function() {
          if (this.stateName) {
            return $state.go(this.stateName, this.stateParams);
          }
          if (this.url && this.url !== $location.url()) {
            if (viewHistory.backView === this) {
              return $window.history.go(-1);
            } else if (viewHistory.forwardView === this) {
              return $window.history.go(1);
            }
            $location.url(this.url);
          }
          return null;
        };
        View.prototype.destroy = function() {
          if (this.scope) {
            this.scope.$destroy && this.scope.$destroy();
            this.scope = null;
          }
        };
        function getViewById(viewId) {
          return (viewId ? viewHistory.views[viewId] : null);
        }
        function getBackView(view) {
          return (view ? getViewById(view.backViewId) : null);
        }
        function getForwardView(view) {
          return (view ? getViewById(view.forwardViewId) : null);
        }
        function getHistoryById(historyId) {
          return (historyId ? viewHistory.histories[historyId] : null);
        }
        function getHistory(scope) {
          var histObj = getParentHistoryObj(scope);
          if (!viewHistory.histories[histObj.historyId]) {
            viewHistory.histories[histObj.historyId] = {
              historyId: histObj.historyId,
              parentHistoryId: getParentHistoryObj(histObj.scope.$parent).historyId,
              stack: [],
              cursor: -1
            };
          }
          return getHistoryById(histObj.historyId);
        }
        function getParentHistoryObj(scope) {
          var parentScope = scope;
          while (parentScope) {
            if (parentScope.hasOwnProperty('$historyId')) {
              return {
                historyId: parentScope.$historyId,
                scope: parentScope
              };
            }
            parentScope = parentScope.$parent;
          }
          return {
            historyId: 'root',
            scope: $rootScope
          };
        }
        function setNavViews(viewId) {
          viewHistory.currentView = getViewById(viewId);
          viewHistory.backView = getBackView(viewHistory.currentView);
          viewHistory.forwardView = getForwardView(viewHistory.currentView);
        }
        function getCurrentStateId() {
          var id;
          if ($state && $state.current && $state.current.name) {
            id = $state.current.name;
            if ($state.params) {
              for (var key in $state.params) {
                if ($state.params.hasOwnProperty(key) && $state.params[key]) {
                  id += "_" + key + "=" + $state.params[key];
                }
              }
            }
            return id;
          }
          return ionic.Utils.nextUid();
        }
        function getCurrentStateParams() {
          var rtn;
          if ($state && $state.params) {
            for (var key in $state.params) {
              if ($state.params.hasOwnProperty(key)) {
                rtn = rtn || {};
                rtn[key] = $state.params[key];
              }
            }
          }
          return rtn;
        }
        return {
          register: function(parentScope, viewLocals) {
            var currentStateId = getCurrentStateId(),
                hist = getHistory(parentScope),
                currentView = viewHistory.currentView,
                backView = viewHistory.backView,
                forwardView = viewHistory.forwardView,
                viewId = null,
                action = null,
                direction = DIRECTION_NONE,
                historyId = hist.historyId,
                url = $location.url(),
                tmp,
                x,
                ele;
            if (lastStateId !== currentStateId) {
              lastStateId = currentStateId;
              stateChangeCounter++;
            }
            if (forcedNav) {
              viewId = forcedNav.viewId;
              action = forcedNav.action;
              direction = forcedNav.direction;
              forcedNav = null;
            } else if (backView && backView.stateId === currentStateId) {
              viewId = backView.viewId;
              historyId = backView.historyId;
              action = ACTION_MOVE_BACK;
              if (backView.historyId === currentView.historyId) {
                direction = DIRECTION_BACK;
              } else if (currentView) {
                direction = DIRECTION_EXIT;
                tmp = getHistoryById(backView.historyId);
                if (tmp && tmp.parentHistoryId === currentView.historyId) {
                  direction = DIRECTION_ENTER;
                } else {
                  tmp = getHistoryById(currentView.historyId);
                  if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {
                    direction = DIRECTION_SWAP;
                  }
                }
              }
            } else if (forwardView && forwardView.stateId === currentStateId) {
              viewId = forwardView.viewId;
              historyId = forwardView.historyId;
              action = ACTION_MOVE_FORWARD;
              if (forwardView.historyId === currentView.historyId) {
                direction = DIRECTION_FORWARD;
              } else if (currentView) {
                direction = DIRECTION_EXIT;
                if (currentView.historyId === hist.parentHistoryId) {
                  direction = DIRECTION_ENTER;
                } else {
                  tmp = getHistoryById(currentView.historyId);
                  if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {
                    direction = DIRECTION_SWAP;
                  }
                }
              }
              tmp = getParentHistoryObj(parentScope);
              if (forwardView.historyId && tmp.scope) {
                tmp.scope.$historyId = forwardView.historyId;
                historyId = forwardView.historyId;
              }
            } else if (currentView && currentView.historyId !== historyId && hist.cursor > -1 && hist.stack.length > 0 && hist.cursor < hist.stack.length && hist.stack[hist.cursor].stateId === currentStateId) {
              var switchToView = hist.stack[hist.cursor];
              viewId = switchToView.viewId;
              historyId = switchToView.historyId;
              action = ACTION_MOVE_BACK;
              direction = DIRECTION_SWAP;
              tmp = getHistoryById(currentView.historyId);
              if (tmp && tmp.parentHistoryId === historyId) {
                direction = DIRECTION_EXIT;
              } else {
                tmp = getHistoryById(historyId);
                if (tmp && tmp.parentHistoryId === currentView.historyId) {
                  direction = DIRECTION_ENTER;
                }
              }
              tmp = getViewById(switchToView.backViewId);
              if (tmp && switchToView.historyId !== tmp.historyId) {
                hist.stack[hist.cursor].backViewId = currentView.viewId;
              }
            } else {
              ele = $ionicViewSwitcher.createViewEle(viewLocals);
              if (this.isAbstractEle(ele, viewLocals)) {
                void 0;
                return {
                  action: 'abstractView',
                  direction: DIRECTION_NONE,
                  ele: ele
                };
              }
              viewId = ionic.Utils.nextUid();
              if (currentView) {
                currentView.forwardViewId = viewId;
                action = ACTION_NEW_VIEW;
                if (forwardView && currentView.stateId !== forwardView.stateId && currentView.historyId === forwardView.historyId) {
                  tmp = getHistoryById(forwardView.historyId);
                  if (tmp) {
                    for (x = tmp.stack.length - 1; x >= forwardView.index; x--) {
                      var stackItem = tmp.stack[x];
                      stackItem && stackItem.destroy && stackItem.destroy();
                      tmp.stack.splice(x);
                    }
                    historyId = forwardView.historyId;
                  }
                }
                if (hist.historyId === currentView.historyId) {
                  direction = DIRECTION_FORWARD;
                } else if (currentView.historyId !== hist.historyId) {
                  direction = DIRECTION_ENTER;
                  tmp = getHistoryById(currentView.historyId);
                  if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {
                    direction = DIRECTION_SWAP;
                  } else {
                    tmp = getHistoryById(tmp.parentHistoryId);
                    if (tmp && tmp.historyId === hist.historyId) {
                      direction = DIRECTION_EXIT;
                    }
                  }
                }
              } else {
                action = ACTION_INITIAL_VIEW;
              }
              if (stateChangeCounter < 2) {
                direction = DIRECTION_NONE;
              }
              viewHistory.views[viewId] = this.createView({
                viewId: viewId,
                index: hist.stack.length,
                historyId: hist.historyId,
                backViewId: (currentView && currentView.viewId ? currentView.viewId : null),
                forwardViewId: null,
                stateId: currentStateId,
                stateName: this.currentStateName(),
                stateParams: getCurrentStateParams(),
                url: url,
                canSwipeBack: canSwipeBack(ele, viewLocals)
              });
              hist.stack.push(viewHistory.views[viewId]);
            }
            deregisterStateChangeListener && deregisterStateChangeListener();
            $timeout.cancel(nextViewExpireTimer);
            if (nextViewOptions) {
              if (nextViewOptions.disableAnimate)
                direction = DIRECTION_NONE;
              if (nextViewOptions.disableBack)
                viewHistory.views[viewId].backViewId = null;
              if (nextViewOptions.historyRoot) {
                for (x = 0; x < hist.stack.length; x++) {
                  if (hist.stack[x].viewId === viewId) {
                    hist.stack[x].index = 0;
                    hist.stack[x].backViewId = hist.stack[x].forwardViewId = null;
                  } else {
                    delete viewHistory.views[hist.stack[x].viewId];
                  }
                }
                hist.stack = [viewHistory.views[viewId]];
              }
              nextViewOptions = null;
            }
            setNavViews(viewId);
            if (viewHistory.backView && historyId == viewHistory.backView.historyId && currentStateId == viewHistory.backView.stateId && url == viewHistory.backView.url) {
              for (x = 0; x < hist.stack.length; x++) {
                if (hist.stack[x].viewId == viewId) {
                  action = 'dupNav';
                  direction = DIRECTION_NONE;
                  if (x > 0) {
                    hist.stack[x - 1].forwardViewId = null;
                  }
                  viewHistory.forwardView = null;
                  viewHistory.currentView.index = viewHistory.backView.index;
                  viewHistory.currentView.backViewId = viewHistory.backView.backViewId;
                  viewHistory.backView = getBackView(viewHistory.backView);
                  hist.stack.splice(x, 1);
                  break;
                }
              }
            }
            void 0;
            hist.cursor = viewHistory.currentView.index;
            return {
              viewId: viewId,
              action: action,
              direction: direction,
              historyId: historyId,
              enableBack: this.enabledBack(viewHistory.currentView),
              isHistoryRoot: (viewHistory.currentView.index === 0),
              ele: ele
            };
          },
          registerHistory: function(scope) {
            scope.$historyId = ionic.Utils.nextUid();
          },
          createView: function(data) {
            var newView = new View();
            return newView.initialize(data);
          },
          getViewById: getViewById,
          viewHistory: function() {
            return viewHistory;
          },
          currentView: function(view) {
            if (arguments.length) {
              viewHistory.currentView = view;
            }
            return viewHistory.currentView;
          },
          currentHistoryId: function() {
            return viewHistory.currentView ? viewHistory.currentView.historyId : null;
          },
          currentTitle: function(val) {
            if (viewHistory.currentView) {
              if (arguments.length) {
                viewHistory.currentView.title = val;
              }
              return viewHistory.currentView.title;
            }
          },
          backView: function(view) {
            if (arguments.length) {
              viewHistory.backView = view;
            }
            return viewHistory.backView;
          },
          backTitle: function(view) {
            var backView = (view && getViewById(view.backViewId)) || viewHistory.backView;
            return backView && backView.title;
          },
          forwardView: function(view) {
            if (arguments.length) {
              viewHistory.forwardView = view;
            }
            return viewHistory.forwardView;
          },
          currentStateName: function() {
            return ($state && $state.current ? $state.current.name : null);
          },
          isCurrentStateNavView: function(navView) {
            return !!($state && $state.current && $state.current.views && $state.current.views[navView]);
          },
          goToHistoryRoot: function(historyId) {
            if (historyId) {
              var hist = getHistoryById(historyId);
              if (hist && hist.stack.length) {
                if (viewHistory.currentView && viewHistory.currentView.viewId === hist.stack[0].viewId) {
                  return ;
                }
                forcedNav = {
                  viewId: hist.stack[0].viewId,
                  action: ACTION_MOVE_BACK,
                  direction: DIRECTION_BACK
                };
                hist.stack[0].go();
              }
            }
          },
          goBack: function(backCount) {
            if (isDefined(backCount) && backCount !== -1) {
              if (backCount > -1)
                return ;
              var currentHistory = viewHistory.histories[this.currentHistoryId()];
              var newCursor = currentHistory.cursor + backCount + 1;
              if (newCursor < 1) {
                newCursor = 1;
              }
              currentHistory.cursor = newCursor;
              setNavViews(currentHistory.stack[newCursor].viewId);
              var cursor = newCursor - 1;
              var clearStateIds = [];
              var fwdView = getViewById(currentHistory.stack[cursor].forwardViewId);
              while (fwdView) {
                clearStateIds.push(fwdView.stateId || fwdView.viewId);
                cursor++;
                if (cursor >= currentHistory.stack.length)
                  break;
                fwdView = getViewById(currentHistory.stack[cursor].forwardViewId);
              }
              var self = this;
              if (clearStateIds.length) {
                $timeout(function() {
                  self.clearCache(clearStateIds);
                }, 600);
              }
            }
            viewHistory.backView && viewHistory.backView.go();
          },
          enabledBack: function(view) {
            var backView = getBackView(view);
            return !!(backView && backView.historyId === view.historyId);
          },
          clearHistory: function() {
            var histories = viewHistory.histories,
                currentView = viewHistory.currentView;
            if (histories) {
              for (var historyId in histories) {
                if (histories[historyId].stack) {
                  histories[historyId].stack = [];
                  histories[historyId].cursor = -1;
                }
                if (currentView && currentView.historyId === historyId) {
                  currentView.backViewId = currentView.forwardViewId = null;
                  histories[historyId].stack.push(currentView);
                } else if (histories[historyId].destroy) {
                  histories[historyId].destroy();
                }
              }
            }
            for (var viewId in viewHistory.views) {
              if (viewId !== currentView.viewId) {
                delete viewHistory.views[viewId];
              }
            }
            if (currentView) {
              setNavViews(currentView.viewId);
            }
          },
          clearCache: function(stateIds) {
            return $timeout(function() {
              $ionicNavViewDelegate._instances.forEach(function(instance) {
                instance.clearCache(stateIds);
              });
            });
          },
          nextViewOptions: function(opts) {
            deregisterStateChangeListener && deregisterStateChangeListener();
            if (arguments.length) {
              $timeout.cancel(nextViewExpireTimer);
              if (opts === null) {
                nextViewOptions = opts;
              } else {
                nextViewOptions = nextViewOptions || {};
                extend(nextViewOptions, opts);
                if (nextViewOptions.expire) {
                  deregisterStateChangeListener = $rootScope.$on('$stateChangeSuccess', function() {
                    nextViewExpireTimer = $timeout(function() {
                      nextViewOptions = null;
                    }, nextViewOptions.expire);
                  });
                }
              }
            }
            return nextViewOptions;
          },
          isAbstractEle: function(ele, viewLocals) {
            if (viewLocals && viewLocals.$$state && viewLocals.$$state.self['abstract']) {
              return true;
            }
            return !!(ele && (isAbstractTag(ele) || isAbstractTag(ele.children())));
          },
          isActiveScope: function(scope) {
            if (!scope)
              return false;
            var climbScope = scope;
            var currentHistoryId = this.currentHistoryId();
            var foundHistoryId;
            while (climbScope) {
              if (climbScope.$$disconnected) {
                return false;
              }
              if (!foundHistoryId && climbScope.hasOwnProperty('$historyId')) {
                foundHistoryId = true;
              }
              if (currentHistoryId) {
                if (climbScope.hasOwnProperty('$historyId') && currentHistoryId == climbScope.$historyId) {
                  return true;
                }
                if (climbScope.hasOwnProperty('$activeHistoryId')) {
                  if (currentHistoryId == climbScope.$activeHistoryId) {
                    if (climbScope.hasOwnProperty('$historyId')) {
                      return true;
                    }
                    if (!foundHistoryId) {
                      return true;
                    }
                  }
                }
              }
              if (foundHistoryId && climbScope.hasOwnProperty('$activeHistoryId')) {
                foundHistoryId = false;
              }
              climbScope = climbScope.$parent;
            }
            return currentHistoryId ? currentHistoryId == 'root' : true;
          }
        };
        function isAbstractTag(ele) {
          return ele && ele.length && /ion-side-menus|ion-tabs/i.test(ele[0].tagName);
        }
        function canSwipeBack(ele, viewLocals) {
          if (viewLocals && viewLocals.$$state && viewLocals.$$state.self.canSwipeBack === false) {
            return false;
          }
          if (ele && ele.attr('can-swipe-back') === 'false') {
            return false;
          }
          return true;
        }
      }]).run(['$rootScope', '$state', '$location', '$document', '$ionicPlatform', '$ionicHistory', 'IONIC_BACK_PRIORITY', function($rootScope, $state, $location, $document, $ionicPlatform, $ionicHistory, IONIC_BACK_PRIORITY) {
        $rootScope.$on('$ionicView.beforeEnter', function() {
          ionic.keyboard && ionic.keyboard.hide && ionic.keyboard.hide();
        });
        $rootScope.$on('$ionicHistory.change', function(e, data) {
          if (!data)
            return null;
          var viewHistory = $ionicHistory.viewHistory();
          var hist = (data.historyId ? viewHistory.histories[data.historyId] : null);
          if (hist && hist.cursor > -1 && hist.cursor < hist.stack.length) {
            var view = hist.stack[hist.cursor];
            return view.go(data);
          }
          if (!data.url && data.uiSref) {
            data.url = $state.href(data.uiSref);
          }
          if (data.url) {
            if (data.url.indexOf('#') === 0) {
              data.url = data.url.replace('#', '');
            }
            if (data.url !== $location.url()) {
              $location.url(data.url);
            }
          }
        });
        $rootScope.$ionicGoBack = function(backCount) {
          $ionicHistory.goBack(backCount);
        };
        $rootScope.$on('$ionicView.afterEnter', function(ev, data) {
          if (data && data.title) {
            $document[0].title = data.title;
          }
        });
        function onHardwareBackButton(e) {
          var backView = $ionicHistory.backView();
          if (backView) {
            backView.go();
          } else {
            ionic.Platform.exitApp();
          }
          e.preventDefault();
          return false;
        }
        $ionicPlatform.registerBackButtonAction(onHardwareBackButton, IONIC_BACK_PRIORITY.view);
      }]);
      IonicModule.provider('$ionicConfig', function() {
        var provider = this;
        provider.platform = {};
        var PLATFORM = 'platform';
        var configProperties = {
          views: {
            maxCache: PLATFORM,
            forwardCache: PLATFORM,
            transition: PLATFORM,
            swipeBackEnabled: PLATFORM,
            swipeBackHitWidth: PLATFORM
          },
          navBar: {
            alignTitle: PLATFORM,
            positionPrimaryButtons: PLATFORM,
            positionSecondaryButtons: PLATFORM,
            transition: PLATFORM
          },
          backButton: {
            icon: PLATFORM,
            text: PLATFORM,
            previousTitleText: PLATFORM
          },
          form: {
            checkbox: PLATFORM,
            toggle: PLATFORM
          },
          scrolling: {jsScrolling: PLATFORM},
          spinner: {icon: PLATFORM},
          tabs: {
            style: PLATFORM,
            position: PLATFORM
          },
          templates: {maxPrefetch: PLATFORM},
          platform: {}
        };
        createConfig(configProperties, provider, '');
        setPlatformConfig('default', {
          views: {
            maxCache: 10,
            forwardCache: false,
            transition: 'ios',
            swipeBackEnabled: true,
            swipeBackHitWidth: 45
          },
          navBar: {
            alignTitle: 'center',
            positionPrimaryButtons: 'left',
            positionSecondaryButtons: 'right',
            transition: 'view'
          },
          backButton: {
            icon: 'ion-ios-arrow-back',
            text: 'Back',
            previousTitleText: true
          },
          form: {
            checkbox: 'circle',
            toggle: 'large'
          },
          scrolling: {jsScrolling: true},
          spinner: {icon: 'ios'},
          tabs: {
            style: 'standard',
            position: 'bottom'
          },
          templates: {maxPrefetch: 30}
        });
        setPlatformConfig('ios', {});
        setPlatformConfig('android', {
          views: {
            transition: 'android',
            swipeBackEnabled: false
          },
          navBar: {
            alignTitle: 'left',
            positionPrimaryButtons: 'right',
            positionSecondaryButtons: 'right'
          },
          backButton: {
            icon: 'ion-android-arrow-back',
            text: false,
            previousTitleText: false
          },
          form: {
            checkbox: 'square',
            toggle: 'small'
          },
          spinner: {icon: 'android'},
          tabs: {
            style: 'striped',
            position: 'top'
          }
        });
        setPlatformConfig('windowsphone', {spinner: {icon: 'android'}});
        provider.transitions = {
          views: {},
          navBar: {}
        };
        provider.transitions.views.ios = function(enteringEle, leavingEle, direction, shouldAnimate) {
          function setStyles(ele, opacity, x, boxShadowOpacity) {
            var css = {};
            css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : 0;
            css.opacity = opacity;
            if (boxShadowOpacity > -1) {
              css.boxShadow = '0 0 10px rgba(0,0,0,' + (d.shouldAnimate ? boxShadowOpacity * 0.45 : 0.3) + ')';
            }
            css[ionic.CSS.TRANSFORM] = 'translate3d(' + x + '%,0,0)';
            ionic.DomUtil.cachedStyles(ele, css);
          }
          var d = {
            run: function(step) {
              if (direction == 'forward') {
                setStyles(enteringEle, 1, (1 - step) * 99, 1 - step);
                setStyles(leavingEle, (1 - 0.1 * step), step * -33, -1);
              } else if (direction == 'back') {
                setStyles(enteringEle, (1 - 0.1 * (1 - step)), (1 - step) * -33, -1);
                setStyles(leavingEle, 1, step * 100, 1 - step);
              } else {
                setStyles(enteringEle, 1, 0, -1);
                setStyles(leavingEle, 0, 0, -1);
              }
            },
            shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')
          };
          return d;
        };
        provider.transitions.navBar.ios = function(enteringHeaderBar, leavingHeaderBar, direction, shouldAnimate) {
          function setStyles(ctrl, opacity, titleX, backTextX) {
            var css = {};
            css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : '0ms';
            css.opacity = opacity === 1 ? '' : opacity;
            ctrl.setCss('buttons-left', css);
            ctrl.setCss('buttons-right', css);
            ctrl.setCss('back-button', css);
            css[ionic.CSS.TRANSFORM] = 'translate3d(' + backTextX + 'px,0,0)';
            ctrl.setCss('back-text', css);
            css[ionic.CSS.TRANSFORM] = 'translate3d(' + titleX + 'px,0,0)';
            ctrl.setCss('title', css);
          }
          function enter(ctrlA, ctrlB, step) {
            if (!ctrlA || !ctrlB)
              return ;
            var titleX = (ctrlA.titleTextX() + ctrlA.titleWidth()) * (1 - step);
            var backTextX = (ctrlB && (ctrlB.titleTextX() - ctrlA.backButtonTextLeft()) * (1 - step)) || 0;
            setStyles(ctrlA, step, titleX, backTextX);
          }
          function leave(ctrlA, ctrlB, step) {
            if (!ctrlA || !ctrlB)
              return ;
            var titleX = (-(ctrlA.titleTextX() - ctrlB.backButtonTextLeft()) - (ctrlA.titleLeftRight())) * step;
            setStyles(ctrlA, 1 - step, titleX, 0);
          }
          var d = {
            run: function(step) {
              var enteringHeaderCtrl = enteringHeaderBar.controller();
              var leavingHeaderCtrl = leavingHeaderBar && leavingHeaderBar.controller();
              if (d.direction == 'back') {
                leave(enteringHeaderCtrl, leavingHeaderCtrl, 1 - step);
                enter(leavingHeaderCtrl, enteringHeaderCtrl, 1 - step);
              } else {
                enter(enteringHeaderCtrl, leavingHeaderCtrl, step);
                leave(leavingHeaderCtrl, enteringHeaderCtrl, step);
              }
            },
            direction: direction,
            shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')
          };
          return d;
        };
        provider.transitions.views.android = function(enteringEle, leavingEle, direction, shouldAnimate) {
          shouldAnimate = shouldAnimate && (direction == 'forward' || direction == 'back');
          function setStyles(ele, x) {
            var css = {};
            css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : 0;
            css[ionic.CSS.TRANSFORM] = 'translate3d(' + x + '%,0,0)';
            ionic.DomUtil.cachedStyles(ele, css);
          }
          var d = {
            run: function(step) {
              if (direction == 'forward') {
                setStyles(enteringEle, (1 - step) * 99);
                setStyles(leavingEle, step * -100);
              } else if (direction == 'back') {
                setStyles(enteringEle, (1 - step) * -100);
                setStyles(leavingEle, step * 100);
              } else {
                setStyles(enteringEle, 0);
                setStyles(leavingEle, 0);
              }
            },
            shouldAnimate: shouldAnimate
          };
          return d;
        };
        provider.transitions.navBar.android = function(enteringHeaderBar, leavingHeaderBar, direction, shouldAnimate) {
          function setStyles(ctrl, opacity) {
            if (!ctrl)
              return ;
            var css = {};
            css.opacity = opacity === 1 ? '' : opacity;
            ctrl.setCss('buttons-left', css);
            ctrl.setCss('buttons-right', css);
            ctrl.setCss('back-button', css);
            ctrl.setCss('back-text', css);
            ctrl.setCss('title', css);
          }
          return {
            run: function(step) {
              setStyles(enteringHeaderBar.controller(), step);
              setStyles(leavingHeaderBar && leavingHeaderBar.controller(), 1 - step);
            },
            shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')
          };
        };
        provider.transitions.views.none = function(enteringEle, leavingEle) {
          return {
            run: function(step) {
              provider.transitions.views.android(enteringEle, leavingEle, false, false).run(step);
            },
            shouldAnimate: false
          };
        };
        provider.transitions.navBar.none = function(enteringHeaderBar, leavingHeaderBar) {
          return {
            run: function(step) {
              provider.transitions.navBar.ios(enteringHeaderBar, leavingHeaderBar, false, false).run(step);
              provider.transitions.navBar.android(enteringHeaderBar, leavingHeaderBar, false, false).run(step);
            },
            shouldAnimate: false
          };
        };
        function setPlatformConfig(platformName, platformConfigs) {
          configProperties.platform[platformName] = platformConfigs;
          provider.platform[platformName] = {};
          addConfig(configProperties, configProperties.platform[platformName]);
          createConfig(configProperties.platform[platformName], provider.platform[platformName], '');
        }
        function addConfig(configObj, platformObj) {
          for (var n in configObj) {
            if (n != PLATFORM && configObj.hasOwnProperty(n)) {
              if (angular.isObject(configObj[n])) {
                if (!isDefined(platformObj[n])) {
                  platformObj[n] = {};
                }
                addConfig(configObj[n], platformObj[n]);
              } else if (!isDefined(platformObj[n])) {
                platformObj[n] = null;
              }
            }
          }
        }
        function createConfig(configObj, providerObj, platformPath) {
          forEach(configObj, function(value, namespace) {
            if (angular.isObject(configObj[namespace])) {
              providerObj[namespace] = {};
              createConfig(configObj[namespace], providerObj[namespace], platformPath + '.' + namespace);
            } else {
              providerObj[namespace] = function(newValue) {
                if (arguments.length) {
                  configObj[namespace] = newValue;
                  return providerObj;
                }
                if (configObj[namespace] == PLATFORM) {
                  var platformConfig = stringObj(configProperties.platform, ionic.Platform.platform() + platformPath + '.' + namespace);
                  if (platformConfig || platformConfig === false) {
                    return platformConfig;
                  }
                  return stringObj(configProperties.platform, 'default' + platformPath + '.' + namespace);
                }
                return configObj[namespace];
              };
            }
          });
        }
        function stringObj(obj, str) {
          str = str.split(".");
          for (var i = 0; i < str.length; i++) {
            if (obj && isDefined(obj[str[i]])) {
              obj = obj[str[i]];
            } else {
              return null;
            }
          }
          return obj;
        }
        provider.setPlatformConfig = setPlatformConfig;
        provider.$get = function() {
          return provider;
        };
      }).config(['$compileProvider', function($compileProvider) {
        $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|tel|ftp|mailto|file|ghttps?|ms-appx|x-wmapp0):/);
        $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|file|content|blob|ms-appx|x-wmapp0):|data:image\//);
      }]);
      var LOADING_TPL = '<div class="loading-container">' + '<div class="loading">' + '</div>' + '</div>';
      var LOADING_HIDE_DEPRECATED = '$ionicLoading instance.hide() has been deprecated. Use $ionicLoading.hide().';
      var LOADING_SHOW_DEPRECATED = '$ionicLoading instance.show() has been deprecated. Use $ionicLoading.show().';
      var LOADING_SET_DEPRECATED = '$ionicLoading instance.setContent() has been deprecated. Use $ionicLoading.show({ template: \'my content\' }).';
      IonicModule.constant('$ionicLoadingConfig', {template: '<ion-spinner></ion-spinner>'}).factory('$ionicLoading', ['$ionicLoadingConfig', '$ionicBody', '$ionicTemplateLoader', '$ionicBackdrop', '$timeout', '$q', '$log', '$compile', '$ionicPlatform', '$rootScope', 'IONIC_BACK_PRIORITY', function($ionicLoadingConfig, $ionicBody, $ionicTemplateLoader, $ionicBackdrop, $timeout, $q, $log, $compile, $ionicPlatform, $rootScope, IONIC_BACK_PRIORITY) {
        var loaderInstance;
        var deregisterBackAction = noop;
        var deregisterStateListener1 = noop;
        var deregisterStateListener2 = noop;
        var loadingShowDelay = $q.when();
        return {
          show: showLoader,
          hide: hideLoader,
          _getLoader: getLoader
        };
        function getLoader() {
          if (!loaderInstance) {
            loaderInstance = $ionicTemplateLoader.compile({
              template: LOADING_TPL,
              appendTo: $ionicBody.get()
            }).then(function(self) {
              self.show = function(options) {
                var templatePromise = options.templateUrl ? $ionicTemplateLoader.load(options.templateUrl) : $q.when(options.template || options.content || '');
                self.scope = options.scope || self.scope;
                if (!self.isShown) {
                  self.hasBackdrop = !options.noBackdrop && options.showBackdrop !== false;
                  if (self.hasBackdrop) {
                    $ionicBackdrop.retain();
                    $ionicBackdrop.getElement().addClass('backdrop-loading');
                  }
                }
                if (options.duration) {
                  $timeout.cancel(self.durationTimeout);
                  self.durationTimeout = $timeout(angular.bind(self, self.hide), +options.duration);
                }
                deregisterBackAction();
                deregisterBackAction = $ionicPlatform.registerBackButtonAction(noop, IONIC_BACK_PRIORITY.loading);
                templatePromise.then(function(html) {
                  if (html) {
                    var loading = self.element.children();
                    loading.html(html);
                    $compile(loading.contents())(self.scope);
                  }
                  if (self.isShown) {
                    self.element.addClass('visible');
                    ionic.requestAnimationFrame(function() {
                      if (self.isShown) {
                        self.element.addClass('active');
                        $ionicBody.addClass('loading-active');
                      }
                    });
                  }
                });
                self.isShown = true;
              };
              self.hide = function() {
                deregisterBackAction();
                if (self.isShown) {
                  if (self.hasBackdrop) {
                    $ionicBackdrop.release();
                    $ionicBackdrop.getElement().removeClass('backdrop-loading');
                  }
                  self.element.removeClass('active');
                  $ionicBody.removeClass('loading-active');
                  setTimeout(function() {
                    !self.isShown && self.element.removeClass('visible');
                  }, 200);
                }
                $timeout.cancel(self.durationTimeout);
                self.isShown = false;
              };
              return self;
            });
          }
          return loaderInstance;
        }
        function showLoader(options) {
          options = extend({}, $ionicLoadingConfig || {}, options || {});
          var delay = options.delay || options.showDelay || 0;
          deregisterStateListener1();
          deregisterStateListener2();
          if (options.hideOnStateChange) {
            deregisterStateListener1 = $rootScope.$on('$stateChangeSuccess', hideLoader);
            deregisterStateListener2 = $rootScope.$on('$stateChangeError', hideLoader);
          }
          $timeout.cancel(loadingShowDelay);
          loadingShowDelay = $timeout(noop, delay);
          loadingShowDelay.then(getLoader).then(function(loader) {
            return loader.show(options);
          });
          return {
            hide: function deprecatedHide() {
              $log.error(LOADING_HIDE_DEPRECATED);
              return hideLoader.apply(this, arguments);
            },
            show: function deprecatedShow() {
              $log.error(LOADING_SHOW_DEPRECATED);
              return showLoader.apply(this, arguments);
            },
            setContent: function deprecatedSetContent(content) {
              $log.error(LOADING_SET_DEPRECATED);
              return getLoader().then(function(loader) {
                loader.show({template: content});
              });
            }
          };
        }
        function hideLoader() {
          deregisterStateListener1();
          deregisterStateListener2();
          $timeout.cancel(loadingShowDelay);
          getLoader().then(function(loader) {
            loader.hide();
          });
        }
      }]);
      IonicModule.factory('$ionicModal', ['$rootScope', '$ionicBody', '$compile', '$timeout', '$ionicPlatform', '$ionicTemplateLoader', '$$q', '$log', '$ionicClickBlock', '$window', 'IONIC_BACK_PRIORITY', function($rootScope, $ionicBody, $compile, $timeout, $ionicPlatform, $ionicTemplateLoader, $$q, $log, $ionicClickBlock, $window, IONIC_BACK_PRIORITY) {
        var ModalView = ionic.views.Modal.inherit({
          initialize: function(opts) {
            ionic.views.Modal.prototype.initialize.call(this, opts);
            this.animation = opts.animation || 'slide-in-up';
          },
          show: function(target) {
            var self = this;
            if (self.scope.$$destroyed) {
              $log.error('Cannot call ' + self.viewType + '.show() after remove(). Please create a new ' + self.viewType + ' instance.');
              return $$q.when();
            }
            $ionicClickBlock.show(600);
            stack.add(self);
            var modalEl = jqLite(self.modalEl);
            self.el.classList.remove('hide');
            $timeout(function() {
              if (!self._isShown)
                return ;
              $ionicBody.addClass(self.viewType + '-open');
            }, 400, false);
            if (!self.el.parentElement) {
              modalEl.addClass(self.animation);
              $ionicBody.append(self.el);
            }
            var scrollCtrl = modalEl.data('$$ionicScrollController');
            scrollCtrl && scrollCtrl.resize();
            if (target && self.positionView) {
              self.positionView(target, modalEl);
              self._onWindowResize = function() {
                if (self._isShown)
                  self.positionView(target, modalEl);
              };
              ionic.on('resize', self._onWindowResize, window);
            }
            modalEl.addClass('ng-enter active').removeClass('ng-leave ng-leave-active');
            self._isShown = true;
            self._deregisterBackButton = $ionicPlatform.registerBackButtonAction(self.hardwareBackButtonClose ? angular.bind(self, self.hide) : noop, IONIC_BACK_PRIORITY.modal);
            ionic.views.Modal.prototype.show.call(self);
            $timeout(function() {
              if (!self._isShown)
                return ;
              modalEl.addClass('ng-enter-active');
              ionic.trigger('resize');
              self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.shown', self);
              self.el.classList.add('active');
              self.scope.$broadcast('$ionicHeader.align');
            }, 20);
            return $timeout(function() {
              if (!self._isShown)
                return ;
              self.$el.on('click', function(e) {
                if (self.backdropClickToClose && e.target === self.el && stack.isHighest(self)) {
                  self.hide();
                }
              });
            }, 400);
          },
          hide: function() {
            var self = this;
            var modalEl = jqLite(self.modalEl);
            $ionicClickBlock.show(600);
            stack.remove(self);
            self.el.classList.remove('active');
            modalEl.addClass('ng-leave');
            $timeout(function() {
              if (self._isShown)
                return ;
              modalEl.addClass('ng-leave-active').removeClass('ng-enter ng-enter-active active');
            }, 20, false);
            self.$el.off('click');
            self._isShown = false;
            self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.hidden', self);
            self._deregisterBackButton && self._deregisterBackButton();
            ionic.views.Modal.prototype.hide.call(self);
            if (self.positionView) {
              ionic.off('resize', self._onWindowResize, window);
            }
            return $timeout(function() {
              $ionicBody.removeClass(self.viewType + '-open');
              self.el.classList.add('hide');
            }, self.hideDelay || 320);
          },
          remove: function() {
            var self = this;
            self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.removed', self);
            return self.hide().then(function() {
              self.scope.$destroy();
              self.$el.remove();
            });
          },
          isShown: function() {
            return !!this._isShown;
          }
        });
        var createModal = function(templateString, options) {
          var scope = options.scope && options.scope.$new() || $rootScope.$new(true);
          options.viewType = options.viewType || 'modal';
          extend(scope, {
            $hasHeader: false,
            $hasSubheader: false,
            $hasFooter: false,
            $hasSubfooter: false,
            $hasTabs: false,
            $hasTabsTop: false
          });
          var element = $compile('<ion-' + options.viewType + '>' + templateString + '</ion-' + options.viewType + '>')(scope);
          options.$el = element;
          options.el = element[0];
          options.modalEl = options.el.querySelector('.' + options.viewType);
          var modal = new ModalView(options);
          modal.scope = scope;
          if (!options.scope) {
            scope[options.viewType] = modal;
          }
          return modal;
        };
        var modalStack = [];
        var stack = {
          add: function(modal) {
            modalStack.push(modal);
          },
          remove: function(modal) {
            var index = modalStack.indexOf(modal);
            if (index > -1 && index < modalStack.length) {
              modalStack.splice(index, 1);
            }
          },
          isHighest: function(modal) {
            var index = modalStack.indexOf(modal);
            return (index > -1 && index === modalStack.length - 1);
          }
        };
        return {
          fromTemplate: function(templateString, options) {
            var modal = createModal(templateString, options || {});
            return modal;
          },
          fromTemplateUrl: function(url, options, _) {
            var cb;
            if (angular.isFunction(options)) {
              cb = options;
              options = _;
            }
            return $ionicTemplateLoader.load(url).then(function(templateString) {
              var modal = createModal(templateString, options || {});
              cb && cb(modal);
              return modal;
            });
          },
          stack: stack
        };
      }]);
      IonicModule.service('$ionicNavBarDelegate', ionic.DelegateService(['align', 'showBackButton', 'showBar', 'title', 'changeTitle', 'setTitle', 'getTitle', 'back', 'getPreviousTitle']));
      IonicModule.service('$ionicNavViewDelegate', ionic.DelegateService(['clearCache']));
      IonicModule.constant('IONIC_BACK_PRIORITY', {
        view: 100,
        sideMenu: 150,
        modal: 200,
        actionSheet: 300,
        popup: 400,
        loading: 500
      }).provider('$ionicPlatform', function() {
        return {$get: ['$q', function($q) {
            var self = {
              onHardwareBackButton: function(cb) {
                ionic.Platform.ready(function() {
                  document.addEventListener('backbutton', cb, false);
                });
              },
              offHardwareBackButton: function(fn) {
                ionic.Platform.ready(function() {
                  document.removeEventListener('backbutton', fn);
                });
              },
              $backButtonActions: {},
              registerBackButtonAction: function(fn, priority, actionId) {
                if (!self._hasBackButtonHandler) {
                  self.$backButtonActions = {};
                  self.onHardwareBackButton(self.hardwareBackButtonClick);
                  self._hasBackButtonHandler = true;
                }
                var action = {
                  id: (actionId ? actionId : ionic.Utils.nextUid()),
                  priority: (priority ? priority : 0),
                  fn: fn
                };
                self.$backButtonActions[action.id] = action;
                return function() {
                  delete self.$backButtonActions[action.id];
                };
              },
              hardwareBackButtonClick: function(e) {
                var priorityAction,
                    actionId;
                for (actionId in self.$backButtonActions) {
                  if (!priorityAction || self.$backButtonActions[actionId].priority >= priorityAction.priority) {
                    priorityAction = self.$backButtonActions[actionId];
                  }
                }
                if (priorityAction) {
                  priorityAction.fn(e);
                  return priorityAction;
                }
              },
              is: function(type) {
                return ionic.Platform.is(type);
              },
              on: function(type, cb) {
                ionic.Platform.ready(function() {
                  document.addEventListener(type, cb, false);
                });
                return function() {
                  ionic.Platform.ready(function() {
                    document.removeEventListener(type, cb);
                  });
                };
              },
              ready: function(cb) {
                var q = $q.defer();
                ionic.Platform.ready(function() {
                  q.resolve();
                  cb && cb();
                });
                return q.promise;
              }
            };
            return self;
          }]};
      });
      IonicModule.factory('$ionicPopover', ['$ionicModal', '$ionicPosition', '$document', '$window', function($ionicModal, $ionicPosition, $document, $window) {
        var POPOVER_BODY_PADDING = 6;
        var POPOVER_OPTIONS = {
          viewType: 'popover',
          hideDelay: 1,
          animation: 'none',
          positionView: positionView
        };
        function positionView(target, popoverEle) {
          var targetEle = jqLite(target.target || target);
          var buttonOffset = $ionicPosition.offset(targetEle);
          var popoverWidth = popoverEle.prop('offsetWidth');
          var popoverHeight = popoverEle.prop('offsetHeight');
          var bodyWidth = $window.innerWidth;
          var bodyHeight = $window.innerHeight;
          var popoverCSS = {left: buttonOffset.left + buttonOffset.width / 2 - popoverWidth / 2};
          var arrowEle = jqLite(popoverEle[0].querySelector('.popover-arrow'));
          if (popoverCSS.left < POPOVER_BODY_PADDING) {
            popoverCSS.left = POPOVER_BODY_PADDING;
          } else if (popoverCSS.left + popoverWidth + POPOVER_BODY_PADDING > bodyWidth) {
            popoverCSS.left = bodyWidth - popoverWidth - POPOVER_BODY_PADDING;
          }
          if (buttonOffset.top + buttonOffset.height + popoverHeight > bodyHeight && buttonOffset.top - popoverHeight > 0) {
            popoverCSS.top = buttonOffset.top - popoverHeight;
            popoverEle.addClass('popover-bottom');
          } else {
            popoverCSS.top = buttonOffset.top + buttonOffset.height;
            popoverEle.removeClass('popover-bottom');
          }
          arrowEle.css({left: buttonOffset.left + buttonOffset.width / 2 - arrowEle.prop('offsetWidth') / 2 - popoverCSS.left + 'px'});
          popoverEle.css({
            top: popoverCSS.top + 'px',
            left: popoverCSS.left + 'px',
            marginLeft: '0',
            opacity: '1'
          });
        }
        return {
          fromTemplate: function(templateString, options) {
            return $ionicModal.fromTemplate(templateString, ionic.Utils.extend(POPOVER_OPTIONS, options || {}));
          },
          fromTemplateUrl: function(url, options) {
            return $ionicModal.fromTemplateUrl(url, ionic.Utils.extend(POPOVER_OPTIONS, options || {}));
          }
        };
      }]);
      var POPUP_TPL = '<div class="popup-container" ng-class="cssClass">' + '<div class="popup">' + '<div class="popup-head">' + '<h3 class="popup-title" ng-bind-html="title"></h3>' + '<h5 class="popup-sub-title" ng-bind-html="subTitle" ng-if="subTitle"></h5>' + '</div>' + '<div class="popup-body">' + '</div>' + '<div class="popup-buttons" ng-show="buttons.length">' + '<button ng-repeat="button in buttons" ng-click="$buttonTapped(button, $event)" class="button" ng-class="button.type || \'button-default\'" ng-bind-html="button.text"></button>' + '</div>' + '</div>' + '</div>';
      IonicModule.factory('$ionicPopup', ['$ionicTemplateLoader', '$ionicBackdrop', '$q', '$timeout', '$rootScope', '$ionicBody', '$compile', '$ionicPlatform', '$ionicModal', 'IONIC_BACK_PRIORITY', function($ionicTemplateLoader, $ionicBackdrop, $q, $timeout, $rootScope, $ionicBody, $compile, $ionicPlatform, $ionicModal, IONIC_BACK_PRIORITY) {
        var config = {stackPushDelay: 75};
        var popupStack = [];
        var $ionicPopup = {
          show: showPopup,
          alert: showAlert,
          confirm: showConfirm,
          prompt: showPrompt,
          _createPopup: createPopup,
          _popupStack: popupStack
        };
        return $ionicPopup;
        function createPopup(options) {
          options = extend({
            scope: null,
            title: '',
            buttons: []
          }, options || {});
          var self = {};
          self.scope = (options.scope || $rootScope).$new();
          self.element = jqLite(POPUP_TPL);
          self.responseDeferred = $q.defer();
          $ionicBody.get().appendChild(self.element[0]);
          $compile(self.element)(self.scope);
          extend(self.scope, {
            title: options.title,
            buttons: options.buttons,
            subTitle: options.subTitle,
            cssClass: options.cssClass,
            $buttonTapped: function(button, event) {
              var result = (button.onTap || noop)(event);
              event = event.originalEvent || event;
              if (!event.defaultPrevented) {
                self.responseDeferred.resolve(result);
              }
            }
          });
          $q.when(options.templateUrl ? $ionicTemplateLoader.load(options.templateUrl) : (options.template || options.content || '')).then(function(template) {
            var popupBody = jqLite(self.element[0].querySelector('.popup-body'));
            if (template) {
              popupBody.html(template);
              $compile(popupBody.contents())(self.scope);
            } else {
              popupBody.remove();
            }
          });
          self.show = function() {
            if (self.isShown || self.removed)
              return ;
            $ionicModal.stack.add(self);
            self.isShown = true;
            ionic.requestAnimationFrame(function() {
              if (!self.isShown)
                return ;
              self.element.removeClass('popup-hidden');
              self.element.addClass('popup-showing active');
              focusInput(self.element);
            });
          };
          self.hide = function(callback) {
            callback = callback || noop;
            if (!self.isShown)
              return callback();
            $ionicModal.stack.remove(self);
            self.isShown = false;
            self.element.removeClass('active');
            self.element.addClass('popup-hidden');
            $timeout(callback, 250, false);
          };
          self.remove = function() {
            if (self.removed || !$ionicModal.stack.isHighest(self))
              return ;
            self.hide(function() {
              self.element.remove();
              self.scope.$destroy();
            });
            self.removed = true;
          };
          return self;
        }
        function onHardwareBackButton() {
          var last = popupStack[popupStack.length - 1];
          last && last.responseDeferred.resolve();
        }
        function showPopup(options) {
          var popup = $ionicPopup._createPopup(options);
          var showDelay = 0;
          if (popupStack.length > 0) {
            popupStack[popupStack.length - 1].hide();
            showDelay = config.stackPushDelay;
          } else {
            $ionicBody.addClass('popup-open');
            $ionicBackdrop.retain();
            $ionicPopup._backButtonActionDone = $ionicPlatform.registerBackButtonAction(onHardwareBackButton, IONIC_BACK_PRIORITY.popup);
          }
          popup.responseDeferred.promise.close = function popupClose(result) {
            if (!popup.removed)
              popup.responseDeferred.resolve(result);
          };
          popup.responseDeferred.notify({close: popup.responseDeferred.close});
          doShow();
          return popup.responseDeferred.promise;
          function doShow() {
            popupStack.push(popup);
            $timeout(popup.show, showDelay, false);
            popup.responseDeferred.promise.then(function(result) {
              var index = popupStack.indexOf(popup);
              if (index !== -1) {
                popupStack.splice(index, 1);
              }
              if (popupStack.length > 0) {
                popupStack[popupStack.length - 1].show();
              } else {
                $ionicBackdrop.release();
                $timeout(function() {
                  if (!popupStack.length) {
                    $ionicBody.removeClass('popup-open');
                  }
                }, 400, false);
                ($ionicPopup._backButtonActionDone || noop)();
              }
              popup.remove();
              return result;
            });
          }
        }
        function focusInput(element) {
          var focusOn = element[0].querySelector('[autofocus]');
          if (focusOn) {
            focusOn.focus();
          }
        }
        function showAlert(opts) {
          return showPopup(extend({buttons: [{
              text: opts.okText || 'OK',
              type: opts.okType || 'button-positive',
              onTap: function() {
                return true;
              }
            }]}, opts || {}));
        }
        function showConfirm(opts) {
          return showPopup(extend({buttons: [{
              text: opts.cancelText || 'Cancel',
              type: opts.cancelType || 'button-default',
              onTap: function() {
                return false;
              }
            }, {
              text: opts.okText || 'OK',
              type: opts.okType || 'button-positive',
              onTap: function() {
                return true;
              }
            }]}, opts || {}));
        }
        function showPrompt(opts) {
          var scope = $rootScope.$new(true);
          scope.data = {};
          var text = '';
          if (opts.template && /<[a-z][\s\S]*>/i.test(opts.template) === false) {
            text = '<span>' + opts.template + '</span>';
            delete opts.template;
          }
          return showPopup(extend({
            template: text + '<input ng-model="data.response" type="' + (opts.inputType || 'text') + '" placeholder="' + (opts.inputPlaceholder || '') + '">',
            scope: scope,
            buttons: [{
              text: opts.cancelText || 'Cancel',
              type: opts.cancelType || 'button-default',
              onTap: function() {}
            }, {
              text: opts.okText || 'OK',
              type: opts.okType || 'button-positive',
              onTap: function() {
                return scope.data.response || '';
              }
            }]
          }, opts || {}));
        }
      }]);
      IonicModule.factory('$ionicPosition', ['$document', '$window', function($document, $window) {
        function getStyle(el, cssprop) {
          if (el.currentStyle) {
            return el.currentStyle[cssprop];
          } else if ($window.getComputedStyle) {
            return $window.getComputedStyle(el)[cssprop];
          }
          return el.style[cssprop];
        }
        function isStaticPositioned(element) {
          return (getStyle(element, 'position') || 'static') === 'static';
        }
        var parentOffsetEl = function(element) {
          var docDomEl = $document[0];
          var offsetParent = element.offsetParent || docDomEl;
          while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent)) {
            offsetParent = offsetParent.offsetParent;
          }
          return offsetParent || docDomEl;
        };
        return {
          position: function(element) {
            var elBCR = this.offset(element);
            var offsetParentBCR = {
              top: 0,
              left: 0
            };
            var offsetParentEl = parentOffsetEl(element[0]);
            if (offsetParentEl != $document[0]) {
              offsetParentBCR = this.offset(jqLite(offsetParentEl));
              offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
              offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
            }
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
              width: boundingClientRect.width || element.prop('offsetWidth'),
              height: boundingClientRect.height || element.prop('offsetHeight'),
              top: elBCR.top - offsetParentBCR.top,
              left: elBCR.left - offsetParentBCR.left
            };
          },
          offset: function(element) {
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
              width: boundingClientRect.width || element.prop('offsetWidth'),
              height: boundingClientRect.height || element.prop('offsetHeight'),
              top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
              left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
            };
          }
        };
      }]);
      IonicModule.service('$ionicScrollDelegate', ionic.DelegateService(['resize', 'scrollTop', 'scrollBottom', 'scrollTo', 'scrollBy', 'zoomTo', 'zoomBy', 'getScrollPosition', 'anchorScroll', 'freezeScroll', 'freezeAllScrolls', 'getScrollView']));
      IonicModule.service('$ionicSideMenuDelegate', ionic.DelegateService(['toggleLeft', 'toggleRight', 'getOpenRatio', 'isOpen', 'isOpenLeft', 'isOpenRight', 'canDragContent', 'edgeDragThreshold']));
      IonicModule.service('$ionicSlideBoxDelegate', ionic.DelegateService(['update', 'slide', 'select', 'enableSlide', 'previous', 'next', 'stop', 'autoPlay', 'start', 'currentIndex', 'selected', 'slidesCount', 'count', 'loop']));
      IonicModule.service('$ionicTabsDelegate', ionic.DelegateService(['select', 'selectedIndex']));
      (function() {
        var templatesToCache = [];
        IonicModule.factory('$ionicTemplateCache', ['$http', '$templateCache', '$timeout', function($http, $templateCache, $timeout) {
          var toCache = templatesToCache,
              hasRun;
          function $ionicTemplateCache(templates) {
            if (typeof templates === 'undefined') {
              return run();
            }
            if (isString(templates)) {
              templates = [templates];
            }
            forEach(templates, function(template) {
              toCache.push(template);
            });
            if (hasRun) {
              run();
            }
          }
          function run() {
            var template;
            $ionicTemplateCache._runCount++;
            hasRun = true;
            if (toCache.length === 0)
              return ;
            var i = 0;
            while (i < 4 && (template = toCache.pop())) {
              if (isString(template))
                $http.get(template, {cache: $templateCache});
              i++;
            }
            if (toCache.length) {
              $timeout(run, 1000);
            }
          }
          $ionicTemplateCache._runCount = 0;
          return $ionicTemplateCache;
        }]).config(['$stateProvider', '$ionicConfigProvider', function($stateProvider, $ionicConfigProvider) {
          var stateProviderState = $stateProvider.state;
          $stateProvider.state = function(stateName, definition) {
            if (typeof definition === 'object') {
              var enabled = definition.prefetchTemplate !== false && templatesToCache.length < $ionicConfigProvider.templates.maxPrefetch();
              if (enabled && isString(definition.templateUrl))
                templatesToCache.push(definition.templateUrl);
              if (angular.isObject(definition.views)) {
                for (var key in definition.views) {
                  enabled = definition.views[key].prefetchTemplate !== false && templatesToCache.length < $ionicConfigProvider.templates.maxPrefetch();
                  if (enabled && isString(definition.views[key].templateUrl))
                    templatesToCache.push(definition.views[key].templateUrl);
                }
              }
            }
            return stateProviderState.call($stateProvider, stateName, definition);
          };
        }]).run(['$ionicTemplateCache', function($ionicTemplateCache) {
          $ionicTemplateCache();
        }]);
      })();
      IonicModule.factory('$ionicTemplateLoader', ['$compile', '$controller', '$http', '$q', '$rootScope', '$templateCache', function($compile, $controller, $http, $q, $rootScope, $templateCache) {
        return {
          load: fetchTemplate,
          compile: loadAndCompile
        };
        function fetchTemplate(url) {
          return $http.get(url, {cache: $templateCache}).then(function(response) {
            return response.data && response.data.trim();
          });
        }
        function loadAndCompile(options) {
          options = extend({
            template: '',
            templateUrl: '',
            scope: null,
            controller: null,
            locals: {},
            appendTo: null
          }, options || {});
          var templatePromise = options.templateUrl ? this.load(options.templateUrl) : $q.when(options.template);
          return templatePromise.then(function(template) {
            var controller;
            var scope = options.scope || $rootScope.$new();
            var element = jqLite('<div>').html(template).contents();
            if (options.controller) {
              controller = $controller(options.controller, extend(options.locals, {$scope: scope}));
              element.children().data('$ngControllerController', controller);
            }
            if (options.appendTo) {
              jqLite(options.appendTo).append(element);
            }
            $compile(element)(scope);
            return {
              element: element,
              scope: scope
            };
          });
        }
      }]);
      IonicModule.factory('$ionicViewService', ['$ionicHistory', '$log', function($ionicHistory, $log) {
        function warn(oldMethod, newMethod) {
          $log.warn('$ionicViewService' + oldMethod + ' is deprecated, please use $ionicHistory' + newMethod + ' instead: http://ionicframework.com/docs/nightly/api/service/$ionicHistory/');
        }
        warn('', '');
        var methodsMap = {
          getCurrentView: 'currentView',
          getBackView: 'backView',
          getForwardView: 'forwardView',
          getCurrentStateName: 'currentStateName',
          nextViewOptions: 'nextViewOptions',
          clearHistory: 'clearHistory'
        };
        forEach(methodsMap, function(newMethod, oldMethod) {
          methodsMap[oldMethod] = function() {
            warn('.' + oldMethod, '.' + newMethod);
            return $ionicHistory[newMethod].apply(this, arguments);
          };
        });
        return methodsMap;
      }]);
      IonicModule.factory('$ionicViewSwitcher', ['$timeout', '$document', '$q', '$ionicClickBlock', '$ionicConfig', '$ionicNavBarDelegate', function($timeout, $document, $q, $ionicClickBlock, $ionicConfig, $ionicNavBarDelegate) {
        var TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
        var DATA_NO_CACHE = '$noCache';
        var DATA_DESTROY_ELE = '$destroyEle';
        var DATA_ELE_IDENTIFIER = '$eleId';
        var DATA_VIEW_ACCESSED = '$accessed';
        var DATA_FALLBACK_TIMER = '$fallbackTimer';
        var DATA_VIEW = '$viewData';
        var NAV_VIEW_ATTR = 'nav-view';
        var VIEW_STATUS_ACTIVE = 'active';
        var VIEW_STATUS_CACHED = 'cached';
        var VIEW_STATUS_STAGED = 'stage';
        var transitionCounter = 0;
        var nextTransition,
            nextDirection;
        ionic.transition = ionic.transition || {};
        ionic.transition.isActive = false;
        var isActiveTimer;
        var cachedAttr = ionic.DomUtil.cachedAttr;
        var transitionPromises = [];
        var defaultTimeout = 1100;
        var ionicViewSwitcher = {
          create: function(navViewCtrl, viewLocals, enteringView, leavingView, renderStart, renderEnd) {
            var enteringEle,
                leavingEle;
            var transitionId = ++transitionCounter;
            var alreadyInDom;
            var switcher = {
              init: function(registerData, callback) {
                ionicViewSwitcher.isTransitioning(true);
                switcher.loadViewElements(registerData);
                switcher.render(registerData, function() {
                  callback && callback();
                });
              },
              loadViewElements: function(registerData) {
                var x,
                    l,
                    viewEle;
                var viewElements = navViewCtrl.getViewElements();
                var enteringEleIdentifier = getViewElementIdentifier(viewLocals, enteringView);
                var navViewActiveEleId = navViewCtrl.activeEleId();
                for (x = 0, l = viewElements.length; x < l; x++) {
                  viewEle = viewElements.eq(x);
                  if (viewEle.data(DATA_ELE_IDENTIFIER) === enteringEleIdentifier) {
                    if (viewEle.data(DATA_NO_CACHE)) {
                      viewEle.data(DATA_ELE_IDENTIFIER, enteringEleIdentifier + ionic.Utils.nextUid());
                      viewEle.data(DATA_DESTROY_ELE, true);
                    } else {
                      enteringEle = viewEle;
                    }
                  } else if (isDefined(navViewActiveEleId) && viewEle.data(DATA_ELE_IDENTIFIER) === navViewActiveEleId) {
                    leavingEle = viewEle;
                  }
                  if (enteringEle && leavingEle)
                    break;
                }
                alreadyInDom = !!enteringEle;
                if (!alreadyInDom) {
                  enteringEle = registerData.ele || ionicViewSwitcher.createViewEle(viewLocals);
                  enteringEle.data(DATA_ELE_IDENTIFIER, enteringEleIdentifier);
                }
                if (renderEnd) {
                  navViewCtrl.activeEleId(enteringEleIdentifier);
                }
                registerData.ele = null;
              },
              render: function(registerData, callback) {
                if (alreadyInDom) {
                  ionic.Utils.reconnectScope(enteringEle.scope());
                } else {
                  navViewAttr(enteringEle, VIEW_STATUS_STAGED);
                  var enteringData = getTransitionData(viewLocals, enteringEle, registerData.direction, enteringView);
                  var transitionFn = $ionicConfig.transitions.views[enteringData.transition] || $ionicConfig.transitions.views.none;
                  transitionFn(enteringEle, null, enteringData.direction, true).run(0);
                  enteringEle.data(DATA_VIEW, {
                    viewId: enteringData.viewId,
                    historyId: enteringData.historyId,
                    stateName: enteringData.stateName,
                    stateParams: enteringData.stateParams
                  });
                  if (viewState(viewLocals).cache === false || viewState(viewLocals).cache === 'false' || enteringEle.attr('cache-view') == 'false' || $ionicConfig.views.maxCache() === 0) {
                    enteringEle.data(DATA_NO_CACHE, true);
                  }
                  var viewScope = navViewCtrl.appendViewElement(enteringEle, viewLocals);
                  delete enteringData.direction;
                  delete enteringData.transition;
                  viewScope.$emit('$ionicView.loaded', enteringData);
                }
                enteringEle.data(DATA_VIEW_ACCESSED, Date.now());
                callback && callback();
              },
              transition: function(direction, enableBack, allowAnimate) {
                var deferred;
                var enteringData = getTransitionData(viewLocals, enteringEle, direction, enteringView);
                var leavingData = extend(extend({}, enteringData), getViewData(leavingView));
                enteringData.transitionId = leavingData.transitionId = transitionId;
                enteringData.fromCache = !!alreadyInDom;
                enteringData.enableBack = !!enableBack;
                enteringData.renderStart = renderStart;
                enteringData.renderEnd = renderEnd;
                cachedAttr(enteringEle.parent(), 'nav-view-transition', enteringData.transition);
                cachedAttr(enteringEle.parent(), 'nav-view-direction', enteringData.direction);
                $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));
                var transitionFn = $ionicConfig.transitions.views[enteringData.transition] || $ionicConfig.transitions.views.none;
                var viewTransition = transitionFn(enteringEle, leavingEle, enteringData.direction, enteringData.shouldAnimate && allowAnimate && renderEnd);
                if (viewTransition.shouldAnimate) {
                  enteringEle.on(TRANSITIONEND_EVENT, completeOnTransitionEnd);
                  enteringEle.data(DATA_FALLBACK_TIMER, $timeout(transitionComplete, defaultTimeout));
                  $ionicClickBlock.show(defaultTimeout);
                }
                if (renderStart) {
                  switcher.emit('before', enteringData, leavingData);
                  navViewAttr(enteringEle, VIEW_STATUS_STAGED);
                  viewTransition.run(0);
                }
                if (renderEnd) {
                  deferred = $q.defer();
                  transitionPromises.push(deferred.promise);
                }
                if (renderStart && renderEnd) {
                  $timeout(onReflow, 16);
                } else if (!renderEnd) {
                  navViewAttr(enteringEle, 'entering');
                  navViewAttr(leavingEle, 'leaving');
                  return {
                    run: viewTransition.run,
                    cancel: function(shouldAnimate) {
                      if (shouldAnimate) {
                        enteringEle.on(TRANSITIONEND_EVENT, cancelOnTransitionEnd);
                        enteringEle.data(DATA_FALLBACK_TIMER, $timeout(cancelTransition, defaultTimeout));
                        $ionicClickBlock.show(defaultTimeout);
                      } else {
                        cancelTransition();
                      }
                      viewTransition.shouldAnimate = shouldAnimate;
                      viewTransition.run(0);
                      viewTransition = null;
                    }
                  };
                } else if (renderEnd) {
                  onReflow();
                }
                function onReflow() {
                  navViewAttr(enteringEle, viewTransition.shouldAnimate ? 'entering' : VIEW_STATUS_ACTIVE);
                  navViewAttr(leavingEle, viewTransition.shouldAnimate ? 'leaving' : VIEW_STATUS_CACHED);
                  viewTransition.run(1);
                  $ionicNavBarDelegate._instances.forEach(function(instance) {
                    instance.triggerTransitionStart(transitionId);
                  });
                  if (!viewTransition.shouldAnimate) {
                    transitionComplete();
                  }
                }
                function completeOnTransitionEnd(ev) {
                  if (ev.target !== this)
                    return ;
                  transitionComplete();
                }
                function transitionComplete() {
                  if (transitionComplete.x)
                    return ;
                  transitionComplete.x = true;
                  enteringEle.off(TRANSITIONEND_EVENT, completeOnTransitionEnd);
                  $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));
                  leavingEle && $timeout.cancel(leavingEle.data(DATA_FALLBACK_TIMER));
                  switcher.emit('after', enteringData, leavingData);
                  deferred && deferred.resolve(navViewCtrl);
                  if (transitionId === transitionCounter) {
                    $q.all(transitionPromises).then(ionicViewSwitcher.transitionEnd);
                    switcher.cleanup(enteringData);
                  }
                  $ionicNavBarDelegate._instances.forEach(function(instance) {
                    instance.triggerTransitionEnd();
                  });
                  nextTransition = nextDirection = enteringView = leavingView = enteringEle = leavingEle = null;
                }
                function cancelOnTransitionEnd(ev) {
                  if (ev.target !== this)
                    return ;
                  cancelTransition();
                }
                function cancelTransition() {
                  navViewAttr(enteringEle, VIEW_STATUS_CACHED);
                  navViewAttr(leavingEle, VIEW_STATUS_ACTIVE);
                  enteringEle.off(TRANSITIONEND_EVENT, cancelOnTransitionEnd);
                  $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));
                  ionicViewSwitcher.transitionEnd([navViewCtrl]);
                }
              },
              emit: function(step, enteringData, leavingData) {
                var enteringScope = enteringEle.scope(),
                    leavingScope = leavingEle && leavingEle.scope();
                if (step == 'after') {
                  if (enteringScope) {
                    enteringScope.$emit('$ionicView.enter', enteringData);
                  }
                  if (leavingScope) {
                    leavingScope.$emit('$ionicView.leave', leavingData);
                  } else if (enteringScope && leavingData && leavingData.viewId) {
                    enteringScope.$emit('$ionicNavView.leave', leavingData);
                  }
                }
                if (enteringScope) {
                  enteringScope.$emit('$ionicView.' + step + 'Enter', enteringData);
                }
                if (leavingScope) {
                  leavingScope.$emit('$ionicView.' + step + 'Leave', leavingData);
                } else if (enteringScope && leavingData && leavingData.viewId) {
                  enteringScope.$emit('$ionicNavView.' + step + 'Leave', leavingData);
                }
              },
              cleanup: function(transData) {
                if (leavingEle && transData.direction == 'back' && !$ionicConfig.views.forwardCache()) {
                  destroyViewEle(leavingEle);
                }
                var viewElements = navViewCtrl.getViewElements();
                var viewElementsLength = viewElements.length;
                var x,
                    viewElement;
                var removeOldestAccess = (viewElementsLength - 1) > $ionicConfig.views.maxCache();
                var removableEle;
                var oldestAccess = Date.now();
                for (x = 0; x < viewElementsLength; x++) {
                  viewElement = viewElements.eq(x);
                  if (removeOldestAccess && viewElement.data(DATA_VIEW_ACCESSED) < oldestAccess) {
                    oldestAccess = viewElement.data(DATA_VIEW_ACCESSED);
                    removableEle = viewElements.eq(x);
                  } else if (viewElement.data(DATA_DESTROY_ELE) && navViewAttr(viewElement) != VIEW_STATUS_ACTIVE) {
                    destroyViewEle(viewElement);
                  }
                }
                destroyViewEle(removableEle);
                if (enteringEle.data(DATA_NO_CACHE)) {
                  enteringEle.data(DATA_DESTROY_ELE, true);
                }
              },
              enteringEle: function() {
                return enteringEle;
              },
              leavingEle: function() {
                return leavingEle;
              }
            };
            return switcher;
          },
          transitionEnd: function(navViewCtrls) {
            forEach(navViewCtrls, function(navViewCtrl) {
              navViewCtrl.transitionEnd();
            });
            ionicViewSwitcher.isTransitioning(false);
            $ionicClickBlock.hide();
            transitionPromises = [];
          },
          nextTransition: function(val) {
            nextTransition = val;
          },
          nextDirection: function(val) {
            nextDirection = val;
          },
          isTransitioning: function(val) {
            if (arguments.length) {
              ionic.transition.isActive = !!val;
              $timeout.cancel(isActiveTimer);
              if (val) {
                isActiveTimer = $timeout(function() {
                  ionicViewSwitcher.isTransitioning(false);
                }, 999);
              }
            }
            return ionic.transition.isActive;
          },
          createViewEle: function(viewLocals) {
            var containerEle = $document[0].createElement('div');
            if (viewLocals && viewLocals.$template) {
              containerEle.innerHTML = viewLocals.$template;
              if (containerEle.children.length === 1) {
                containerEle.children[0].classList.add('pane');
                return jqLite(containerEle.children[0]);
              }
            }
            containerEle.className = "pane";
            return jqLite(containerEle);
          },
          viewEleIsActive: function(viewEle, isActiveAttr) {
            navViewAttr(viewEle, isActiveAttr ? VIEW_STATUS_ACTIVE : VIEW_STATUS_CACHED);
          },
          getTransitionData: getTransitionData,
          navViewAttr: navViewAttr,
          destroyViewEle: destroyViewEle
        };
        return ionicViewSwitcher;
        function getViewElementIdentifier(locals, view) {
          if (viewState(locals)['abstract'])
            return viewState(locals).name;
          if (view)
            return view.stateId || view.viewId;
          return ionic.Utils.nextUid();
        }
        function viewState(locals) {
          return locals && locals.$$state && locals.$$state.self || {};
        }
        function getTransitionData(viewLocals, enteringEle, direction, view) {
          var state = viewState(viewLocals);
          var viewTransition = nextTransition || cachedAttr(enteringEle, 'view-transition') || state.viewTransition || $ionicConfig.views.transition() || 'ios';
          var navBarTransition = $ionicConfig.navBar.transition();
          direction = nextDirection || cachedAttr(enteringEle, 'view-direction') || state.viewDirection || direction || 'none';
          return extend(getViewData(view), {
            transition: viewTransition,
            navBarTransition: navBarTransition === 'view' ? viewTransition : navBarTransition,
            direction: direction,
            shouldAnimate: (viewTransition !== 'none' && direction !== 'none')
          });
        }
        function getViewData(view) {
          view = view || {};
          return {
            viewId: view.viewId,
            historyId: view.historyId,
            stateId: view.stateId,
            stateName: view.stateName,
            stateParams: view.stateParams
          };
        }
        function navViewAttr(ele, value) {
          if (arguments.length > 1) {
            cachedAttr(ele, NAV_VIEW_ATTR, value);
          } else {
            return cachedAttr(ele, NAV_VIEW_ATTR);
          }
        }
        function destroyViewEle(ele) {
          if (ele && ele.length) {
            var viewScope = ele.scope();
            if (viewScope) {
              viewScope.$emit('$ionicView.unloaded', ele.data(DATA_VIEW));
              viewScope.$destroy();
            }
            ele.remove();
          }
        }
      }]);
      IonicModule.config(['$provide', function($provide) {
        $provide.decorator('$compile', ['$delegate', function($compile) {
          $compile.$$addScopeInfo = function $$addScopeInfo($element, scope, isolated, noTemplate) {
            var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
            $element.data(dataName, scope);
          };
          return $compile;
        }]);
      }]);
      IonicModule.config(['$provide', function($provide) {
        function $LocationDecorator($location, $timeout) {
          $location.__hash = $location.hash;
          $location.hash = function(value) {
            if (isDefined(value) && value.length > 0) {
              $timeout(function() {
                var scroll = document.querySelector('.scroll-content');
                if (scroll) {
                  scroll.scrollTop = 0;
                }
              }, 0, false);
            }
            return $location.__hash(value);
          };
          return $location;
        }
        $provide.decorator('$location', ['$delegate', '$timeout', $LocationDecorator]);
      }]);
      IonicModule.controller('$ionicHeaderBar', ['$scope', '$element', '$attrs', '$q', '$ionicConfig', '$ionicHistory', function($scope, $element, $attrs, $q, $ionicConfig, $ionicHistory) {
        var TITLE = 'title';
        var BACK_TEXT = 'back-text';
        var BACK_BUTTON = 'back-button';
        var DEFAULT_TITLE = 'default-title';
        var PREVIOUS_TITLE = 'previous-title';
        var HIDE = 'hide';
        var self = this;
        var titleText = '';
        var previousTitleText = '';
        var titleLeft = 0;
        var titleRight = 0;
        var titleCss = '';
        var isBackEnabled = false;
        var isBackShown = true;
        var isNavBackShown = true;
        var isBackElementShown = false;
        var titleTextWidth = 0;
        self.beforeEnter = function(viewData) {
          $scope.$broadcast('$ionicView.beforeEnter', viewData);
        };
        self.title = function(newTitleText) {
          if (arguments.length && newTitleText !== titleText) {
            getEle(TITLE).innerHTML = newTitleText;
            titleText = newTitleText;
            titleTextWidth = 0;
          }
          return titleText;
        };
        self.enableBack = function(shouldEnable, disableReset) {
          if (arguments.length) {
            isBackEnabled = shouldEnable;
            if (!disableReset)
              self.updateBackButton();
          }
          return isBackEnabled;
        };
        self.showBack = function(shouldShow, disableReset) {
          if (arguments.length) {
            isBackShown = shouldShow;
            if (!disableReset)
              self.updateBackButton();
          }
          return isBackShown;
        };
        self.showNavBack = function(shouldShow) {
          isNavBackShown = shouldShow;
          self.updateBackButton();
        };
        self.updateBackButton = function() {
          var ele;
          if ((isBackShown && isNavBackShown && isBackEnabled) !== isBackElementShown) {
            isBackElementShown = isBackShown && isNavBackShown && isBackEnabled;
            ele = getEle(BACK_BUTTON);
            ele && ele.classList[isBackElementShown ? 'remove' : 'add'](HIDE);
          }
          if (isBackEnabled) {
            ele = ele || getEle(BACK_BUTTON);
            if (ele) {
              if (self.backButtonIcon !== $ionicConfig.backButton.icon()) {
                ele = getEle(BACK_BUTTON + ' .icon');
                if (ele) {
                  self.backButtonIcon = $ionicConfig.backButton.icon();
                  ele.className = 'icon ' + self.backButtonIcon;
                }
              }
              if (self.backButtonText !== $ionicConfig.backButton.text()) {
                ele = getEle(BACK_BUTTON + ' .back-text');
                if (ele) {
                  ele.textContent = self.backButtonText = $ionicConfig.backButton.text();
                }
              }
            }
          }
        };
        self.titleTextWidth = function() {
          if (!titleTextWidth) {
            var bounds = ionic.DomUtil.getTextBounds(getEle(TITLE));
            titleTextWidth = Math.min(bounds && bounds.width || 30);
          }
          return titleTextWidth;
        };
        self.titleWidth = function() {
          var titleWidth = self.titleTextWidth();
          var offsetWidth = getEle(TITLE).offsetWidth;
          if (offsetWidth < titleWidth) {
            titleWidth = offsetWidth + (titleLeft - titleRight - 5);
          }
          return titleWidth;
        };
        self.titleTextX = function() {
          return ($element[0].offsetWidth / 2) - (self.titleWidth() / 2);
        };
        self.titleLeftRight = function() {
          return titleLeft - titleRight;
        };
        self.backButtonTextLeft = function() {
          var offsetLeft = 0;
          var ele = getEle(BACK_TEXT);
          while (ele) {
            offsetLeft += ele.offsetLeft;
            ele = ele.parentElement;
          }
          return offsetLeft;
        };
        self.resetBackButton = function(viewData) {
          if ($ionicConfig.backButton.previousTitleText()) {
            var previousTitleEle = getEle(PREVIOUS_TITLE);
            if (previousTitleEle) {
              previousTitleEle.classList.remove(HIDE);
              var view = (viewData && $ionicHistory.getViewById(viewData.viewId));
              var newPreviousTitleText = $ionicHistory.backTitle(view);
              if (newPreviousTitleText !== previousTitleText) {
                previousTitleText = previousTitleEle.innerHTML = newPreviousTitleText;
              }
            }
            var defaultTitleEle = getEle(DEFAULT_TITLE);
            if (defaultTitleEle) {
              defaultTitleEle.classList.remove(HIDE);
            }
          }
        };
        self.align = function(textAlign) {
          var titleEle = getEle(TITLE);
          textAlign = textAlign || $attrs.alignTitle || $ionicConfig.navBar.alignTitle();
          var widths = self.calcWidths(textAlign, false);
          if (isBackShown && previousTitleText && $ionicConfig.backButton.previousTitleText()) {
            var previousTitleWidths = self.calcWidths(textAlign, true);
            var availableTitleWidth = $element[0].offsetWidth - previousTitleWidths.titleLeft - previousTitleWidths.titleRight;
            if (self.titleTextWidth() <= availableTitleWidth) {
              widths = previousTitleWidths;
            }
          }
          return self.updatePositions(titleEle, widths.titleLeft, widths.titleRight, widths.buttonsLeft, widths.buttonsRight, widths.css, widths.showPrevTitle);
        };
        self.calcWidths = function(textAlign, isPreviousTitle) {
          var titleEle = getEle(TITLE);
          var backBtnEle = getEle(BACK_BUTTON);
          var x,
              y,
              z,
              b,
              c,
              d,
              childSize,
              bounds;
          var childNodes = $element[0].childNodes;
          var buttonsLeft = 0;
          var buttonsRight = 0;
          var isCountRightOfTitle;
          var updateTitleLeft = 0;
          var updateTitleRight = 0;
          var updateCss = '';
          var backButtonWidth = 0;
          for (x = 0; x < childNodes.length; x++) {
            c = childNodes[x];
            childSize = 0;
            if (c.nodeType == 1) {
              if (c === titleEle) {
                isCountRightOfTitle = true;
                continue;
              }
              if (c.classList.contains(HIDE)) {
                continue;
              }
              if (isBackShown && c === backBtnEle) {
                for (y = 0; y < c.childNodes.length; y++) {
                  b = c.childNodes[y];
                  if (b.nodeType == 1) {
                    if (b.classList.contains(BACK_TEXT)) {
                      for (z = 0; z < b.children.length; z++) {
                        d = b.children[z];
                        if (isPreviousTitle) {
                          if (d.classList.contains(DEFAULT_TITLE))
                            continue;
                          backButtonWidth += d.offsetWidth;
                        } else {
                          if (d.classList.contains(PREVIOUS_TITLE))
                            continue;
                          backButtonWidth += d.offsetWidth;
                        }
                      }
                    } else {
                      backButtonWidth += b.offsetWidth;
                    }
                  } else if (b.nodeType == 3 && b.nodeValue.trim()) {
                    bounds = ionic.DomUtil.getTextBounds(b);
                    backButtonWidth += bounds && bounds.width || 0;
                  }
                }
                childSize = backButtonWidth || c.offsetWidth;
              } else {
                childSize = c.offsetWidth;
              }
            } else if (c.nodeType == 3 && c.nodeValue.trim()) {
              bounds = ionic.DomUtil.getTextBounds(c);
              childSize = bounds && bounds.width || 0;
            }
            if (isCountRightOfTitle) {
              buttonsRight += childSize;
            } else {
              buttonsLeft += childSize;
            }
          }
          if (textAlign == 'left') {
            updateCss = 'title-left';
            if (buttonsLeft) {
              updateTitleLeft = buttonsLeft + 15;
            }
            if (buttonsRight) {
              updateTitleRight = buttonsRight + 15;
            }
          } else if (textAlign == 'right') {
            updateCss = 'title-right';
            if (buttonsLeft) {
              updateTitleLeft = buttonsLeft + 15;
            }
            if (buttonsRight) {
              updateTitleRight = buttonsRight + 15;
            }
          } else {
            var margin = Math.max(buttonsLeft, buttonsRight) + 10;
            if (margin > 10) {
              updateTitleLeft = updateTitleRight = margin;
            }
          }
          return {
            backButtonWidth: backButtonWidth,
            buttonsLeft: buttonsLeft,
            buttonsRight: buttonsRight,
            titleLeft: updateTitleLeft,
            titleRight: updateTitleRight,
            showPrevTitle: isPreviousTitle,
            css: updateCss
          };
        };
        self.updatePositions = function(titleEle, updateTitleLeft, updateTitleRight, buttonsLeft, buttonsRight, updateCss, showPreviousTitle) {
          var deferred = $q.defer();
          if (titleEle) {
            if (updateTitleLeft !== titleLeft) {
              titleEle.style.left = updateTitleLeft ? updateTitleLeft + 'px' : '';
              titleLeft = updateTitleLeft;
            }
            if (updateTitleRight !== titleRight) {
              titleEle.style.right = updateTitleRight ? updateTitleRight + 'px' : '';
              titleRight = updateTitleRight;
            }
            if (updateCss !== titleCss) {
              updateCss && titleEle.classList.add(updateCss);
              titleCss && titleEle.classList.remove(titleCss);
              titleCss = updateCss;
            }
          }
          if ($ionicConfig.backButton.previousTitleText()) {
            var prevTitle = getEle(PREVIOUS_TITLE);
            var defaultTitle = getEle(DEFAULT_TITLE);
            prevTitle && prevTitle.classList[showPreviousTitle ? 'remove' : 'add'](HIDE);
            defaultTitle && defaultTitle.classList[showPreviousTitle ? 'add' : 'remove'](HIDE);
          }
          ionic.requestAnimationFrame(function() {
            if (titleEle && titleEle.offsetWidth + 10 < titleEle.scrollWidth) {
              var minRight = buttonsRight + 5;
              var testRight = $element[0].offsetWidth - titleLeft - self.titleTextWidth() - 20;
              updateTitleRight = testRight < minRight ? minRight : testRight;
              if (updateTitleRight !== titleRight) {
                titleEle.style.right = updateTitleRight + 'px';
                titleRight = updateTitleRight;
              }
            }
            deferred.resolve();
          });
          return deferred.promise;
        };
        self.setCss = function(elementClassname, css) {
          ionic.DomUtil.cachedStyles(getEle(elementClassname), css);
        };
        var eleCache = {};
        function getEle(className) {
          if (!eleCache[className]) {
            eleCache[className] = $element[0].querySelector('.' + className);
          }
          return eleCache[className];
        }
        $scope.$on('$destroy', function() {
          for (var n in eleCache)
            eleCache[n] = null;
        });
      }]);
      IonicModule.controller('$ionInfiniteScroll', ['$scope', '$attrs', '$element', '$timeout', function($scope, $attrs, $element, $timeout) {
        var self = this;
        self.isLoading = false;
        $scope.icon = function() {
          return isDefined($attrs.icon) ? $attrs.icon : 'ion-load-d';
        };
        $scope.spinner = function() {
          return isDefined($attrs.spinner) ? $attrs.spinner : '';
        };
        $scope.$on('scroll.infiniteScrollComplete', function() {
          finishInfiniteScroll();
        });
        $scope.$on('$destroy', function() {
          if (self.scrollCtrl && self.scrollCtrl.$element)
            self.scrollCtrl.$element.off('scroll', self.checkBounds);
          if (self.scrollEl && self.scrollEl.removeEventListener) {
            self.scrollEl.removeEventListener('scroll', self.checkBounds);
          }
        });
        self.checkBounds = ionic.Utils.throttle(checkInfiniteBounds, 300);
        function onInfinite() {
          ionic.requestAnimationFrame(function() {
            $element[0].classList.add('active');
          });
          self.isLoading = true;
          $scope.$parent && $scope.$parent.$apply($attrs.onInfinite || '');
        }
        function finishInfiniteScroll() {
          ionic.requestAnimationFrame(function() {
            $element[0].classList.remove('active');
          });
          $timeout(function() {
            if (self.jsScrolling)
              self.scrollView.resize();
            if ((self.jsScrolling && self.scrollView.__container && self.scrollView.__container.offsetHeight > 0) || !self.jsScrolling) {
              self.checkBounds();
            }
          }, 30, false);
          self.isLoading = false;
        }
        function checkInfiniteBounds() {
          if (self.isLoading)
            return ;
          var maxScroll = {};
          if (self.jsScrolling) {
            maxScroll = self.getJSMaxScroll();
            var scrollValues = self.scrollView.getValues();
            if ((maxScroll.left !== -1 && scrollValues.left >= maxScroll.left) || (maxScroll.top !== -1 && scrollValues.top >= maxScroll.top)) {
              onInfinite();
            }
          } else {
            maxScroll = self.getNativeMaxScroll();
            if ((maxScroll.left !== -1 && self.scrollEl.scrollLeft >= maxScroll.left - self.scrollEl.clientWidth) || (maxScroll.top !== -1 && self.scrollEl.scrollTop >= maxScroll.top - self.scrollEl.clientHeight)) {
              onInfinite();
            }
          }
        }
        self.getJSMaxScroll = function() {
          var maxValues = self.scrollView.getScrollMax();
          return {
            left: self.scrollView.options.scrollingX ? calculateMaxValue(maxValues.left) : -1,
            top: self.scrollView.options.scrollingY ? calculateMaxValue(maxValues.top) : -1
          };
        };
        self.getNativeMaxScroll = function() {
          var maxValues = {
            left: self.scrollEl.scrollWidth,
            top: self.scrollEl.scrollHeight
          };
          var computedStyle = window.getComputedStyle(self.scrollEl) || {};
          return {
            left: computedStyle.overflowX === 'scroll' || computedStyle.overflowX === 'auto' || self.scrollEl.style['overflow-x'] === 'scroll' ? calculateMaxValue(maxValues.left) : -1,
            top: computedStyle.overflowY === 'scroll' || computedStyle.overflowY === 'auto' || self.scrollEl.style['overflow-y'] === 'scroll' ? calculateMaxValue(maxValues.top) : -1
          };
        };
        function calculateMaxValue(maximum) {
          var distance = ($attrs.distance || '2.5%').trim();
          var isPercent = distance.indexOf('%') !== -1;
          return isPercent ? maximum * (1 - parseFloat(distance) / 100) : maximum - parseFloat(distance);
        }
        self.__finishInfiniteScroll = finishInfiniteScroll;
      }]);
      IonicModule.service('$ionicListDelegate', ionic.DelegateService(['showReorder', 'showDelete', 'canSwipeItems', 'closeOptionButtons'])).controller('$ionicList', ['$scope', '$attrs', '$ionicListDelegate', '$ionicHistory', function($scope, $attrs, $ionicListDelegate, $ionicHistory) {
        var self = this;
        var isSwipeable = true;
        var isReorderShown = false;
        var isDeleteShown = false;
        var deregisterInstance = $ionicListDelegate._registerInstance(self, $attrs.delegateHandle, function() {
          return $ionicHistory.isActiveScope($scope);
        });
        $scope.$on('$destroy', deregisterInstance);
        self.showReorder = function(show) {
          if (arguments.length) {
            isReorderShown = !!show;
          }
          return isReorderShown;
        };
        self.showDelete = function(show) {
          if (arguments.length) {
            isDeleteShown = !!show;
          }
          return isDeleteShown;
        };
        self.canSwipeItems = function(can) {
          if (arguments.length) {
            isSwipeable = !!can;
          }
          return isSwipeable;
        };
        self.closeOptionButtons = function() {
          self.listView && self.listView.clearDragEffects();
        };
      }]);
      IonicModule.controller('$ionicNavBar', ['$scope', '$element', '$attrs', '$compile', '$timeout', '$ionicNavBarDelegate', '$ionicConfig', '$ionicHistory', function($scope, $element, $attrs, $compile, $timeout, $ionicNavBarDelegate, $ionicConfig, $ionicHistory) {
        var CSS_HIDE = 'hide';
        var DATA_NAV_BAR_CTRL = '$ionNavBarController';
        var PRIMARY_BUTTONS = 'primaryButtons';
        var SECONDARY_BUTTONS = 'secondaryButtons';
        var BACK_BUTTON = 'backButton';
        var ITEM_TYPES = 'primaryButtons secondaryButtons leftButtons rightButtons title'.split(' ');
        var self = this;
        var headerBars = [];
        var navElementHtml = {};
        var isVisible = true;
        var queuedTransitionStart,
            queuedTransitionEnd,
            latestTransitionId;
        $element.parent().data(DATA_NAV_BAR_CTRL, self);
        var delegateHandle = $attrs.delegateHandle || 'navBar' + ionic.Utils.nextUid();
        var deregisterInstance = $ionicNavBarDelegate._registerInstance(self, delegateHandle);
        self.init = function() {
          $element.addClass('nav-bar-container');
          ionic.DomUtil.cachedAttr($element, 'nav-bar-transition', $ionicConfig.views.transition());
          self.createHeaderBar(false);
          self.createHeaderBar(true);
          $scope.$emit('ionNavBar.init', delegateHandle);
        };
        self.createHeaderBar = function(isActive) {
          var containerEle = jqLite('<div class="nav-bar-block">');
          ionic.DomUtil.cachedAttr(containerEle, 'nav-bar', isActive ? 'active' : 'cached');
          var alignTitle = $attrs.alignTitle || $ionicConfig.navBar.alignTitle();
          var headerBarEle = jqLite('<ion-header-bar>').addClass($attrs['class']).attr('align-title', alignTitle);
          if (isDefined($attrs.noTapScroll))
            headerBarEle.attr('no-tap-scroll', $attrs.noTapScroll);
          var titleEle = jqLite('<div class="title title-' + alignTitle + '">');
          var navEle = {};
          var lastViewItemEle = {};
          var leftButtonsEle,
              rightButtonsEle;
          navEle[BACK_BUTTON] = createNavElement(BACK_BUTTON);
          navEle[BACK_BUTTON] && headerBarEle.append(navEle[BACK_BUTTON]);
          headerBarEle.append(titleEle);
          forEach(ITEM_TYPES, function(itemType) {
            navEle[itemType] = createNavElement(itemType);
            positionItem(navEle[itemType], itemType);
          });
          for (var x = 0; x < headerBarEle[0].children.length; x++) {
            headerBarEle[0].children[x].classList.add('header-item');
          }
          containerEle.append(headerBarEle);
          $element.append($compile(containerEle)($scope.$new()));
          var headerBarCtrl = headerBarEle.data('$ionHeaderBarController');
          headerBarCtrl.backButtonIcon = $ionicConfig.backButton.icon();
          headerBarCtrl.backButtonText = $ionicConfig.backButton.text();
          var headerBarInstance = {
            isActive: isActive,
            title: function(newTitleText) {
              headerBarCtrl.title(newTitleText);
            },
            setItem: function(navBarItemEle, itemType) {
              headerBarInstance.removeItem(itemType);
              if (navBarItemEle) {
                if (itemType === 'title') {
                  headerBarInstance.title("");
                }
                positionItem(navBarItemEle, itemType);
                if (navEle[itemType]) {
                  navEle[itemType].addClass(CSS_HIDE);
                }
                lastViewItemEle[itemType] = navBarItemEle;
              } else if (navEle[itemType]) {
                navEle[itemType].removeClass(CSS_HIDE);
              }
            },
            removeItem: function(itemType) {
              if (lastViewItemEle[itemType]) {
                lastViewItemEle[itemType].scope().$destroy();
                lastViewItemEle[itemType].remove();
                lastViewItemEle[itemType] = null;
              }
            },
            containerEle: function() {
              return containerEle;
            },
            headerBarEle: function() {
              return headerBarEle;
            },
            afterLeave: function() {
              forEach(ITEM_TYPES, function(itemType) {
                headerBarInstance.removeItem(itemType);
              });
              headerBarCtrl.resetBackButton();
            },
            controller: function() {
              return headerBarCtrl;
            },
            destroy: function() {
              forEach(ITEM_TYPES, function(itemType) {
                headerBarInstance.removeItem(itemType);
              });
              containerEle.scope().$destroy();
              for (var n in navEle) {
                if (navEle[n]) {
                  navEle[n].removeData();
                  navEle[n] = null;
                }
              }
              leftButtonsEle && leftButtonsEle.removeData();
              rightButtonsEle && rightButtonsEle.removeData();
              titleEle.removeData();
              headerBarEle.removeData();
              containerEle.remove();
              containerEle = headerBarEle = titleEle = leftButtonsEle = rightButtonsEle = null;
            }
          };
          function positionItem(ele, itemType) {
            if (!ele)
              return ;
            if (itemType === 'title') {
              titleEle.append(ele);
            } else if (itemType == 'rightButtons' || (itemType == SECONDARY_BUTTONS && $ionicConfig.navBar.positionSecondaryButtons() != 'left') || (itemType == PRIMARY_BUTTONS && $ionicConfig.navBar.positionPrimaryButtons() == 'right')) {
              if (!rightButtonsEle) {
                rightButtonsEle = jqLite('<div class="buttons buttons-right">');
                headerBarEle.append(rightButtonsEle);
              }
              if (itemType == SECONDARY_BUTTONS) {
                rightButtonsEle.append(ele);
              } else {
                rightButtonsEle.prepend(ele);
              }
            } else {
              if (!leftButtonsEle) {
                leftButtonsEle = jqLite('<div class="buttons buttons-left">');
                if (navEle[BACK_BUTTON]) {
                  navEle[BACK_BUTTON].after(leftButtonsEle);
                } else {
                  headerBarEle.prepend(leftButtonsEle);
                }
              }
              if (itemType == SECONDARY_BUTTONS) {
                leftButtonsEle.append(ele);
              } else {
                leftButtonsEle.prepend(ele);
              }
            }
          }
          headerBars.push(headerBarInstance);
          return headerBarInstance;
        };
        self.navElement = function(type, html) {
          if (isDefined(html)) {
            navElementHtml[type] = html;
          }
          return navElementHtml[type];
        };
        self.update = function(viewData) {
          var showNavBar = !viewData.hasHeaderBar && viewData.showNavBar;
          viewData.transition = $ionicConfig.views.transition();
          if (!showNavBar) {
            viewData.direction = 'none';
          }
          self.enable(showNavBar);
          var enteringHeaderBar = self.isInitialized ? getOffScreenHeaderBar() : getOnScreenHeaderBar();
          var leavingHeaderBar = self.isInitialized ? getOnScreenHeaderBar() : null;
          var enteringHeaderCtrl = enteringHeaderBar.controller();
          enteringHeaderCtrl.enableBack(viewData.enableBack, true);
          enteringHeaderCtrl.showBack(viewData.showBack, true);
          enteringHeaderCtrl.updateBackButton();
          self.title(viewData.title, enteringHeaderBar);
          self.showBar(showNavBar);
          if (viewData.navBarItems) {
            forEach(ITEM_TYPES, function(itemType) {
              enteringHeaderBar.setItem(viewData.navBarItems[itemType], itemType);
            });
          }
          self.transition(enteringHeaderBar, leavingHeaderBar, viewData);
          self.isInitialized = true;
          navSwipeAttr('');
        };
        self.transition = function(enteringHeaderBar, leavingHeaderBar, viewData) {
          var enteringHeaderBarCtrl = enteringHeaderBar.controller();
          var transitionFn = $ionicConfig.transitions.navBar[viewData.navBarTransition] || $ionicConfig.transitions.navBar.none;
          var transitionId = viewData.transitionId;
          enteringHeaderBarCtrl.beforeEnter(viewData);
          var navBarTransition = transitionFn(enteringHeaderBar, leavingHeaderBar, viewData.direction, viewData.shouldAnimate && self.isInitialized);
          ionic.DomUtil.cachedAttr($element, 'nav-bar-transition', viewData.navBarTransition);
          ionic.DomUtil.cachedAttr($element, 'nav-bar-direction', viewData.direction);
          if (navBarTransition.shouldAnimate && viewData.renderEnd) {
            navBarAttr(enteringHeaderBar, 'stage');
          } else {
            navBarAttr(enteringHeaderBar, 'entering');
            navBarAttr(leavingHeaderBar, 'leaving');
          }
          enteringHeaderBarCtrl.resetBackButton(viewData);
          navBarTransition.run(0);
          self.activeTransition = {
            run: function(step) {
              navBarTransition.shouldAnimate = false;
              navBarTransition.direction = 'back';
              navBarTransition.run(step);
            },
            cancel: function(shouldAnimate, speed, cancelData) {
              navSwipeAttr(speed);
              navBarAttr(leavingHeaderBar, 'active');
              navBarAttr(enteringHeaderBar, 'cached');
              navBarTransition.shouldAnimate = shouldAnimate;
              navBarTransition.run(0);
              self.activeTransition = navBarTransition = null;
              var runApply;
              if (cancelData.showBar !== self.showBar()) {
                self.showBar(cancelData.showBar);
              }
              if (cancelData.showBackButton !== self.showBackButton()) {
                self.showBackButton(cancelData.showBackButton);
              }
              if (runApply) {
                $scope.$apply();
              }
            },
            complete: function(shouldAnimate, speed) {
              navSwipeAttr(speed);
              navBarTransition.shouldAnimate = shouldAnimate;
              navBarTransition.run(1);
              queuedTransitionEnd = transitionEnd;
            }
          };
          $timeout(enteringHeaderBarCtrl.align, 16);
          queuedTransitionStart = function() {
            if (latestTransitionId !== transitionId)
              return ;
            navBarAttr(enteringHeaderBar, 'entering');
            navBarAttr(leavingHeaderBar, 'leaving');
            navBarTransition.run(1);
            queuedTransitionEnd = function() {
              if (latestTransitionId == transitionId || !navBarTransition.shouldAnimate) {
                transitionEnd();
              }
            };
            queuedTransitionStart = null;
          };
          function transitionEnd() {
            for (var x = 0; x < headerBars.length; x++) {
              headerBars[x].isActive = false;
            }
            enteringHeaderBar.isActive = true;
            navBarAttr(enteringHeaderBar, 'active');
            navBarAttr(leavingHeaderBar, 'cached');
            self.activeTransition = navBarTransition = queuedTransitionEnd = null;
          }
          queuedTransitionStart();
        };
        self.triggerTransitionStart = function(triggerTransitionId) {
          latestTransitionId = triggerTransitionId;
          queuedTransitionStart && queuedTransitionStart();
        };
        self.triggerTransitionEnd = function() {
          queuedTransitionEnd && queuedTransitionEnd();
        };
        self.showBar = function(shouldShow) {
          if (arguments.length) {
            self.visibleBar(shouldShow);
            $scope.$parent.$hasHeader = !!shouldShow;
          }
          return !!$scope.$parent.$hasHeader;
        };
        self.visibleBar = function(shouldShow) {
          if (shouldShow && !isVisible) {
            $element.removeClass(CSS_HIDE);
            self.align();
          } else if (!shouldShow && isVisible) {
            $element.addClass(CSS_HIDE);
          }
          isVisible = shouldShow;
        };
        self.enable = function(val) {
          self.visibleBar(val);
          for (var x = 0; x < $ionicNavBarDelegate._instances.length; x++) {
            if ($ionicNavBarDelegate._instances[x] !== self)
              $ionicNavBarDelegate._instances[x].visibleBar(false);
          }
        };
        self.showBackButton = function(shouldShow) {
          if (arguments.length) {
            for (var x = 0; x < headerBars.length; x++) {
              headerBars[x].controller().showNavBack(!!shouldShow);
            }
            $scope.$isBackButtonShown = !!shouldShow;
          }
          return $scope.$isBackButtonShown;
        };
        self.showActiveBackButton = function(shouldShow) {
          var headerBar = getOnScreenHeaderBar();
          if (headerBar) {
            if (arguments.length) {
              return headerBar.controller().showBack(shouldShow);
            }
            return headerBar.controller().showBack();
          }
        };
        self.title = function(newTitleText, headerBar) {
          if (isDefined(newTitleText)) {
            newTitleText = newTitleText || '';
            headerBar = headerBar || getOnScreenHeaderBar();
            headerBar && headerBar.title(newTitleText);
            $scope.$title = newTitleText;
            $ionicHistory.currentTitle(newTitleText);
          }
          return $scope.$title;
        };
        self.align = function(val, headerBar) {
          headerBar = headerBar || getOnScreenHeaderBar();
          headerBar && headerBar.controller().align(val);
        };
        self.hasTabsTop = function(isTabsTop) {
          $element[isTabsTop ? 'addClass' : 'removeClass']('nav-bar-tabs-top');
        };
        self.hasBarSubheader = function(isBarSubheader) {
          $element[isBarSubheader ? 'addClass' : 'removeClass']('nav-bar-has-subheader');
        };
        self.changeTitle = function(val) {
          deprecatedWarning('changeTitle(val)', 'title(val)');
          self.title(val);
        };
        self.setTitle = function(val) {
          deprecatedWarning('setTitle(val)', 'title(val)');
          self.title(val);
        };
        self.getTitle = function() {
          deprecatedWarning('getTitle()', 'title()');
          return self.title();
        };
        self.back = function() {
          deprecatedWarning('back()', '$ionicHistory.goBack()');
          $ionicHistory.goBack();
        };
        self.getPreviousTitle = function() {
          deprecatedWarning('getPreviousTitle()', '$ionicHistory.backTitle()');
          $ionicHistory.goBack();
        };
        function deprecatedWarning(oldMethod, newMethod) {
          var warn = console.warn || console.log;
          warn && warn.call(console, 'navBarController.' + oldMethod + ' is deprecated, please use ' + newMethod + ' instead');
        }
        function createNavElement(type) {
          if (navElementHtml[type]) {
            return jqLite(navElementHtml[type]);
          }
        }
        function getOnScreenHeaderBar() {
          for (var x = 0; x < headerBars.length; x++) {
            if (headerBars[x].isActive)
              return headerBars[x];
          }
        }
        function getOffScreenHeaderBar() {
          for (var x = 0; x < headerBars.length; x++) {
            if (!headerBars[x].isActive)
              return headerBars[x];
          }
        }
        function navBarAttr(ctrl, val) {
          ctrl && ionic.DomUtil.cachedAttr(ctrl.containerEle(), 'nav-bar', val);
        }
        function navSwipeAttr(val) {
          ionic.DomUtil.cachedAttr($element, 'nav-swipe', val);
        }
        $scope.$on('$destroy', function() {
          $scope.$parent.$hasHeader = false;
          $element.parent().removeData(DATA_NAV_BAR_CTRL);
          for (var x = 0; x < headerBars.length; x++) {
            headerBars[x].destroy();
          }
          $element.remove();
          $element = headerBars = null;
          deregisterInstance();
        });
      }]);
      IonicModule.controller('$ionicNavView', ['$scope', '$element', '$attrs', '$compile', '$controller', '$ionicNavBarDelegate', '$ionicNavViewDelegate', '$ionicHistory', '$ionicViewSwitcher', '$ionicConfig', '$ionicScrollDelegate', function($scope, $element, $attrs, $compile, $controller, $ionicNavBarDelegate, $ionicNavViewDelegate, $ionicHistory, $ionicViewSwitcher, $ionicConfig, $ionicScrollDelegate) {
        var DATA_ELE_IDENTIFIER = '$eleId';
        var DATA_DESTROY_ELE = '$destroyEle';
        var DATA_NO_CACHE = '$noCache';
        var VIEW_STATUS_ACTIVE = 'active';
        var VIEW_STATUS_CACHED = 'cached';
        var self = this;
        var direction;
        var isPrimary = false;
        var navBarDelegate;
        var activeEleId;
        var navViewAttr = $ionicViewSwitcher.navViewAttr;
        var disableRenderStartViewId,
            disableAnimation;
        self.scope = $scope;
        self.element = $element;
        self.init = function() {
          var navViewName = $attrs.name || '';
          var parent = $element.parent().inheritedData('$uiView');
          var parentViewName = ((parent && parent.state) ? parent.state.name : '');
          if (navViewName.indexOf('@') < 0)
            navViewName = navViewName + '@' + parentViewName;
          var viewData = {
            name: navViewName,
            state: null
          };
          $element.data('$uiView', viewData);
          var deregisterInstance = $ionicNavViewDelegate._registerInstance(self, $attrs.delegateHandle);
          $scope.$on('$destroy', function() {
            deregisterInstance();
            if (self.isSwipeFreeze) {
              $ionicScrollDelegate.freezeAllScrolls(false);
            }
          });
          $scope.$on('$ionicHistory.deselect', self.cacheCleanup);
          $scope.$on('$ionicTabs.top', onTabsTop);
          $scope.$on('$ionicSubheader', onBarSubheader);
          $scope.$on('$ionicTabs.beforeLeave', onTabsLeave);
          $scope.$on('$ionicTabs.afterLeave', onTabsLeave);
          $scope.$on('$ionicTabs.leave', onTabsLeave);
          ionic.Platform.ready(function() {
            if (ionic.Platform.isWebView() && $ionicConfig.views.swipeBackEnabled()) {
              self.initSwipeBack();
            }
          });
          return viewData;
        };
        self.register = function(viewLocals) {
          var leavingView = extend({}, $ionicHistory.currentView());
          var registerData = $ionicHistory.register($scope, viewLocals);
          self.update(registerData);
          var enteringView = $ionicHistory.getViewById(registerData.viewId) || {};
          var renderStart = (disableRenderStartViewId !== registerData.viewId);
          self.render(registerData, viewLocals, enteringView, leavingView, renderStart, true);
        };
        self.update = function(registerData) {
          isPrimary = true;
          direction = registerData.direction;
          var parentNavViewCtrl = $element.parent().inheritedData('$ionNavViewController');
          if (parentNavViewCtrl) {
            parentNavViewCtrl.isPrimary(false);
            if (direction === 'enter' || direction === 'exit') {
              parentNavViewCtrl.direction(direction);
              if (direction === 'enter') {
                direction = 'none';
              }
            }
          }
        };
        self.render = function(registerData, viewLocals, enteringView, leavingView, renderStart, renderEnd) {
          var switcher = $ionicViewSwitcher.create(self, viewLocals, enteringView, leavingView, renderStart, renderEnd);
          switcher.init(registerData, function() {
            switcher.transition(self.direction(), registerData.enableBack, !disableAnimation);
            disableRenderStartViewId = disableAnimation = null;
          });
        };
        self.beforeEnter = function(transitionData) {
          if (isPrimary) {
            navBarDelegate = transitionData.navBarDelegate;
            var associatedNavBarCtrl = getAssociatedNavBarCtrl();
            associatedNavBarCtrl && associatedNavBarCtrl.update(transitionData);
            navSwipeAttr('');
          }
        };
        self.activeEleId = function(eleId) {
          if (arguments.length) {
            activeEleId = eleId;
          }
          return activeEleId;
        };
        self.transitionEnd = function() {
          var viewElements = $element.children();
          var x,
              l,
              viewElement;
          for (x = 0, l = viewElements.length; x < l; x++) {
            viewElement = viewElements.eq(x);
            if (viewElement.data(DATA_ELE_IDENTIFIER) === activeEleId) {
              navViewAttr(viewElement, VIEW_STATUS_ACTIVE);
            } else if (navViewAttr(viewElement) === 'leaving' || navViewAttr(viewElement) === VIEW_STATUS_ACTIVE || navViewAttr(viewElement) === VIEW_STATUS_CACHED) {
              if (viewElement.data(DATA_DESTROY_ELE) || viewElement.data(DATA_NO_CACHE)) {
                $ionicViewSwitcher.destroyViewEle(viewElement);
              } else {
                navViewAttr(viewElement, VIEW_STATUS_CACHED);
                ionic.Utils.disconnectScope(viewElement.scope());
              }
            }
          }
          navSwipeAttr('');
          if (self.isSwipeFreeze) {
            $ionicScrollDelegate.freezeAllScrolls(false);
          }
        };
        function onTabsLeave(ev, data) {
          var viewElements = $element.children();
          var viewElement,
              viewScope;
          for (var x = 0,
              l = viewElements.length; x < l; x++) {
            viewElement = viewElements.eq(x);
            if (navViewAttr(viewElement) == VIEW_STATUS_ACTIVE) {
              viewScope = viewElement.scope();
              viewScope && viewScope.$emit(ev.name.replace('Tabs', 'View'), data);
              break;
            }
          }
        }
        self.cacheCleanup = function() {
          var viewElements = $element.children();
          for (var x = 0,
              l = viewElements.length; x < l; x++) {
            if (viewElements.eq(x).data(DATA_DESTROY_ELE)) {
              $ionicViewSwitcher.destroyViewEle(viewElements.eq(x));
            }
          }
        };
        self.clearCache = function(stateIds) {
          var viewElements = $element.children();
          var viewElement,
              viewScope,
              x,
              l,
              y,
              eleIdentifier;
          for (x = 0, l = viewElements.length; x < l; x++) {
            viewElement = viewElements.eq(x);
            if (stateIds) {
              eleIdentifier = viewElement.data(DATA_ELE_IDENTIFIER);
              for (y = 0; y < stateIds.length; y++) {
                if (eleIdentifier === stateIds[y]) {
                  $ionicViewSwitcher.destroyViewEle(viewElement);
                }
              }
              continue;
            }
            if (navViewAttr(viewElement) == VIEW_STATUS_CACHED) {
              $ionicViewSwitcher.destroyViewEle(viewElement);
            } else if (navViewAttr(viewElement) == VIEW_STATUS_ACTIVE) {
              viewScope = viewElement.scope();
              viewScope && viewScope.$broadcast('$ionicView.clearCache');
            }
          }
        };
        self.getViewElements = function() {
          return $element.children();
        };
        self.appendViewElement = function(viewEle, viewLocals) {
          var linkFn = $compile(viewEle);
          $element.append(viewEle);
          var viewScope = $scope.$new();
          if (viewLocals && viewLocals.$$controller) {
            viewLocals.$scope = viewScope;
            var controller = $controller(viewLocals.$$controller, viewLocals);
            $element.children().data('$ngControllerController', controller);
          }
          linkFn(viewScope);
          return viewScope;
        };
        self.title = function(val) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          associatedNavBarCtrl && associatedNavBarCtrl.title(val);
        };
        self.enableBackButton = function(shouldEnable) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          associatedNavBarCtrl && associatedNavBarCtrl.enableBackButton(shouldEnable);
        };
        self.showBackButton = function(shouldShow) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          if (associatedNavBarCtrl) {
            if (arguments.length) {
              return associatedNavBarCtrl.showActiveBackButton(shouldShow);
            }
            return associatedNavBarCtrl.showActiveBackButton();
          }
          return true;
        };
        self.showBar = function(val) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          if (associatedNavBarCtrl) {
            if (arguments.length) {
              return associatedNavBarCtrl.showBar(val);
            }
            return associatedNavBarCtrl.showBar();
          }
          return true;
        };
        self.isPrimary = function(val) {
          if (arguments.length) {
            isPrimary = val;
          }
          return isPrimary;
        };
        self.direction = function(val) {
          if (arguments.length) {
            direction = val;
          }
          return direction;
        };
        self.initSwipeBack = function() {
          var swipeBackHitWidth = $ionicConfig.views.swipeBackHitWidth();
          var viewTransition,
              associatedNavBarCtrl,
              backView;
          var deregDragStart,
              deregDrag,
              deregRelease;
          var windowWidth,
              startDragX,
              dragPoints;
          var cancelData = {};
          function onDragStart(ev) {
            if (!isPrimary)
              return ;
            startDragX = getDragX(ev);
            if (startDragX > swipeBackHitWidth)
              return ;
            backView = $ionicHistory.backView();
            var currentView = $ionicHistory.currentView();
            if (!backView || backView.historyId !== currentView.historyId || currentView.canSwipeBack === false)
              return ;
            if (!windowWidth)
              windowWidth = window.innerWidth;
            self.isSwipeFreeze = $ionicScrollDelegate.freezeAllScrolls(true);
            var registerData = {direction: 'back'};
            dragPoints = [];
            cancelData = {
              showBar: self.showBar(),
              showBackButton: self.showBackButton()
            };
            var switcher = $ionicViewSwitcher.create(self, registerData, backView, currentView, true, false);
            switcher.loadViewElements(registerData);
            switcher.render(registerData);
            viewTransition = switcher.transition('back', $ionicHistory.enabledBack(backView), true);
            associatedNavBarCtrl = getAssociatedNavBarCtrl();
            deregDrag = ionic.onGesture('drag', onDrag, $element[0]);
            deregRelease = ionic.onGesture('release', onRelease, $element[0]);
          }
          function onDrag(ev) {
            if (isPrimary && viewTransition) {
              var dragX = getDragX(ev);
              dragPoints.push({
                t: Date.now(),
                x: dragX
              });
              if (dragX >= windowWidth - 15) {
                onRelease(ev);
              } else {
                var step = Math.min(Math.max(getSwipeCompletion(dragX), 0), 1);
                viewTransition.run(step);
                associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.run(step);
              }
            }
          }
          function onRelease(ev) {
            if (isPrimary && viewTransition && dragPoints && dragPoints.length > 1) {
              var now = Date.now();
              var releaseX = getDragX(ev);
              var startDrag = dragPoints[dragPoints.length - 1];
              for (var x = dragPoints.length - 2; x >= 0; x--) {
                if (now - startDrag.t > 200) {
                  break;
                }
                startDrag = dragPoints[x];
              }
              var isSwipingRight = (releaseX >= dragPoints[dragPoints.length - 2].x);
              var releaseSwipeCompletion = getSwipeCompletion(releaseX);
              var velocity = Math.abs(startDrag.x - releaseX) / (now - startDrag.t);
              disableRenderStartViewId = backView.viewId;
              disableAnimation = (releaseSwipeCompletion < 0.03 || releaseSwipeCompletion > 0.97);
              if (isSwipingRight && (releaseSwipeCompletion > 0.5 || velocity > 0.1)) {
                var speed = (velocity > 0.5 || velocity < 0.05 || releaseX > windowWidth - 45) ? 'fast' : 'slow';
                navSwipeAttr(disableAnimation ? '' : speed);
                backView.go();
                associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.complete(!disableAnimation, speed);
              } else {
                navSwipeAttr(disableAnimation ? '' : 'fast');
                disableRenderStartViewId = null;
                viewTransition.cancel(!disableAnimation);
                associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.cancel(!disableAnimation, 'fast', cancelData);
                disableAnimation = null;
              }
            }
            ionic.offGesture(deregDrag, 'drag', onDrag);
            ionic.offGesture(deregRelease, 'release', onRelease);
            windowWidth = viewTransition = dragPoints = null;
            self.isSwipeFreeze = $ionicScrollDelegate.freezeAllScrolls(false);
          }
          function getDragX(ev) {
            return ionic.tap.pointerCoord(ev.gesture.srcEvent).x;
          }
          function getSwipeCompletion(dragX) {
            return (dragX - startDragX) / windowWidth;
          }
          deregDragStart = ionic.onGesture('dragstart', onDragStart, $element[0]);
          $scope.$on('$destroy', function() {
            ionic.offGesture(deregDragStart, 'dragstart', onDragStart);
            ionic.offGesture(deregDrag, 'drag', onDrag);
            ionic.offGesture(deregRelease, 'release', onRelease);
            self.element = viewTransition = associatedNavBarCtrl = null;
          });
        };
        function navSwipeAttr(val) {
          ionic.DomUtil.cachedAttr($element, 'nav-swipe', val);
        }
        function onTabsTop(ev, isTabsTop) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          associatedNavBarCtrl && associatedNavBarCtrl.hasTabsTop(isTabsTop);
        }
        function onBarSubheader(ev, isBarSubheader) {
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          associatedNavBarCtrl && associatedNavBarCtrl.hasBarSubheader(isBarSubheader);
        }
        function getAssociatedNavBarCtrl() {
          if (navBarDelegate) {
            for (var x = 0; x < $ionicNavBarDelegate._instances.length; x++) {
              if ($ionicNavBarDelegate._instances[x].$$delegateHandle == navBarDelegate) {
                return $ionicNavBarDelegate._instances[x];
              }
            }
          }
          return $element.inheritedData('$ionNavBarController');
        }
      }]);
      IonicModule.controller('$ionicRefresher', ['$scope', '$attrs', '$element', '$ionicBind', '$timeout', function($scope, $attrs, $element, $ionicBind, $timeout) {
        var self = this,
            isDragging = false,
            isOverscrolling = false,
            dragOffset = 0,
            lastOverscroll = 0,
            ptrThreshold = 60,
            activated = false,
            scrollTime = 500,
            startY = null,
            deltaY = null,
            canOverscroll = true,
            scrollParent,
            scrollChild;
        if (!isDefined($attrs.pullingIcon)) {
          $attrs.$set('pullingIcon', 'ion-android-arrow-down');
        }
        $scope.showSpinner = !isDefined($attrs.refreshingIcon) && $attrs.spinner != 'none';
        $scope.showIcon = isDefined($attrs.refreshingIcon);
        $ionicBind($scope, $attrs, {
          pullingIcon: '@',
          pullingText: '@',
          refreshingIcon: '@',
          refreshingText: '@',
          spinner: '@',
          disablePullingRotation: '@',
          $onRefresh: '&onRefresh',
          $onPulling: '&onPulling'
        });
        function handleTouchend() {
          if (!canOverscroll && !isDragging) {
            return ;
          }
          startY = null;
          if (!isDragging) {
            dragOffset = 0;
            isOverscrolling = false;
            setScrollLock(false);
          } else {
            isDragging = false;
            dragOffset = 0;
            if (lastOverscroll > ptrThreshold) {
              start();
              scrollTo(ptrThreshold, scrollTime);
            } else {
              scrollTo(0, scrollTime, deactivate);
              isOverscrolling = false;
            }
          }
        }
        function handleTouchmove(e) {
          if (!canOverscroll || e.touches.length > 1) {
            return ;
          }
          if (startY === null) {
            startY = parseInt(e.touches[0].screenY, 10);
          }
          if (ionic.Platform.isAndroid() && ionic.Platform.version() === 4.4 && scrollParent.scrollTop === 0) {
            isDragging = true;
            e.preventDefault();
          }
          deltaY = parseInt(e.touches[0].screenY, 10) - startY;
          if (deltaY - dragOffset <= 0 || scrollParent.scrollTop !== 0) {
            if (isOverscrolling) {
              isOverscrolling = false;
              setScrollLock(false);
            }
            if (isDragging) {
              nativescroll(scrollParent, parseInt(deltaY - dragOffset, 10) * -1);
            }
            if (lastOverscroll !== 0) {
              overscroll(0);
            }
            return ;
          } else if (deltaY > 0 && scrollParent.scrollTop === 0 && !isOverscrolling) {
            dragOffset = deltaY;
          }
          e.preventDefault();
          if (!isOverscrolling) {
            isOverscrolling = true;
            setScrollLock(true);
          }
          isDragging = true;
          overscroll(parseInt((deltaY - dragOffset) / 3, 10));
          if (!activated && lastOverscroll > ptrThreshold) {
            activated = true;
            ionic.requestAnimationFrame(activate);
          } else if (activated && lastOverscroll < ptrThreshold) {
            activated = false;
            ionic.requestAnimationFrame(deactivate);
          }
        }
        function handleScroll(e) {
          canOverscroll = (e.target.scrollTop === 0) || isDragging;
        }
        function overscroll(val) {
          scrollChild.style[ionic.CSS.TRANSFORM] = 'translateY(' + val + 'px)';
          lastOverscroll = val;
        }
        function nativescroll(target, newScrollTop) {
          target.scrollTop = newScrollTop;
          var e = document.createEvent("UIEvents");
          e.initUIEvent("scroll", true, true, window, 1);
          target.dispatchEvent(e);
        }
        function setScrollLock(enabled) {
          if (enabled) {
            ionic.requestAnimationFrame(function() {
              scrollChild.classList.add('overscroll');
              show();
            });
          } else {
            ionic.requestAnimationFrame(function() {
              scrollChild.classList.remove('overscroll');
              hide();
              deactivate();
            });
          }
        }
        $scope.$on('scroll.refreshComplete', function() {
          $timeout(function() {
            ionic.requestAnimationFrame(tail);
            scrollTo(0, scrollTime, deactivate);
            $timeout(function() {
              if (isOverscrolling) {
                isOverscrolling = false;
                setScrollLock(false);
              }
            }, scrollTime);
          }, scrollTime);
        });
        function scrollTo(Y, duration, callback) {
          var start = Date.now(),
              from = lastOverscroll;
          if (from === Y) {
            callback();
            return ;
          }
          function easeOutCubic(t) {
            return (--t) * t * t + 1;
          }
          function scroll() {
            var currentTime = Date.now(),
                time = Math.min(1, ((currentTime - start) / duration)),
                easedT = easeOutCubic(time);
            overscroll(parseInt((easedT * (Y - from)) + from, 10));
            if (time < 1) {
              ionic.requestAnimationFrame(scroll);
            } else {
              if (Y < 5 && Y > -5) {
                isOverscrolling = false;
                setScrollLock(false);
              }
              callback && callback();
            }
          }
          ionic.requestAnimationFrame(scroll);
        }
        self.init = function() {
          scrollParent = $element.parent().parent()[0];
          scrollChild = $element.parent()[0];
          if (!scrollParent || !scrollParent.classList.contains('ionic-scroll') || !scrollChild || !scrollChild.classList.contains('scroll')) {
            throw new Error('Refresher must be immediate child of ion-content or ion-scroll');
          }
          ionic.on('touchmove', handleTouchmove, scrollChild);
          ionic.on('touchend', handleTouchend, scrollChild);
          ionic.on('scroll', handleScroll, scrollParent);
          $scope.$on('$destroy', destroy);
        };
        function destroy() {
          ionic.off('touchmove', handleTouchmove, scrollChild);
          ionic.off('touchend', handleTouchend, scrollChild);
          ionic.off('scroll', handleScroll, scrollParent);
          scrollParent = null;
          scrollChild = null;
        }
        self.getRefresherDomMethods = function() {
          return {
            activate: activate,
            deactivate: deactivate,
            start: start,
            show: show,
            hide: hide,
            tail: tail
          };
        };
        function activate() {
          $element[0].classList.add('active');
          $scope.$onPulling();
        }
        function deactivate() {
          $timeout(function() {
            $element.removeClass('active refreshing refreshing-tail');
            if (activated)
              activated = false;
          }, 150);
        }
        function start() {
          $element[0].classList.add('refreshing');
          $scope.$onRefresh();
        }
        function show() {
          $element[0].classList.remove('invisible');
        }
        function hide() {
          $element[0].classList.add('invisible');
        }
        function tail() {
          $element[0].classList.add('refreshing-tail');
        }
        self.__handleTouchmove = handleTouchmove;
        self.__getScrollChild = function() {
          return scrollChild;
        };
        self.__getScrollParent = function() {
          return scrollParent;
        };
      }]);
      IonicModule.controller('$ionicScroll', ['$scope', 'scrollViewOptions', '$timeout', '$window', '$location', '$document', '$ionicScrollDelegate', '$ionicHistory', function($scope, scrollViewOptions, $timeout, $window, $location, $document, $ionicScrollDelegate, $ionicHistory) {
        var self = this;
        self.__timeout = $timeout;
        self._scrollViewOptions = scrollViewOptions;
        self.isNative = function() {
          return !!scrollViewOptions.nativeScrolling;
        };
        var element = self.element = scrollViewOptions.el;
        var $element = self.$element = jqLite(element);
        var scrollView;
        if (self.isNative()) {
          scrollView = self.scrollView = new ionic.views.ScrollNative(scrollViewOptions);
        } else {
          scrollView = self.scrollView = new ionic.views.Scroll(scrollViewOptions);
        }
        ($element.parent().length ? $element.parent() : $element).data('$$ionicScrollController', self);
        var deregisterInstance = $ionicScrollDelegate._registerInstance(self, scrollViewOptions.delegateHandle, function() {
          return $ionicHistory.isActiveScope($scope);
        });
        if (!isDefined(scrollViewOptions.bouncing)) {
          ionic.Platform.ready(function() {
            if (scrollView.options) {
              scrollView.options.bouncing = true;
              if (ionic.Platform.isAndroid()) {
                scrollView.options.bouncing = false;
                scrollView.options.deceleration = 0.95;
              }
            }
          });
        }
        var resize = angular.bind(scrollView, scrollView.resize);
        angular.element($window).on('resize', resize);
        var scrollFunc = function(e) {
          var detail = (e.originalEvent || e).detail || {};
          $scope.$onScroll && $scope.$onScroll({
            event: e,
            scrollTop: detail.scrollTop || 0,
            scrollLeft: detail.scrollLeft || 0
          });
        };
        $element.on('scroll', scrollFunc);
        $scope.$on('$destroy', function() {
          deregisterInstance();
          scrollView && scrollView.__cleanup && scrollView.__cleanup();
          angular.element($window).off('resize', resize);
          $element.off('scroll', scrollFunc);
          scrollView = self.scrollView = scrollViewOptions = self._scrollViewOptions = scrollViewOptions.el = self._scrollViewOptions.el = $element = self.$element = element = null;
        });
        $timeout(function() {
          scrollView && scrollView.run && scrollView.run();
        });
        self.getScrollView = function() {
          return scrollView;
        };
        self.getScrollPosition = function() {
          return scrollView.getValues();
        };
        self.resize = function() {
          return $timeout(resize, 0, false).then(function() {
            $element && $element.triggerHandler('scroll-resize');
          });
        };
        self.scrollTop = function(shouldAnimate) {
          self.resize().then(function() {
            scrollView.scrollTo(0, 0, !!shouldAnimate);
          });
        };
        self.scrollBottom = function(shouldAnimate) {
          self.resize().then(function() {
            var max = scrollView.getScrollMax();
            scrollView.scrollTo(max.left, max.top, !!shouldAnimate);
          });
        };
        self.scrollTo = function(left, top, shouldAnimate) {
          self.resize().then(function() {
            scrollView.scrollTo(left, top, !!shouldAnimate);
          });
        };
        self.zoomTo = function(zoom, shouldAnimate, originLeft, originTop) {
          self.resize().then(function() {
            scrollView.zoomTo(zoom, !!shouldAnimate, originLeft, originTop);
          });
        };
        self.zoomBy = function(zoom, shouldAnimate, originLeft, originTop) {
          self.resize().then(function() {
            scrollView.zoomBy(zoom, !!shouldAnimate, originLeft, originTop);
          });
        };
        self.scrollBy = function(left, top, shouldAnimate) {
          self.resize().then(function() {
            scrollView.scrollBy(left, top, !!shouldAnimate);
          });
        };
        self.anchorScroll = function(shouldAnimate) {
          self.resize().then(function() {
            var hash = $location.hash();
            var elm = hash && $document[0].getElementById(hash);
            if (!(hash && elm)) {
              scrollView.scrollTo(0, 0, !!shouldAnimate);
              return ;
            }
            var curElm = elm;
            var scrollLeft = 0,
                scrollTop = 0;
            do {
              if (curElm !== null)
                scrollLeft += curElm.offsetLeft;
              if (curElm !== null)
                scrollTop += curElm.offsetTop;
              curElm = curElm.offsetParent;
            } while (curElm.attributes != self.element.attributes && curElm.offsetParent);
            scrollView.scrollTo(scrollLeft, scrollTop, !!shouldAnimate);
          });
        };
        self.freezeScroll = scrollView.freeze;
        self.freezeAllScrolls = function(shouldFreeze) {
          for (var i = 0; i < $ionicScrollDelegate._instances.length; i++) {
            $ionicScrollDelegate._instances[i].freezeScroll(shouldFreeze);
          }
        };
        self._setRefresher = function(refresherScope, refresherElement, refresherMethods) {
          self.refresher = refresherElement;
          var refresherHeight = self.refresher.clientHeight || 60;
          scrollView.activatePullToRefresh(refresherHeight, refresherMethods);
        };
      }]);
      IonicModule.controller('$ionicSideMenus', ['$scope', '$attrs', '$ionicSideMenuDelegate', '$ionicPlatform', '$ionicBody', '$ionicHistory', '$ionicScrollDelegate', 'IONIC_BACK_PRIORITY', '$rootScope', function($scope, $attrs, $ionicSideMenuDelegate, $ionicPlatform, $ionicBody, $ionicHistory, $ionicScrollDelegate, IONIC_BACK_PRIORITY, $rootScope) {
        var self = this;
        var rightShowing,
            leftShowing,
            isDragging;
        var startX,
            lastX,
            offsetX,
            isAsideExposed;
        var enableMenuWithBackViews = true;
        self.$scope = $scope;
        self.initialize = function(options) {
          self.left = options.left;
          self.right = options.right;
          self.setContent(options.content);
          self.dragThresholdX = options.dragThresholdX || 10;
          $ionicHistory.registerHistory(self.$scope);
        };
        self.setContent = function(content) {
          if (content) {
            self.content = content;
            self.content.onDrag = function(e) {
              self._handleDrag(e);
            };
            self.content.endDrag = function(e) {
              self._endDrag(e);
            };
          }
        };
        self.isOpenLeft = function() {
          return self.getOpenAmount() > 0;
        };
        self.isOpenRight = function() {
          return self.getOpenAmount() < 0;
        };
        self.toggleLeft = function(shouldOpen) {
          if (isAsideExposed || !self.left.isEnabled)
            return ;
          var openAmount = self.getOpenAmount();
          if (arguments.length === 0) {
            shouldOpen = openAmount <= 0;
          }
          self.content.enableAnimation();
          if (!shouldOpen) {
            self.openPercentage(0);
            $rootScope.$emit('$ionicSideMenuClose', 'left');
          } else {
            self.openPercentage(100);
            $rootScope.$emit('$ionicSideMenuOpen', 'left');
          }
        };
        self.toggleRight = function(shouldOpen) {
          if (isAsideExposed || !self.right.isEnabled)
            return ;
          var openAmount = self.getOpenAmount();
          if (arguments.length === 0) {
            shouldOpen = openAmount >= 0;
          }
          self.content.enableAnimation();
          if (!shouldOpen) {
            self.openPercentage(0);
            $rootScope.$emit('$ionicSideMenuClose', 'right');
          } else {
            self.openPercentage(-100);
            $rootScope.$emit('$ionicSideMenuOpen', 'right');
          }
        };
        self.toggle = function(side) {
          if (side == 'right') {
            self.toggleRight();
          } else {
            self.toggleLeft();
          }
        };
        self.close = function() {
          self.openPercentage(0);
          $rootScope.$emit('$ionicSideMenuClose', 'left');
          $rootScope.$emit('$ionicSideMenuClose', 'right');
        };
        self.getOpenAmount = function() {
          return self.content && self.content.getTranslateX() || 0;
        };
        self.getOpenRatio = function() {
          var amount = self.getOpenAmount();
          if (amount >= 0) {
            return amount / self.left.width;
          }
          return amount / self.right.width;
        };
        self.isOpen = function() {
          return self.getOpenAmount() !== 0;
        };
        self.getOpenPercentage = function() {
          return self.getOpenRatio() * 100;
        };
        self.openPercentage = function(percentage) {
          var p = percentage / 100;
          if (self.left && percentage >= 0) {
            self.openAmount(self.left.width * p);
          } else if (self.right && percentage < 0) {
            self.openAmount(self.right.width * p);
          }
          $ionicBody.enableClass((percentage !== 0), 'menu-open');
          freezeAllScrolls(false);
        };
        function freezeAllScrolls(shouldFreeze) {
          if (shouldFreeze && !self.isScrollFreeze) {
            $ionicScrollDelegate.freezeAllScrolls(shouldFreeze);
          } else if (!shouldFreeze && self.isScrollFreeze) {
            $ionicScrollDelegate.freezeAllScrolls(false);
          }
          self.isScrollFreeze = shouldFreeze;
        }
        self.openAmount = function(amount) {
          var maxLeft = self.left && self.left.width || 0;
          var maxRight = self.right && self.right.width || 0;
          if (!(self.left && self.left.isEnabled) && amount > 0) {
            self.content.setTranslateX(0);
            return ;
          }
          if (!(self.right && self.right.isEnabled) && amount < 0) {
            self.content.setTranslateX(0);
            return ;
          }
          if (leftShowing && amount > maxLeft) {
            self.content.setTranslateX(maxLeft);
            return ;
          }
          if (rightShowing && amount < -maxRight) {
            self.content.setTranslateX(-maxRight);
            return ;
          }
          self.content.setTranslateX(amount);
          if (amount >= 0) {
            leftShowing = true;
            rightShowing = false;
            if (amount > 0) {
              self.right && self.right.pushDown && self.right.pushDown();
              self.left && self.left.bringUp && self.left.bringUp();
            }
          } else {
            rightShowing = true;
            leftShowing = false;
            self.right && self.right.bringUp && self.right.bringUp();
            self.left && self.left.pushDown && self.left.pushDown();
          }
        };
        self.snapToRest = function(e) {
          self.content.enableAnimation();
          isDragging = false;
          var ratio = self.getOpenRatio();
          if (ratio === 0) {
            self.openPercentage(0);
            return ;
          }
          var velocityThreshold = 0.3;
          var velocityX = e.gesture.velocityX;
          var direction = e.gesture.direction;
          if (ratio > 0 && ratio < 0.5 && direction == 'right' && velocityX < velocityThreshold) {
            self.openPercentage(0);
          } else if (ratio > 0.5 && direction == 'left' && velocityX < velocityThreshold) {
            self.openPercentage(100);
          } else if (ratio < 0 && ratio > -0.5 && direction == 'left' && velocityX < velocityThreshold) {
            self.openPercentage(0);
          } else if (ratio < 0.5 && direction == 'right' && velocityX < velocityThreshold) {
            self.openPercentage(-100);
          } else if (direction == 'right' && ratio >= 0 && (ratio >= 0.5 || velocityX > velocityThreshold)) {
            self.openPercentage(100);
          } else if (direction == 'left' && ratio <= 0 && (ratio <= -0.5 || velocityX > velocityThreshold)) {
            self.openPercentage(-100);
          } else {
            self.openPercentage(0);
          }
        };
        self.enableMenuWithBackViews = function(val) {
          if (arguments.length) {
            enableMenuWithBackViews = !!val;
          }
          return enableMenuWithBackViews;
        };
        self.isAsideExposed = function() {
          return !!isAsideExposed;
        };
        self.exposeAside = function(shouldExposeAside) {
          if (!(self.left && self.left.isEnabled) && !(self.right && self.right.isEnabled))
            return ;
          self.close();
          isAsideExposed = shouldExposeAside;
          if (self.left && self.left.isEnabled) {
            self.content.setMarginLeft(isAsideExposed ? self.left.width : 0);
          } else if (self.right && self.right.isEnabled) {
            self.content.setMarginRight(isAsideExposed ? self.right.width : 0);
          }
          self.$scope.$emit('$ionicExposeAside', isAsideExposed);
        };
        self.activeAsideResizing = function(isResizing) {
          $ionicBody.enableClass(isResizing, 'aside-resizing');
        };
        self._endDrag = function(e) {
          freezeAllScrolls(false);
          if (isAsideExposed)
            return ;
          if (isDragging) {
            self.snapToRest(e);
          }
          startX = null;
          lastX = null;
          offsetX = null;
        };
        self._handleDrag = function(e) {
          if (isAsideExposed || !$scope.dragContent)
            return ;
          if (!startX) {
            startX = e.gesture.touches[0].pageX;
            lastX = startX;
          } else {
            lastX = e.gesture.touches[0].pageX;
          }
          if (!isDragging && Math.abs(lastX - startX) > self.dragThresholdX) {
            startX = lastX;
            isDragging = true;
            self.content.disableAnimation();
            offsetX = self.getOpenAmount();
          }
          if (isDragging) {
            self.openAmount(offsetX + (lastX - startX));
            freezeAllScrolls(true);
          }
        };
        self.canDragContent = function(canDrag) {
          if (arguments.length) {
            $scope.dragContent = !!canDrag;
          }
          return $scope.dragContent;
        };
        self.edgeThreshold = 25;
        self.edgeThresholdEnabled = false;
        self.edgeDragThreshold = function(value) {
          if (arguments.length) {
            if (isNumber(value) && value > 0) {
              self.edgeThreshold = value;
              self.edgeThresholdEnabled = true;
            } else {
              self.edgeThresholdEnabled = !!value;
            }
          }
          return self.edgeThresholdEnabled;
        };
        self.isDraggableTarget = function(e) {
          var shouldOnlyAllowEdgeDrag = self.edgeThresholdEnabled && !self.isOpen();
          var startX = e.gesture.startEvent && e.gesture.startEvent.center && e.gesture.startEvent.center.pageX;
          var dragIsWithinBounds = !shouldOnlyAllowEdgeDrag || startX <= self.edgeThreshold || startX >= self.content.element.offsetWidth - self.edgeThreshold;
          var backView = $ionicHistory.backView();
          var menuEnabled = enableMenuWithBackViews ? true : !backView;
          if (!menuEnabled) {
            var currentView = $ionicHistory.currentView() || {};
            return backView.historyId !== currentView.historyId;
          }
          return ($scope.dragContent || self.isOpen()) && dragIsWithinBounds && !e.gesture.srcEvent.defaultPrevented && menuEnabled && !e.target.tagName.match(/input|textarea|select|object|embed/i) && !e.target.isContentEditable && !(e.target.dataset ? e.target.dataset.preventScroll : e.target.getAttribute('data-prevent-scroll') == 'true');
        };
        $scope.sideMenuContentTranslateX = 0;
        var deregisterBackButtonAction = noop;
        var closeSideMenu = angular.bind(self, self.close);
        $scope.$watch(function() {
          return self.getOpenAmount() !== 0;
        }, function(isOpen) {
          deregisterBackButtonAction();
          if (isOpen) {
            deregisterBackButtonAction = $ionicPlatform.registerBackButtonAction(closeSideMenu, IONIC_BACK_PRIORITY.sideMenu);
          }
        });
        var deregisterInstance = $ionicSideMenuDelegate._registerInstance(self, $attrs.delegateHandle, function() {
          return $ionicHistory.isActiveScope($scope);
        });
        $scope.$on('$destroy', function() {
          deregisterInstance();
          deregisterBackButtonAction();
          self.$scope = null;
          if (self.content) {
            self.content.element = null;
            self.content = null;
          }
          freezeAllScrolls(false);
        });
        self.initialize({
          left: {width: 275},
          right: {width: 275}
        });
      }]);
      (function(ionic) {
        var TRANSLATE32 = 'translate(32,32)';
        var STROKE_OPACITY = 'stroke-opacity';
        var ROUND = 'round';
        var INDEFINITE = 'indefinite';
        var DURATION = '750ms';
        var NONE = 'none';
        var SHORTCUTS = {
          a: 'animate',
          an: 'attributeName',
          at: 'animateTransform',
          c: 'circle',
          da: 'stroke-dasharray',
          os: 'stroke-dashoffset',
          f: 'fill',
          lc: 'stroke-linecap',
          rc: 'repeatCount',
          sw: 'stroke-width',
          t: 'transform',
          v: 'values'
        };
        var SPIN_ANIMATION = {
          v: '0,32,32;360,32,32',
          an: 'transform',
          type: 'rotate',
          rc: INDEFINITE,
          dur: DURATION
        };
        function createSvgElement(tagName, data, parent, spinnerName) {
          var ele = document.createElement(SHORTCUTS[tagName] || tagName);
          var k,
              x,
              y;
          for (k in data) {
            if (angular.isArray(data[k])) {
              for (x = 0; x < data[k].length; x++) {
                if (data[k][x].fn) {
                  for (y = 0; y < data[k][x].t; y++) {
                    createSvgElement(k, data[k][x].fn(y, spinnerName), ele, spinnerName);
                  }
                } else {
                  createSvgElement(k, data[k][x], ele, spinnerName);
                }
              }
            } else {
              setSvgAttribute(ele, k, data[k]);
            }
          }
          parent.appendChild(ele);
        }
        function setSvgAttribute(ele, k, v) {
          ele.setAttribute(SHORTCUTS[k] || k, v);
        }
        function animationValues(strValues, i) {
          var values = strValues.split(';');
          var back = values.slice(i);
          var front = values.slice(0, values.length - back.length);
          values = back.concat(front).reverse();
          return values.join(';') + ';' + values[0];
        }
        var IOS_SPINNER = {
          sw: 4,
          lc: ROUND,
          line: [{
            fn: function(i, spinnerName) {
              return {
                y1: spinnerName == 'ios' ? 17 : 12,
                y2: spinnerName == 'ios' ? 29 : 20,
                t: TRANSLATE32 + ' rotate(' + (30 * i + (i < 6 ? 180 : -180)) + ')',
                a: [{
                  fn: function() {
                    return {
                      an: STROKE_OPACITY,
                      dur: DURATION,
                      v: animationValues('0;.1;.15;.25;.35;.45;.55;.65;.7;.85;1', i),
                      rc: INDEFINITE
                    };
                  },
                  t: 1
                }]
              };
            },
            t: 12
          }]
        };
        var spinners = {
          android: {c: [{
              sw: 6,
              da: 128,
              os: 82,
              r: 26,
              cx: 32,
              cy: 32,
              f: NONE
            }]},
          ios: IOS_SPINNER,
          'ios-small': IOS_SPINNER,
          bubbles: {
            sw: 0,
            c: [{
              fn: function(i) {
                return {
                  cx: 24 * Math.cos(2 * Math.PI * i / 8),
                  cy: 24 * Math.sin(2 * Math.PI * i / 8),
                  t: TRANSLATE32,
                  a: [{
                    fn: function() {
                      return {
                        an: 'r',
                        dur: DURATION,
                        v: animationValues('1;2;3;4;5;6;7;8', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }]
                };
              },
              t: 8
            }]
          },
          circles: {c: [{
              fn: function(i) {
                return {
                  r: 5,
                  cx: 24 * Math.cos(2 * Math.PI * i / 8),
                  cy: 24 * Math.sin(2 * Math.PI * i / 8),
                  t: TRANSLATE32,
                  sw: 0,
                  a: [{
                    fn: function() {
                      return {
                        an: 'fill-opacity',
                        dur: DURATION,
                        v: animationValues('.3;.3;.3;.4;.7;.85;.9;1', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }]
                };
              },
              t: 8
            }]},
          crescent: {c: [{
              sw: 4,
              da: 128,
              os: 82,
              r: 26,
              cx: 32,
              cy: 32,
              f: NONE,
              at: [SPIN_ANIMATION]
            }]},
          dots: {c: [{
              fn: function(i) {
                return {
                  cx: 16 + (16 * i),
                  cy: 32,
                  sw: 0,
                  a: [{
                    fn: function() {
                      return {
                        an: 'fill-opacity',
                        dur: DURATION,
                        v: animationValues('.5;.6;.8;1;.8;.6;.5', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }, {
                    fn: function() {
                      return {
                        an: 'r',
                        dur: DURATION,
                        v: animationValues('4;5;6;5;4;3;3', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }]
                };
              },
              t: 3
            }]},
          lines: {
            sw: 7,
            lc: ROUND,
            line: [{
              fn: function(i) {
                return {
                  x1: 10 + (i * 14),
                  x2: 10 + (i * 14),
                  a: [{
                    fn: function() {
                      return {
                        an: 'y1',
                        dur: DURATION,
                        v: animationValues('16;18;28;18;16', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }, {
                    fn: function() {
                      return {
                        an: 'y2',
                        dur: DURATION,
                        v: animationValues('48;44;36;46;48', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }, {
                    fn: function() {
                      return {
                        an: STROKE_OPACITY,
                        dur: DURATION,
                        v: animationValues('1;.8;.5;.4;1', i),
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }]
                };
              },
              t: 4
            }]
          },
          ripple: {
            f: NONE,
            'fill-rule': 'evenodd',
            sw: 3,
            circle: [{
              fn: function(i) {
                return {
                  cx: 32,
                  cy: 32,
                  a: [{
                    fn: function() {
                      return {
                        an: 'r',
                        begin: (i * -1) + 's',
                        dur: '2s',
                        v: '0;24',
                        keyTimes: '0;1',
                        keySplines: '0.1,0.2,0.3,1',
                        calcMode: 'spline',
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }, {
                    fn: function() {
                      return {
                        an: STROKE_OPACITY,
                        begin: (i * -1) + 's',
                        dur: '2s',
                        v: '.2;1;.2;0',
                        rc: INDEFINITE
                      };
                    },
                    t: 1
                  }]
                };
              },
              t: 2
            }]
          },
          spiral: {
            defs: [{linearGradient: [{
                id: 'sGD',
                gradientUnits: 'userSpaceOnUse',
                x1: 55,
                y1: 46,
                x2: 2,
                y2: 46,
                stop: [{
                  offset: 0.1,
                  class: 'stop1'
                }, {
                  offset: 1,
                  class: 'stop2'
                }]
              }]}],
            g: [{
              sw: 4,
              lc: ROUND,
              f: NONE,
              path: [{
                stroke: 'url(#sGD)',
                d: 'M4,32 c0,15,12,28,28,28c8,0,16-4,21-9'
              }, {d: 'M60,32 C60,16,47.464,4,32,4S4,16,4,32'}],
              at: [SPIN_ANIMATION]
            }]
          }
        };
        var animations = {android: function(ele) {
            var rIndex = 0;
            var rotateCircle = 0;
            var startTime;
            var svgEle = ele.querySelector('g');
            var circleEle = ele.querySelector('circle');
            function run() {
              var v = easeInOutCubic(Date.now() - startTime, 650);
              var scaleX = 1;
              var translateX = 0;
              var dasharray = (188 - (58 * v));
              var dashoffset = (182 - (182 * v));
              if (rIndex % 2) {
                scaleX = -1;
                translateX = -64;
                dasharray = (128 - (-58 * v));
                dashoffset = (182 * v);
              }
              var rotateLine = [0, -101, -90, -11, -180, 79, -270, -191][rIndex];
              setSvgAttribute(circleEle, 'da', Math.max(Math.min(dasharray, 188), 128));
              setSvgAttribute(circleEle, 'os', Math.max(Math.min(dashoffset, 182), 0));
              setSvgAttribute(circleEle, 't', 'scale(' + scaleX + ',1) translate(' + translateX + ',0) rotate(' + rotateLine + ',32,32)');
              rotateCircle += 4.1;
              if (rotateCircle > 359)
                rotateCircle = 0;
              setSvgAttribute(svgEle, 't', 'rotate(' + rotateCircle + ',32,32)');
              if (v >= 1) {
                rIndex++;
                if (rIndex > 7)
                  rIndex = 0;
                startTime = Date.now();
              }
              ionic.requestAnimationFrame(run);
            }
            return function() {
              startTime = Date.now();
              run();
            };
          }};
        function easeInOutCubic(t, c) {
          t /= c / 2;
          if (t < 1)
            return 1 / 2 * t * t * t;
          t -= 2;
          return 1 / 2 * (t * t * t + 2);
        }
        IonicModule.controller('$ionicSpinner', ['$element', '$attrs', '$ionicConfig', function($element, $attrs, $ionicConfig) {
          var spinnerName;
          this.init = function() {
            spinnerName = $attrs.icon || $ionicConfig.spinner.icon();
            var container = document.createElement('div');
            createSvgElement('svg', {
              viewBox: '0 0 64 64',
              g: [spinners[spinnerName]]
            }, container, spinnerName);
            $element.html(container.innerHTML);
            this.start();
            return spinnerName;
          };
          this.start = function() {
            animations[spinnerName] && animations[spinnerName]($element[0])();
          };
        }]);
      })(ionic);
      IonicModule.controller('$ionicTab', ['$scope', '$ionicHistory', '$attrs', '$location', '$state', function($scope, $ionicHistory, $attrs, $location, $state) {
        this.$scope = $scope;
        this.hrefMatchesState = function() {
          return $attrs.href && $location.path().indexOf($attrs.href.replace(/^#/, '').replace(/\/$/, '')) === 0;
        };
        this.srefMatchesState = function() {
          return $attrs.uiSref && $state.includes($attrs.uiSref.split('(')[0]);
        };
        this.navNameMatchesState = function() {
          return this.navViewName && $ionicHistory.isCurrentStateNavView(this.navViewName);
        };
        this.tabMatchesState = function() {
          return this.hrefMatchesState() || this.srefMatchesState() || this.navNameMatchesState();
        };
      }]);
      IonicModule.controller('$ionicTabs', ['$scope', '$element', '$ionicHistory', function($scope, $element, $ionicHistory) {
        var self = this;
        var selectedTab = null;
        var previousSelectedTab = null;
        var selectedTabIndex;
        self.tabs = [];
        self.selectedIndex = function() {
          return self.tabs.indexOf(selectedTab);
        };
        self.selectedTab = function() {
          return selectedTab;
        };
        self.previousSelectedTab = function() {
          return previousSelectedTab;
        };
        self.add = function(tab) {
          $ionicHistory.registerHistory(tab);
          self.tabs.push(tab);
        };
        self.remove = function(tab) {
          var tabIndex = self.tabs.indexOf(tab);
          if (tabIndex === -1) {
            return ;
          }
          if (tab.$tabSelected) {
            self.deselect(tab);
            if (self.tabs.length === 1) {} else {
              var newTabIndex = tabIndex === self.tabs.length - 1 ? tabIndex - 1 : tabIndex + 1;
              self.select(self.tabs[newTabIndex]);
            }
          }
          self.tabs.splice(tabIndex, 1);
        };
        self.deselect = function(tab) {
          if (tab.$tabSelected) {
            previousSelectedTab = selectedTab;
            selectedTab = selectedTabIndex = null;
            tab.$tabSelected = false;
            (tab.onDeselect || noop)();
            tab.$broadcast && tab.$broadcast('$ionicHistory.deselect');
          }
        };
        self.select = function(tab, shouldEmitEvent) {
          var tabIndex;
          if (isNumber(tab)) {
            tabIndex = tab;
            if (tabIndex >= self.tabs.length)
              return ;
            tab = self.tabs[tabIndex];
          } else {
            tabIndex = self.tabs.indexOf(tab);
          }
          if (arguments.length === 1) {
            shouldEmitEvent = !!(tab.navViewName || tab.uiSref);
          }
          if (selectedTab && selectedTab.$historyId == tab.$historyId) {
            if (shouldEmitEvent) {
              $ionicHistory.goToHistoryRoot(tab.$historyId);
            }
          } else if (selectedTabIndex !== tabIndex) {
            forEach(self.tabs, function(tab) {
              self.deselect(tab);
            });
            selectedTab = tab;
            selectedTabIndex = tabIndex;
            if (self.$scope && self.$scope.$parent) {
              self.$scope.$parent.$activeHistoryId = tab.$historyId;
            }
            tab.$tabSelected = true;
            (tab.onSelect || noop)();
            if (shouldEmitEvent) {
              $scope.$emit('$ionicHistory.change', {
                type: 'tab',
                tabIndex: tabIndex,
                historyId: tab.$historyId,
                navViewName: tab.navViewName,
                hasNavView: !!tab.navViewName,
                title: tab.title,
                url: tab.href,
                uiSref: tab.uiSref
              });
            }
          }
        };
        self.hasActiveScope = function() {
          for (var x = 0; x < self.tabs.length; x++) {
            if ($ionicHistory.isActiveScope(self.tabs[x])) {
              return true;
            }
          }
          return false;
        };
      }]);
      IonicModule.controller('$ionicView', ['$scope', '$element', '$attrs', '$compile', '$rootScope', function($scope, $element, $attrs, $compile, $rootScope) {
        var self = this;
        var navElementHtml = {};
        var navViewCtrl;
        var navBarDelegateHandle;
        var hasViewHeaderBar;
        var deregisters = [];
        var viewTitle;
        var deregIonNavBarInit = $scope.$on('ionNavBar.init', function(ev, delegateHandle) {
          ev.stopPropagation();
          navBarDelegateHandle = delegateHandle;
        });
        self.init = function() {
          deregIonNavBarInit();
          var modalCtrl = $element.inheritedData('$ionModalController');
          navViewCtrl = $element.inheritedData('$ionNavViewController');
          if (!navViewCtrl || modalCtrl)
            return ;
          $scope.$on('$ionicView.beforeEnter', self.beforeEnter);
          $scope.$on('$ionicView.afterEnter', afterEnter);
          $scope.$on('$ionicView.beforeLeave', deregisterFns);
        };
        self.beforeEnter = function(ev, transData) {
          if (transData && !transData.viewNotified) {
            transData.viewNotified = true;
            if (!$rootScope.$$phase)
              $scope.$digest();
            viewTitle = isDefined($attrs.viewTitle) ? $attrs.viewTitle : $attrs.title;
            var navBarItems = {};
            for (var n in navElementHtml) {
              navBarItems[n] = generateNavBarItem(navElementHtml[n]);
            }
            navViewCtrl.beforeEnter(extend(transData, {
              title: viewTitle,
              showBack: !attrTrue('hideBackButton'),
              navBarItems: navBarItems,
              navBarDelegate: navBarDelegateHandle || null,
              showNavBar: !attrTrue('hideNavBar'),
              hasHeaderBar: !!hasViewHeaderBar
            }));
            deregisterFns();
          }
        };
        function afterEnter() {
          var viewTitleAttr = isDefined($attrs.viewTitle) && 'viewTitle' || isDefined($attrs.title) && 'title';
          if (viewTitleAttr) {
            titleUpdate($attrs[viewTitleAttr]);
            deregisters.push($attrs.$observe(viewTitleAttr, titleUpdate));
          }
          if (isDefined($attrs.hideBackButton)) {
            deregisters.push($scope.$watch($attrs.hideBackButton, function(val) {
              navViewCtrl.showBackButton(!val);
            }));
          }
          if (isDefined($attrs.hideNavBar)) {
            deregisters.push($scope.$watch($attrs.hideNavBar, function(val) {
              navViewCtrl.showBar(!val);
            }));
          }
        }
        function titleUpdate(newTitle) {
          if (isDefined(newTitle) && newTitle !== viewTitle) {
            viewTitle = newTitle;
            navViewCtrl.title(viewTitle);
          }
        }
        function deregisterFns() {
          for (var x = 0; x < deregisters.length; x++) {
            deregisters[x]();
          }
          deregisters = [];
        }
        function generateNavBarItem(html) {
          if (html) {
            return $compile(html)($scope.$new());
          }
        }
        function attrTrue(key) {
          return !!$scope.$eval($attrs[key]);
        }
        self.navElement = function(type, html) {
          navElementHtml[type] = html;
        };
      }]);
      IonicModule.directive('ionActionSheet', ['$document', function($document) {
        return {
          restrict: 'E',
          scope: true,
          replace: true,
          link: function($scope, $element) {
            var keyUp = function(e) {
              if (e.which == 27) {
                $scope.cancel();
                $scope.$apply();
              }
            };
            var backdropClick = function(e) {
              if (e.target == $element[0]) {
                $scope.cancel();
                $scope.$apply();
              }
            };
            $scope.$on('$destroy', function() {
              $element.remove();
              $document.unbind('keyup', keyUp);
            });
            $document.bind('keyup', keyUp);
            $element.bind('click', backdropClick);
          },
          template: '<div class="action-sheet-backdrop">' + '<div class="action-sheet-wrapper">' + '<div class="action-sheet" ng-class="{\'action-sheet-has-icons\': $actionSheetHasIcon}">' + '<div class="action-sheet-group action-sheet-options">' + '<div class="action-sheet-title" ng-if="titleText" ng-bind-html="titleText"></div>' + '<button class="button action-sheet-option" ng-click="buttonClicked($index)" ng-repeat="b in buttons" ng-bind-html="b.text"></button>' + '<button class="button destructive action-sheet-destructive" ng-if="destructiveText" ng-click="destructiveButtonClicked()" ng-bind-html="destructiveText"></button>' + '</div>' + '<div class="action-sheet-group action-sheet-cancel" ng-if="cancelText">' + '<button class="button" ng-click="cancel()" ng-bind-html="cancelText"></button>' + '</div>' + '</div>' + '</div>' + '</div>'
        };
      }]);
      IonicModule.directive('ionCheckbox', ['$ionicConfig', function($ionicConfig) {
        return {
          restrict: 'E',
          replace: true,
          require: '?ngModel',
          transclude: true,
          template: '<label class="item item-checkbox">' + '<div class="checkbox checkbox-input-hidden disable-pointer-events">' + '<input type="checkbox">' + '<i class="checkbox-icon"></i>' + '</div>' + '<div class="item-content disable-pointer-events" ng-transclude></div>' + '</label>',
          compile: function(element, attr) {
            var input = element.find('input');
            forEach({
              'name': attr.name,
              'ng-value': attr.ngValue,
              'ng-model': attr.ngModel,
              'ng-checked': attr.ngChecked,
              'ng-disabled': attr.ngDisabled,
              'ng-true-value': attr.ngTrueValue,
              'ng-false-value': attr.ngFalseValue,
              'ng-change': attr.ngChange,
              'ng-required': attr.ngRequired,
              'required': attr.required
            }, function(value, name) {
              if (isDefined(value)) {
                input.attr(name, value);
              }
            });
            var checkboxWrapper = element[0].querySelector('.checkbox');
            checkboxWrapper.classList.add('checkbox-' + $ionicConfig.form.checkbox());
          }
        };
      }]);
      IonicModule.directive('collectionRepeat', CollectionRepeatDirective).factory('$ionicCollectionManager', RepeatManagerFactory);
      var ONE_PX_TRANSPARENT_IMG_SRC = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
      var WIDTH_HEIGHT_REGEX = /height:.*?px;\s*width:.*?px/;
      var DEFAULT_RENDER_BUFFER = 3;
      CollectionRepeatDirective.$inject = ['$ionicCollectionManager', '$parse', '$window', '$$rAF', '$rootScope', '$timeout'];
      function CollectionRepeatDirective($ionicCollectionManager, $parse, $window, $$rAF, $rootScope, $timeout) {
        return {
          restrict: 'A',
          priority: 1000,
          transclude: 'element',
          $$tlb: true,
          require: '^^$ionicScroll',
          link: postLink
        };
        function postLink(scope, element, attr, scrollCtrl, transclude) {
          var scrollView = scrollCtrl.scrollView;
          var node = element[0];
          var containerNode = angular.element('<div class="collection-repeat-container">')[0];
          node.parentNode.replaceChild(containerNode, node);
          if (scrollView.options.scrollingX && scrollView.options.scrollingY) {
            throw new Error("collection-repeat expected a parent x or y scrollView, not " + "an xy scrollView.");
          }
          var repeatExpr = attr.collectionRepeat;
          var match = repeatExpr.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
          if (!match) {
            throw new Error("collection-repeat expected expression in form of '_item_ in " + "_collection_[ track by _id_]' but got '" + attr.collectionRepeat + "'.");
          }
          var keyExpr = match[1];
          var listExpr = match[2];
          var listGetter = $parse(listExpr);
          var heightData = {};
          var widthData = {};
          var computedStyleDimensions = {};
          var data = [];
          var repeatManager;
          var renderBufferExpr = attr.itemRenderBuffer || attr.collectionBufferSize;
          var renderBuffer = angular.isDefined(renderBufferExpr) ? parseInt(renderBufferExpr) : DEFAULT_RENDER_BUFFER;
          var heightExpr = attr.itemHeight || attr.collectionItemHeight;
          var widthExpr = attr.itemWidth || attr.collectionItemWidth;
          var afterItemsContainer = initAfterItemsContainer();
          var changeValidator = makeChangeValidator();
          initDimensions();
          scrollCtrl.$element.on('scroll-resize', refreshDimensions);
          angular.element($window).on('resize', onResize);
          var unlistenToExposeAside = $rootScope.$on('$ionicExposeAside', ionic.animationFrameThrottle(function() {
            scrollCtrl.scrollView.resize();
            onResize();
          }));
          $timeout(refreshDimensions, 0, false);
          function onResize() {
            if (changeValidator.resizeRequiresRefresh(scrollView.__clientWidth, scrollView.__clientHeight)) {
              refreshDimensions();
            }
          }
          scope.$watchCollection(listGetter, function(newValue) {
            data = newValue || (newValue = []);
            if (!angular.isArray(newValue)) {
              throw new Error("collection-repeat expected an array for '" + listExpr + "', " + "but got a " + typeof value);
            }
            scope.$$postDigest(function() {
              getRepeatManager().setData(data);
              if (changeValidator.dataChangeRequiresRefresh(data))
                refreshDimensions();
            });
          });
          scope.$on('$destroy', function() {
            angular.element($window).off('resize', onResize);
            unlistenToExposeAside();
            scrollCtrl.$element && scrollCtrl.$element.off('scroll-resize', refreshDimensions);
            computedStyleNode && computedStyleNode.parentNode && computedStyleNode.parentNode.removeChild(computedStyleNode);
            computedStyleScope && computedStyleScope.$destroy();
            computedStyleScope = computedStyleNode = null;
            repeatManager && repeatManager.destroy();
            repeatManager = null;
          });
          function makeChangeValidator() {
            var self;
            return (self = {
              dataLength: 0,
              width: 0,
              height: 0,
              resizeRequiresRefresh: function(newWidth, newHeight) {
                var requiresRefresh = self.dataLength && newWidth && newHeight && (newWidth !== self.width || newHeight !== self.height);
                self.width = newWidth;
                self.height = newHeight;
                return !!requiresRefresh;
              },
              dataChangeRequiresRefresh: function(newData) {
                var requiresRefresh = newData.length > 0 || newData.length < self.dataLength;
                self.dataLength = newData.length;
                return !!requiresRefresh;
              }
            });
          }
          function getRepeatManager() {
            return repeatManager || (repeatManager = new $ionicCollectionManager({
              afterItemsNode: afterItemsContainer[0],
              containerNode: containerNode,
              heightData: heightData,
              widthData: widthData,
              forceRefreshImages: !!(isDefined(attr.forceRefreshImages) && attr.forceRefreshImages !== 'false'),
              keyExpression: keyExpr,
              renderBuffer: renderBuffer,
              scope: scope,
              scrollView: scrollCtrl.scrollView,
              transclude: transclude
            }));
          }
          function initAfterItemsContainer() {
            var container = angular.element(scrollView.__content.querySelector('.collection-repeat-after-container'));
            if (!container.length) {
              var elementIsAfterRepeater = false;
              var afterNodes = [].filter.call(scrollView.__content.childNodes, function(node) {
                if (ionic.DomUtil.contains(node, containerNode)) {
                  elementIsAfterRepeater = true;
                  return false;
                }
                return elementIsAfterRepeater;
              });
              container = angular.element('<span class="collection-repeat-after-container">');
              if (scrollView.options.scrollingX) {
                container.addClass('horizontal');
              }
              container.append(afterNodes);
              scrollView.__content.appendChild(container[0]);
            }
            return container;
          }
          function initDimensions() {
            if (heightExpr) {
              parseDimensionAttr(heightExpr, heightData);
            } else {
              heightData.computed = true;
            }
            if (widthExpr) {
              parseDimensionAttr(widthExpr, widthData);
            } else {
              widthData.computed = true;
            }
          }
          function refreshDimensions() {
            var hasData = data.length > 0;
            if (hasData && (heightData.computed || widthData.computed)) {
              computeStyleDimensions();
            }
            if (hasData && heightData.computed) {
              heightData.value = computedStyleDimensions.height;
              if (!heightData.value) {
                throw new Error('collection-repeat tried to compute the height of repeated elements "' + repeatExpr + '", but was unable to. Please provide the "item-height" attribute. ' + 'http://ionicframework.com/docs/api/directive/collectionRepeat/');
              }
            } else if (!heightData.dynamic && heightData.getValue) {
              heightData.value = heightData.getValue();
            }
            if (hasData && widthData.computed) {
              widthData.value = computedStyleDimensions.width;
              if (!widthData.value) {
                throw new Error('collection-repeat tried to compute the width of repeated elements "' + repeatExpr + '", but was unable to. Please provide the "item-width" attribute. ' + 'http://ionicframework.com/docs/api/directive/collectionRepeat/');
              }
            } else if (!widthData.dynamic && widthData.getValue) {
              widthData.value = widthData.getValue();
            }
            getRepeatManager().refreshLayout();
          }
          function parseDimensionAttr(attrValue, dimensionData) {
            if (!attrValue)
              return ;
            var parsedValue;
            try {
              parsedValue = $parse(attrValue);
            } catch (e) {
              if (attrValue.trim().match(/\d+(px|%)$/)) {
                attrValue = '"' + attrValue + '"';
              }
              parsedValue = $parse(attrValue);
            }
            var constantAttrValue = attrValue.replace(/(\'|\"|px|%)/g, '').trim();
            var isConstant = constantAttrValue.length && !/([a-zA-Z]|\$|:|\?)/.test(constantAttrValue);
            dimensionData.attrValue = attrValue;
            if (isConstant) {
              var intValue = parseInt(parsedValue());
              if (attrValue.indexOf('%') > -1) {
                var decimalValue = intValue / 100;
                dimensionData.getValue = dimensionData === heightData ? function() {
                  return Math.floor(decimalValue * scrollView.__clientHeight);
                } : function() {
                  return Math.floor(decimalValue * scrollView.__clientWidth);
                };
              } else {
                dimensionData.value = intValue;
              }
            } else {
              dimensionData.dynamic = true;
              dimensionData.getValue = dimensionData === heightData ? function heightGetter(scope, locals) {
                var result = parsedValue(scope, locals);
                if (result.charAt && result.charAt(result.length - 1) === '%') {
                  return Math.floor(parseInt(result) / 100 * scrollView.__clientHeight);
                }
                return parseInt(result);
              } : function widthGetter(scope, locals) {
                var result = parsedValue(scope, locals);
                if (result.charAt && result.charAt(result.length - 1) === '%') {
                  return Math.floor(parseInt(result) / 100 * scrollView.__clientWidth);
                }
                return parseInt(result);
              };
            }
          }
          var computedStyleNode;
          var computedStyleScope;
          function computeStyleDimensions() {
            if (!computedStyleNode) {
              transclude(computedStyleScope = scope.$new(), function(clone) {
                clone[0].removeAttribute('collection-repeat');
                computedStyleNode = clone[0];
              });
            }
            computedStyleScope[keyExpr] = (listGetter(scope) || [])[0];
            if (!$rootScope.$$phase)
              computedStyleScope.$digest();
            containerNode.appendChild(computedStyleNode);
            var style = $window.getComputedStyle(computedStyleNode);
            computedStyleDimensions.width = parseInt(style.width);
            computedStyleDimensions.height = parseInt(style.height);
            containerNode.removeChild(computedStyleNode);
          }
        }
      }
      RepeatManagerFactory.$inject = ['$rootScope', '$window', '$$rAF'];
      function RepeatManagerFactory($rootScope, $window, $$rAF) {
        var EMPTY_DIMENSION = {
          primaryPos: 0,
          secondaryPos: 0,
          primarySize: 0,
          secondarySize: 0,
          rowPrimarySize: 0
        };
        return function RepeatController(options) {
          var afterItemsNode = options.afterItemsNode;
          var containerNode = options.containerNode;
          var forceRefreshImages = options.forceRefreshImages;
          var heightData = options.heightData;
          var widthData = options.widthData;
          var keyExpression = options.keyExpression;
          var renderBuffer = options.renderBuffer;
          var scope = options.scope;
          var scrollView = options.scrollView;
          var transclude = options.transclude;
          var data = [];
          var getterLocals = {};
          var heightFn = heightData.getValue || function() {
            return heightData.value;
          };
          var heightGetter = function(index, value) {
            getterLocals[keyExpression] = value;
            getterLocals.$index = index;
            return heightFn(scope, getterLocals);
          };
          var widthFn = widthData.getValue || function() {
            return widthData.value;
          };
          var widthGetter = function(index, value) {
            getterLocals[keyExpression] = value;
            getterLocals.$index = index;
            return widthFn(scope, getterLocals);
          };
          var isVertical = !!scrollView.options.scrollingY;
          var isGridView = isVertical ? (widthData.dynamic || widthData.value !== scrollView.__clientWidth) : (heightData.dynamic || heightData.value !== scrollView.__clientHeight);
          var isStaticView = !heightData.dynamic && !widthData.dynamic;
          var PRIMARY = 'PRIMARY';
          var SECONDARY = 'SECONDARY';
          var TRANSLATE_TEMPLATE_STR = isVertical ? 'translate3d(SECONDARYpx,PRIMARYpx,0)' : 'translate3d(PRIMARYpx,SECONDARYpx,0)';
          var WIDTH_HEIGHT_TEMPLATE_STR = isVertical ? 'height: PRIMARYpx; width: SECONDARYpx;' : 'height: SECONDARYpx; width: PRIMARYpx;';
          var estimatedHeight;
          var estimatedWidth;
          var repeaterBeforeSize = 0;
          var repeaterAfterSize = 0;
          var renderStartIndex = -1;
          var renderEndIndex = -1;
          var renderAfterBoundary = -1;
          var renderBeforeBoundary = -1;
          var itemsPool = [];
          var itemsLeaving = [];
          var itemsEntering = [];
          var itemsShownMap = {};
          var nextItemId = 0;
          var scrollViewSetDimensions = isVertical ? function() {
            scrollView.setDimensions(null, null, null, view.getContentSize(), true);
          } : function() {
            scrollView.setDimensions(null, null, view.getContentSize(), null, true);
          };
          var view = isVertical ? new VerticalViewType() : new HorizontalViewType();
          (isGridView ? GridViewType : ListViewType).call(view);
          (isStaticView ? StaticViewType : DynamicViewType).call(view);
          var contentSizeStr = isVertical ? 'getContentHeight' : 'getContentWidth';
          var originalGetContentSize = scrollView.options[contentSizeStr];
          scrollView.options[contentSizeStr] = angular.bind(view, view.getContentSize);
          scrollView.__$callback = scrollView.__callback;
          scrollView.__callback = function(transformLeft, transformTop, zoom, wasResize) {
            var scrollValue = view.getScrollValue();
            if (renderStartIndex === -1 || scrollValue + view.scrollPrimarySize > renderAfterBoundary || scrollValue < renderBeforeBoundary) {
              render();
            }
            scrollView.__$callback(transformLeft, transformTop, zoom, wasResize);
          };
          var isLayoutReady = false;
          var isDataReady = false;
          this.refreshLayout = function() {
            if (data.length) {
              estimatedHeight = heightGetter(0, data[0]);
              estimatedWidth = widthGetter(0, data[0]);
            } else {
              estimatedHeight = 100;
              estimatedWidth = 100;
            }
            var style = getComputedStyle(afterItemsNode) || {};
            var firstStyle = afterItemsNode.firstElementChild && getComputedStyle(afterItemsNode.firstElementChild) || {};
            var lastStyle = afterItemsNode.lastElementChild && getComputedStyle(afterItemsNode.lastElementChild) || {};
            repeaterAfterSize = (parseInt(style[isVertical ? 'height' : 'width']) || 0) + (firstStyle && parseInt(firstStyle[isVertical ? 'marginTop' : 'marginLeft']) || 0) + (lastStyle && parseInt(lastStyle[isVertical ? 'marginBottom' : 'marginRight']) || 0);
            repeaterBeforeSize = 0;
            var current = containerNode;
            do {
              repeaterBeforeSize += current[isVertical ? 'offsetTop' : 'offsetLeft'];
            } while (ionic.DomUtil.contains(scrollView.__content, current = current.offsetParent));
            var containerPrevNode = containerNode.previousElementSibling;
            var beforeStyle = containerPrevNode ? $window.getComputedStyle(containerPrevNode) : {};
            var beforeMargin = parseInt(beforeStyle[isVertical ? 'marginBottom' : 'marginRight'] || 0);
            containerNode.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR.replace(PRIMARY, -beforeMargin).replace(SECONDARY, 0);
            repeaterBeforeSize -= beforeMargin;
            if (!scrollView.__clientHeight || !scrollView.__clientWidth) {
              scrollView.__clientWidth = scrollView.__container.clientWidth;
              scrollView.__clientHeight = scrollView.__container.clientHeight;
            }
            (view.onRefreshLayout || angular.noop)();
            view.refreshDirection();
            scrollViewSetDimensions();
            if (!isLayoutReady) {
              var poolSize = Math.max(20, renderBuffer * 3);
              for (var i = 0; i < poolSize; i++) {
                itemsPool.push(new RepeatItem());
              }
            }
            isLayoutReady = true;
            if (isLayoutReady && isDataReady) {
              if (scrollView.__scrollLeft > scrollView.__maxScrollLeft || scrollView.__scrollTop > scrollView.__maxScrollTop) {
                scrollView.resize();
              }
              forceRerender(true);
            }
          };
          this.setData = function(newData) {
            data = newData;
            (view.onRefreshData || angular.noop)();
            isDataReady = true;
          };
          this.destroy = function() {
            render.destroyed = true;
            itemsPool.forEach(function(item) {
              item.scope.$destroy();
              item.scope = item.element = item.node = item.images = null;
            });
            itemsPool.length = itemsEntering.length = itemsLeaving.length = 0;
            itemsShownMap = {};
            scrollView.options[contentSizeStr] = originalGetContentSize;
            scrollView.__callback = scrollView.__$callback;
            scrollView.resize();
            (view.onDestroy || angular.noop)();
          };
          function forceRerender() {
            return render(true);
          }
          function render(forceRerender) {
            if (render.destroyed)
              return ;
            var i;
            var ii;
            var item;
            var dim;
            var scope;
            var scrollValue = view.getScrollValue();
            var scrollValueEnd = scrollValue + view.scrollPrimarySize;
            view.updateRenderRange(scrollValue, scrollValueEnd);
            renderStartIndex = Math.max(0, renderStartIndex - renderBuffer);
            renderEndIndex = Math.min(data.length - 1, renderEndIndex + renderBuffer);
            for (i in itemsShownMap) {
              if (i < renderStartIndex || i > renderEndIndex) {
                item = itemsShownMap[i];
                delete itemsShownMap[i];
                itemsLeaving.push(item);
                item.isShown = false;
              }
            }
            for (i = renderStartIndex; i <= renderEndIndex; i++) {
              if (i >= data.length || (itemsShownMap[i] && !forceRerender))
                continue;
              item = itemsShownMap[i] || (itemsShownMap[i] = itemsLeaving.length ? itemsLeaving.pop() : itemsPool.length ? itemsPool.shift() : new RepeatItem());
              itemsEntering.push(item);
              item.isShown = true;
              scope = item.scope;
              scope.$index = i;
              scope[keyExpression] = data[i];
              scope.$first = (i === 0);
              scope.$last = (i === (data.length - 1));
              scope.$middle = !(scope.$first || scope.$last);
              scope.$odd = !(scope.$even = (i & 1) === 0);
              if (scope.$$disconnected)
                ionic.Utils.reconnectScope(item.scope);
              dim = view.getDimensions(i);
              if (item.secondaryPos !== dim.secondaryPos || item.primaryPos !== dim.primaryPos) {
                item.node.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR.replace(PRIMARY, (item.primaryPos = dim.primaryPos)).replace(SECONDARY, (item.secondaryPos = dim.secondaryPos));
              }
              if (item.secondarySize !== dim.secondarySize || item.primarySize !== dim.primarySize) {
                item.node.style.cssText = item.node.style.cssText.replace(WIDTH_HEIGHT_REGEX, WIDTH_HEIGHT_TEMPLATE_STR.replace(PRIMARY, (item.primarySize = dim.primarySize) + 1).replace(SECONDARY, (item.secondarySize = dim.secondarySize)));
              }
            }
            if (renderEndIndex === data.length - 1) {
              dim = view.getDimensions(data.length - 1) || EMPTY_DIMENSION;
              afterItemsNode.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR.replace(PRIMARY, dim.primaryPos + dim.primarySize).replace(SECONDARY, 0);
            }
            while (itemsLeaving.length) {
              item = itemsLeaving.pop();
              item.scope.$broadcast('$collectionRepeatLeave');
              ionic.Utils.disconnectScope(item.scope);
              itemsPool.push(item);
              item.node.style[ionic.CSS.TRANSFORM] = 'translate3d(-9999px,-9999px,0)';
              item.primaryPos = item.secondaryPos = null;
            }
            if (forceRefreshImages) {
              for (i = 0, ii = itemsEntering.length; i < ii && (item = itemsEntering[i]); i++) {
                if (!item.images)
                  continue;
                for (var j = 0,
                    jj = item.images.length,
                    img; j < jj && (img = item.images[j]); j++) {
                  var src = img.src;
                  img.src = ONE_PX_TRANSPARENT_IMG_SRC;
                  img.src = src;
                }
              }
            }
            if (forceRerender) {
              var rootScopePhase = $rootScope.$$phase;
              while (itemsEntering.length) {
                item = itemsEntering.pop();
                if (!rootScopePhase)
                  item.scope.$digest();
              }
            } else {
              digestEnteringItems();
            }
          }
          function digestEnteringItems() {
            var item;
            if (digestEnteringItems.running)
              return ;
            digestEnteringItems.running = true;
            $$rAF(function process() {
              var rootScopePhase = $rootScope.$$phase;
              while (itemsEntering.length) {
                item = itemsEntering.pop();
                if (item.isShown) {
                  if (!rootScopePhase)
                    item.scope.$digest();
                }
              }
              digestEnteringItems.running = false;
            });
          }
          function RepeatItem() {
            var self = this;
            this.scope = scope.$new();
            this.id = 'item' + (nextItemId++);
            transclude(this.scope, function(clone) {
              self.element = clone;
              self.element.data('$$collectionRepeatItem', self);
              self.node = clone[0];
              self.node.style[ionic.CSS.TRANSFORM] = 'translate3d(-9999px,-9999px,0)';
              self.node.style.cssText += ' height: 0px; width: 0px;';
              ionic.Utils.disconnectScope(self.scope);
              containerNode.appendChild(self.node);
              self.images = clone[0].getElementsByTagName('img');
            });
          }
          function VerticalViewType() {
            this.getItemPrimarySize = heightGetter;
            this.getItemSecondarySize = widthGetter;
            this.getScrollValue = function() {
              return Math.max(0, Math.min(scrollView.__scrollTop - repeaterBeforeSize, scrollView.__maxScrollTop - repeaterBeforeSize - repeaterAfterSize));
            };
            this.refreshDirection = function() {
              this.scrollPrimarySize = scrollView.__clientHeight;
              this.scrollSecondarySize = scrollView.__clientWidth;
              this.estimatedPrimarySize = estimatedHeight;
              this.estimatedSecondarySize = estimatedWidth;
              this.estimatedItemsAcross = isGridView && Math.floor(scrollView.__clientWidth / estimatedWidth) || 1;
            };
          }
          function HorizontalViewType() {
            this.getItemPrimarySize = widthGetter;
            this.getItemSecondarySize = heightGetter;
            this.getScrollValue = function() {
              return Math.max(0, Math.min(scrollView.__scrollLeft - repeaterBeforeSize, scrollView.__maxScrollLeft - repeaterBeforeSize - repeaterAfterSize));
            };
            this.refreshDirection = function() {
              this.scrollPrimarySize = scrollView.__clientWidth;
              this.scrollSecondarySize = scrollView.__clientHeight;
              this.estimatedPrimarySize = estimatedWidth;
              this.estimatedSecondarySize = estimatedHeight;
              this.estimatedItemsAcross = isGridView && Math.floor(scrollView.__clientHeight / estimatedHeight) || 1;
            };
          }
          function GridViewType() {
            this.getEstimatedSecondaryPos = function(index) {
              return (index % this.estimatedItemsAcross) * this.estimatedSecondarySize;
            };
            this.getEstimatedPrimaryPos = function(index) {
              return Math.floor(index / this.estimatedItemsAcross) * this.estimatedPrimarySize;
            };
            this.getEstimatedIndex = function(scrollValue) {
              return Math.floor(scrollValue / this.estimatedPrimarySize) * this.estimatedItemsAcross;
            };
          }
          function ListViewType() {
            this.getEstimatedSecondaryPos = function() {
              return 0;
            };
            this.getEstimatedPrimaryPos = function(index) {
              return index * this.estimatedPrimarySize;
            };
            this.getEstimatedIndex = function(scrollValue) {
              return Math.floor((scrollValue) / this.estimatedPrimarySize);
            };
          }
          function StaticViewType() {
            this.getContentSize = function() {
              return this.getEstimatedPrimaryPos(data.length - 1) + this.estimatedPrimarySize + repeaterBeforeSize + repeaterAfterSize;
            };
            var dim = {};
            this.getDimensions = function(index) {
              dim.primaryPos = this.getEstimatedPrimaryPos(index);
              dim.secondaryPos = this.getEstimatedSecondaryPos(index);
              dim.primarySize = this.estimatedPrimarySize;
              dim.secondarySize = this.estimatedSecondarySize;
              return dim;
            };
            this.updateRenderRange = function(scrollValue, scrollValueEnd) {
              renderStartIndex = Math.max(0, this.getEstimatedIndex(scrollValue));
              renderEndIndex = Math.min(data.length - 1, this.getEstimatedIndex(scrollValueEnd) + this.estimatedItemsAcross - 1);
              renderBeforeBoundary = Math.max(0, this.getEstimatedPrimaryPos(renderStartIndex));
              renderAfterBoundary = this.getEstimatedPrimaryPos(renderEndIndex) + this.estimatedPrimarySize;
            };
          }
          function DynamicViewType() {
            var self = this;
            var debouncedScrollViewSetDimensions = ionic.debounce(scrollViewSetDimensions, 25, true);
            var calculateDimensions = isGridView ? calculateDimensionsGrid : calculateDimensionsList;
            var dimensionsIndex;
            var dimensions = [];
            function calculateDimensionsList(toIndex) {
              var i,
                  prevDimension,
                  dim;
              for (i = Math.max(0, dimensionsIndex); i <= toIndex && (dim = dimensions[i]); i++) {
                prevDimension = dimensions[i - 1] || EMPTY_DIMENSION;
                dim.primarySize = self.getItemPrimarySize(i, data[i]);
                dim.secondarySize = self.scrollSecondarySize;
                dim.primaryPos = prevDimension.primaryPos + prevDimension.primarySize;
                dim.secondaryPos = 0;
              }
            }
            function calculateDimensionsGrid(toIndex) {
              var i,
                  prevDimension,
                  dim;
              for (i = Math.max(dimensionsIndex, 0); i <= toIndex && (dim = dimensions[i]); i++) {
                prevDimension = dimensions[i - 1] || EMPTY_DIMENSION;
                dim.secondarySize = Math.min(self.getItemSecondarySize(i, data[i]), self.scrollSecondarySize);
                dim.secondaryPos = prevDimension.secondaryPos + prevDimension.secondarySize;
                if (i === 0 || dim.secondaryPos + dim.secondarySize > self.scrollSecondarySize) {
                  dim.secondaryPos = 0;
                  dim.primarySize = self.getItemPrimarySize(i, data[i]);
                  dim.primaryPos = prevDimension.primaryPos + prevDimension.rowPrimarySize;
                  dim.rowStartIndex = i;
                  dim.rowPrimarySize = dim.primarySize;
                } else {
                  dim.primarySize = self.getItemPrimarySize(i, data[i]);
                  dim.primaryPos = prevDimension.primaryPos;
                  dim.rowStartIndex = prevDimension.rowStartIndex;
                  dimensions[dim.rowStartIndex].rowPrimarySize = dim.rowPrimarySize = Math.max(dimensions[dim.rowStartIndex].rowPrimarySize, dim.primarySize);
                  dim.rowPrimarySize = Math.max(dim.primarySize, dim.rowPrimarySize);
                }
              }
            }
            this.getContentSize = function() {
              var dim = dimensions[dimensionsIndex] || EMPTY_DIMENSION;
              return ((dim.primaryPos + dim.primarySize) || 0) + this.getEstimatedPrimaryPos(data.length - dimensionsIndex - 1) + repeaterBeforeSize + repeaterAfterSize;
            };
            this.onDestroy = function() {
              dimensions.length = 0;
            };
            this.onRefreshData = function() {
              var i;
              var ii;
              for (i = dimensions.length, ii = data.length; i < ii; i++) {
                dimensions.push({});
              }
              dimensionsIndex = -1;
            };
            this.onRefreshLayout = function() {
              dimensionsIndex = -1;
            };
            this.getDimensions = function(index) {
              index = Math.min(index, data.length - 1);
              if (dimensionsIndex < index) {
                if (index > data.length * 0.9) {
                  calculateDimensions(data.length - 1);
                  dimensionsIndex = data.length - 1;
                  scrollViewSetDimensions();
                } else {
                  calculateDimensions(index);
                  dimensionsIndex = index;
                  debouncedScrollViewSetDimensions();
                }
              }
              return dimensions[index];
            };
            var oldRenderStartIndex = -1;
            var oldScrollValue = -1;
            this.updateRenderRange = function(scrollValue, scrollValueEnd) {
              var i;
              var len;
              var dim;
              this.getDimensions(this.getEstimatedIndex(scrollValueEnd) * 2);
              if (oldRenderStartIndex === -1 || scrollValue === 0) {
                i = 0;
              } else if (scrollValue >= oldScrollValue) {
                for (i = oldRenderStartIndex, len = data.length; i < len; i++) {
                  if ((dim = this.getDimensions(i)) && dim.primaryPos + dim.rowPrimarySize >= scrollValue) {
                    break;
                  }
                }
              } else {
                for (i = oldRenderStartIndex; i >= 0; i--) {
                  if ((dim = this.getDimensions(i)) && dim.primaryPos <= scrollValue) {
                    i = isGridView ? dim.rowStartIndex : i;
                    break;
                  }
                }
              }
              renderStartIndex = Math.min(Math.max(0, i), data.length - 1);
              renderBeforeBoundary = renderStartIndex !== -1 ? this.getDimensions(renderStartIndex).primaryPos : -1;
              var lastRowDim;
              for (i = renderStartIndex + 1, len = data.length; i < len; i++) {
                if ((dim = this.getDimensions(i)) && dim.primaryPos + dim.rowPrimarySize > scrollValueEnd) {
                  if (isGridView) {
                    lastRowDim = dim;
                    while (i < len - 1 && (dim = this.getDimensions(i + 1)).primaryPos === lastRowDim.primaryPos) {
                      i++;
                    }
                  }
                  break;
                }
              }
              renderEndIndex = Math.min(i, data.length - 1);
              renderAfterBoundary = renderEndIndex !== -1 ? ((dim = this.getDimensions(renderEndIndex)).primaryPos + (dim.rowPrimarySize || dim.primarySize)) : -1;
              oldScrollValue = scrollValue;
              oldRenderStartIndex = renderStartIndex;
            };
          }
        };
      }
      IonicModule.directive('ionContent', ['$timeout', '$controller', '$ionicBind', '$ionicConfig', function($timeout, $controller, $ionicBind, $ionicConfig) {
        return {
          restrict: 'E',
          require: '^?ionNavView',
          scope: true,
          priority: 800,
          compile: function(element, attr) {
            var innerElement;
            var scrollCtrl;
            element.addClass('scroll-content ionic-scroll');
            if (attr.scroll != 'false') {
              innerElement = jqLite('<div class="scroll"></div>');
              innerElement.append(element.contents());
              element.append(innerElement);
            } else {
              element.addClass('scroll-content-false');
            }
            var nativeScrolling = attr.overflowScroll === "true" || !$ionicConfig.scrolling.jsScrolling();
            if (nativeScrolling) {
              nativeScrolling = !element[0].querySelector('[collection-repeat]');
            }
            return {pre: prelink};
            function prelink($scope, $element, $attr) {
              var parentScope = $scope.$parent;
              $scope.$watch(function() {
                return (parentScope.$hasHeader ? ' has-header' : '') + (parentScope.$hasSubheader ? ' has-subheader' : '') + (parentScope.$hasFooter ? ' has-footer' : '') + (parentScope.$hasSubfooter ? ' has-subfooter' : '') + (parentScope.$hasTabs ? ' has-tabs' : '') + (parentScope.$hasTabsTop ? ' has-tabs-top' : '');
              }, function(className, oldClassName) {
                $element.removeClass(oldClassName);
                $element.addClass(className);
              });
              $scope.$hasHeader = $scope.$hasSubheader = $scope.$hasFooter = $scope.$hasSubfooter = $scope.$hasTabs = $scope.$hasTabsTop = false;
              $ionicBind($scope, $attr, {
                $onScroll: '&onScroll',
                $onScrollComplete: '&onScrollComplete',
                hasBouncing: '@',
                padding: '@',
                direction: '@',
                scrollbarX: '@',
                scrollbarY: '@',
                startX: '@',
                startY: '@',
                scrollEventInterval: '@'
              });
              $scope.direction = $scope.direction || 'y';
              if (isDefined($attr.padding)) {
                $scope.$watch($attr.padding, function(newVal) {
                  (innerElement || $element).toggleClass('padding', !!newVal);
                });
              }
              if ($attr.scroll === "false") {} else {
                var scrollViewOptions = {};
                if (nativeScrolling) {
                  $element.addClass('overflow-scroll');
                  scrollViewOptions = {
                    el: $element[0],
                    delegateHandle: attr.delegateHandle,
                    startX: $scope.$eval($scope.startX) || 0,
                    startY: $scope.$eval($scope.startY) || 0,
                    nativeScrolling: true
                  };
                } else {
                  scrollViewOptions = {
                    el: $element[0],
                    delegateHandle: attr.delegateHandle,
                    locking: (attr.locking || 'true') === 'true',
                    bouncing: $scope.$eval($scope.hasBouncing),
                    startX: $scope.$eval($scope.startX) || 0,
                    startY: $scope.$eval($scope.startY) || 0,
                    scrollbarX: $scope.$eval($scope.scrollbarX) !== false,
                    scrollbarY: $scope.$eval($scope.scrollbarY) !== false,
                    scrollingX: $scope.direction.indexOf('x') >= 0,
                    scrollingY: $scope.direction.indexOf('y') >= 0,
                    scrollEventInterval: parseInt($scope.scrollEventInterval, 10) || 10,
                    scrollingComplete: onScrollComplete
                  };
                }
                scrollCtrl = $controller('$ionicScroll', {
                  $scope: $scope,
                  scrollViewOptions: scrollViewOptions
                });
                $scope.$on('$destroy', function() {
                  if (scrollViewOptions) {
                    scrollViewOptions.scrollingComplete = noop;
                    delete scrollViewOptions.el;
                  }
                  innerElement = null;
                  $element = null;
                  attr.$$element = null;
                });
              }
              function onScrollComplete() {
                $scope.$onScrollComplete({
                  scrollTop: scrollCtrl.scrollView.__scrollTop,
                  scrollLeft: scrollCtrl.scrollView.__scrollLeft
                });
              }
            }
          }
        };
      }]);
      IonicModule.directive('exposeAsideWhen', ['$window', function($window) {
        return {
          restrict: 'A',
          require: '^ionSideMenus',
          link: function($scope, $element, $attr, sideMenuCtrl) {
            function checkAsideExpose() {
              var mq = $attr.exposeAsideWhen == 'large' ? '(min-width:768px)' : $attr.exposeAsideWhen;
              sideMenuCtrl.exposeAside($window.matchMedia(mq).matches);
              sideMenuCtrl.activeAsideResizing(false);
            }
            function onResize() {
              sideMenuCtrl.activeAsideResizing(true);
              debouncedCheck();
            }
            var debouncedCheck = ionic.debounce(function() {
              $scope.$apply(checkAsideExpose);
            }, 300, false);
            $scope.$evalAsync(checkAsideExpose);
            ionic.on('resize', onResize, $window);
            $scope.$on('$destroy', function() {
              ionic.off('resize', onResize, $window);
            });
          }
        };
      }]);
      var GESTURE_DIRECTIVES = 'onHold onTap onDoubleTap onTouch onRelease onDragStart onDrag onDragEnd onDragUp onDragRight onDragDown onDragLeft onSwipe onSwipeUp onSwipeRight onSwipeDown onSwipeLeft'.split(' ');
      GESTURE_DIRECTIVES.forEach(function(name) {
        IonicModule.directive(name, gestureDirective(name));
      });
      function gestureDirective(directiveName) {
        return ['$ionicGesture', '$parse', function($ionicGesture, $parse) {
          var eventType = directiveName.substr(2).toLowerCase();
          return function(scope, element, attr) {
            var fn = $parse(attr[directiveName]);
            var listener = function(ev) {
              scope.$apply(function() {
                fn(scope, {$event: ev});
              });
            };
            var gesture = $ionicGesture.on(eventType, listener, element);
            scope.$on('$destroy', function() {
              $ionicGesture.off(gesture, eventType, listener);
            });
          };
        }];
      }
      IonicModule.directive('ionHeaderBar', tapScrollToTopDirective()).directive('ionHeaderBar', headerFooterBarDirective(true)).directive('ionFooterBar', headerFooterBarDirective(false));
      function tapScrollToTopDirective() {
        return ['$ionicScrollDelegate', function($ionicScrollDelegate) {
          return {
            restrict: 'E',
            link: function($scope, $element, $attr) {
              if ($attr.noTapScroll == 'true') {
                return ;
              }
              ionic.on('tap', onTap, $element[0]);
              $scope.$on('$destroy', function() {
                ionic.off('tap', onTap, $element[0]);
              });
              function onTap(e) {
                var depth = 3;
                var current = e.target;
                while (depth-- && current) {
                  if (current.classList.contains('button') || current.tagName.match(/input|textarea|select/i) || current.isContentEditable) {
                    return ;
                  }
                  current = current.parentNode;
                }
                var touch = e.gesture && e.gesture.touches[0] || e.detail.touches[0];
                var bounds = $element[0].getBoundingClientRect();
                if (ionic.DomUtil.rectContains(touch.pageX, touch.pageY, bounds.left, bounds.top - 20, bounds.left + bounds.width, bounds.top + bounds.height)) {
                  $ionicScrollDelegate.scrollTop(true);
                }
              }
            }
          };
        }];
      }
      function headerFooterBarDirective(isHeader) {
        return ['$document', '$timeout', function($document, $timeout) {
          return {
            restrict: 'E',
            controller: '$ionicHeaderBar',
            compile: function(tElement) {
              tElement.addClass(isHeader ? 'bar bar-header' : 'bar bar-footer');
              $timeout(function() {
                if (isHeader && $document[0].getElementsByClassName('tabs-top').length)
                  tElement.addClass('has-tabs-top');
              });
              return {pre: prelink};
              function prelink($scope, $element, $attr, ctrl) {
                if (isHeader) {
                  $scope.$watch(function() {
                    return $element[0].className;
                  }, function(value) {
                    var isShown = value.indexOf('ng-hide') === -1;
                    var isSubheader = value.indexOf('bar-subheader') !== -1;
                    $scope.$hasHeader = isShown && !isSubheader;
                    $scope.$hasSubheader = isShown && isSubheader;
                    $scope.$emit('$ionicSubheader', $scope.$hasSubheader);
                  });
                  $scope.$on('$destroy', function() {
                    delete $scope.$hasHeader;
                    delete $scope.$hasSubheader;
                  });
                  ctrl.align();
                  $scope.$on('$ionicHeader.align', function() {
                    ionic.requestAnimationFrame(function() {
                      ctrl.align();
                    });
                  });
                } else {
                  $scope.$watch(function() {
                    return $element[0].className;
                  }, function(value) {
                    var isShown = value.indexOf('ng-hide') === -1;
                    var isSubfooter = value.indexOf('bar-subfooter') !== -1;
                    $scope.$hasFooter = isShown && !isSubfooter;
                    $scope.$hasSubfooter = isShown && isSubfooter;
                  });
                  $scope.$on('$destroy', function() {
                    delete $scope.$hasFooter;
                    delete $scope.$hasSubfooter;
                  });
                  $scope.$watch('$hasTabs', function(val) {
                    $element.toggleClass('has-tabs', !!val);
                  });
                }
              }
            }
          };
        }];
      }
      IonicModule.directive('ionInfiniteScroll', ['$timeout', function($timeout) {
        return {
          restrict: 'E',
          require: ['?^$ionicScroll', 'ionInfiniteScroll'],
          template: function($element, $attrs) {
            if ($attrs.icon)
              return '<i class="icon {{icon()}} icon-refreshing {{scrollingType}}"></i>';
            return '<ion-spinner icon="{{spinner()}}"></ion-spinner>';
          },
          scope: true,
          controller: '$ionInfiniteScroll',
          link: function($scope, $element, $attrs, ctrls) {
            var infiniteScrollCtrl = ctrls[1];
            var scrollCtrl = infiniteScrollCtrl.scrollCtrl = ctrls[0];
            var jsScrolling = infiniteScrollCtrl.jsScrolling = !scrollCtrl.isNative();
            if (jsScrolling) {
              infiniteScrollCtrl.scrollView = scrollCtrl.scrollView;
              $scope.scrollingType = 'js-scrolling';
              scrollCtrl.$element.on('scroll', infiniteScrollCtrl.checkBounds);
            } else {
              var scrollEl = ionic.DomUtil.getParentOrSelfWithClass($element[0].parentNode, 'overflow-scroll');
              infiniteScrollCtrl.scrollEl = scrollEl;
              if (!scrollEl) {
                throw 'Infinite scroll must be used inside a scrollable div';
              }
              infiniteScrollCtrl.scrollEl.addEventListener('scroll', infiniteScrollCtrl.checkBounds);
            }
            var doImmediateCheck = isDefined($attrs.immediateCheck) ? $scope.$eval($attrs.immediateCheck) : true;
            if (doImmediateCheck) {
              $timeout(function() {
                infiniteScrollCtrl.checkBounds();
              });
            }
          }
        };
      }]);
      IonicModule.directive('ionItem', ['$$rAF', function($$rAF) {
        return {
          restrict: 'E',
          controller: ['$scope', '$element', function($scope, $element) {
            this.$scope = $scope;
            this.$element = $element;
          }],
          scope: true,
          compile: function($element, $attrs) {
            var isAnchor = isDefined($attrs.href) || isDefined($attrs.ngHref) || isDefined($attrs.uiSref);
            var isComplexItem = isAnchor || /ion-(delete|option|reorder)-button/i.test($element.html());
            if (isComplexItem) {
              var innerElement = jqLite(isAnchor ? '<a></a>' : '<div></div>');
              innerElement.addClass('item-content');
              if (isDefined($attrs.href) || isDefined($attrs.ngHref)) {
                innerElement.attr('ng-href', '{{$href()}}');
                if (isDefined($attrs.target)) {
                  innerElement.attr('target', '{{$target()}}');
                }
              }
              innerElement.append($element.contents());
              $element.addClass('item item-complex').append(innerElement);
            } else {
              $element.addClass('item');
            }
            return function link($scope, $element, $attrs) {
              $scope.$href = function() {
                return $attrs.href || $attrs.ngHref;
              };
              $scope.$target = function() {
                return $attrs.target;
              };
              var content = $element[0].querySelector('.item-content');
              if (content) {
                $scope.$on('$collectionRepeatLeave', function() {
                  if (content && content.$$ionicOptionsOpen) {
                    content.style[ionic.CSS.TRANSFORM] = '';
                    content.style[ionic.CSS.TRANSITION] = 'none';
                    $$rAF(function() {
                      content.style[ionic.CSS.TRANSITION] = '';
                    });
                    content.$$ionicOptionsOpen = false;
                  }
                });
              }
            };
          }
        };
      }]);
      var ITEM_TPL_DELETE_BUTTON = '<div class="item-left-edit item-delete enable-pointer-events">' + '</div>';
      IonicModule.directive('ionDeleteButton', function() {
        function stopPropagation(ev) {
          ev.stopPropagation();
        }
        return {
          restrict: 'E',
          require: ['^^ionItem', '^?ionList'],
          priority: Number.MAX_VALUE,
          compile: function($element, $attr) {
            $attr.$set('class', ($attr['class'] || '') + ' button icon button-icon', true);
            return function($scope, $element, $attr, ctrls) {
              var itemCtrl = ctrls[0];
              var listCtrl = ctrls[1];
              var container = jqLite(ITEM_TPL_DELETE_BUTTON);
              container.append($element);
              itemCtrl.$element.append(container).addClass('item-left-editable');
              $element.on('click', stopPropagation);
              init();
              $scope.$on('$ionic.reconnectScope', init);
              function init() {
                listCtrl = listCtrl || $element.controller('ionList');
                if (listCtrl && listCtrl.showDelete()) {
                  container.addClass('visible active');
                }
              }
            };
          }
        };
      });
      IonicModule.directive('itemFloatingLabel', function() {
        return {
          restrict: 'C',
          link: function(scope, element) {
            var el = element[0];
            var input = el.querySelector('input, textarea');
            var inputLabel = el.querySelector('.input-label');
            if (!input || !inputLabel)
              return ;
            var onInput = function() {
              if (input.value) {
                inputLabel.classList.add('has-input');
              } else {
                inputLabel.classList.remove('has-input');
              }
            };
            input.addEventListener('input', onInput);
            var ngModelCtrl = jqLite(input).controller('ngModel');
            if (ngModelCtrl) {
              ngModelCtrl.$render = function() {
                input.value = ngModelCtrl.$viewValue || '';
                onInput();
              };
            }
            scope.$on('$destroy', function() {
              input.removeEventListener('input', onInput);
            });
          }
        };
      });
      var ITEM_TPL_OPTION_BUTTONS = '<div class="item-options invisible">' + '</div>';
      IonicModule.directive('ionOptionButton', [function() {
        function stopPropagation(e) {
          e.stopPropagation();
        }
        return {
          restrict: 'E',
          require: '^ionItem',
          priority: Number.MAX_VALUE,
          compile: function($element, $attr) {
            $attr.$set('class', ($attr['class'] || '') + ' button', true);
            return function($scope, $element, $attr, itemCtrl) {
              if (!itemCtrl.optionsContainer) {
                itemCtrl.optionsContainer = jqLite(ITEM_TPL_OPTION_BUTTONS);
                itemCtrl.$element.append(itemCtrl.optionsContainer);
              }
              itemCtrl.optionsContainer.append($element);
              itemCtrl.$element.addClass('item-right-editable');
              $element.on('click', stopPropagation);
            };
          }
        };
      }]);
      var ITEM_TPL_REORDER_BUTTON = '<div data-prevent-scroll="true" class="item-right-edit item-reorder enable-pointer-events">' + '</div>';
      IonicModule.directive('ionReorderButton', ['$parse', function($parse) {
        return {
          restrict: 'E',
          require: ['^ionItem', '^?ionList'],
          priority: Number.MAX_VALUE,
          compile: function($element, $attr) {
            $attr.$set('class', ($attr['class'] || '') + ' button icon button-icon', true);
            $element[0].setAttribute('data-prevent-scroll', true);
            return function($scope, $element, $attr, ctrls) {
              var itemCtrl = ctrls[0];
              var listCtrl = ctrls[1];
              var onReorderFn = $parse($attr.onReorder);
              $scope.$onReorder = function(oldIndex, newIndex) {
                onReorderFn($scope, {
                  $fromIndex: oldIndex,
                  $toIndex: newIndex
                });
              };
              if (!$attr.ngClick && !$attr.onClick && !$attr.onclick) {
                $element[0].onclick = function(e) {
                  e.stopPropagation();
                  return false;
                };
              }
              var container = jqLite(ITEM_TPL_REORDER_BUTTON);
              container.append($element);
              itemCtrl.$element.append(container).addClass('item-right-editable');
              if (listCtrl && listCtrl.showReorder()) {
                container.addClass('visible active');
              }
            };
          }
        };
      }]);
      IonicModule.directive('keyboardAttach', function() {
        return function(scope, element) {
          ionic.on('native.keyboardshow', onShow, window);
          ionic.on('native.keyboardhide', onHide, window);
          ionic.on('native.showkeyboard', onShow, window);
          ionic.on('native.hidekeyboard', onHide, window);
          var scrollCtrl;
          function onShow(e) {
            if (ionic.Platform.isAndroid() && !ionic.Platform.isFullScreen) {
              return ;
            }
            var keyboardHeight = e.keyboardHeight || e.detail.keyboardHeight;
            element.css('bottom', keyboardHeight + "px");
            scrollCtrl = element.controller('$ionicScroll');
            if (scrollCtrl) {
              scrollCtrl.scrollView.__container.style.bottom = keyboardHeight + keyboardAttachGetClientHeight(element[0]) + "px";
            }
          }
          function onHide() {
            if (ionic.Platform.isAndroid() && !ionic.Platform.isFullScreen) {
              return ;
            }
            element.css('bottom', '');
            if (scrollCtrl) {
              scrollCtrl.scrollView.__container.style.bottom = '';
            }
          }
          scope.$on('$destroy', function() {
            ionic.off('native.keyboardshow', onShow, window);
            ionic.off('native.keyboardhide', onHide, window);
            ionic.off('native.showkeyboard', onShow, window);
            ionic.off('native.hidekeyboard', onHide, window);
          });
        };
      });
      function keyboardAttachGetClientHeight(element) {
        return element.clientHeight;
      }
      IonicModule.directive('ionList', ['$timeout', function($timeout) {
        return {
          restrict: 'E',
          require: ['ionList', '^?$ionicScroll'],
          controller: '$ionicList',
          compile: function($element, $attr) {
            var listEl = jqLite('<div class="list">').append($element.contents()).addClass($attr.type);
            $element.append(listEl);
            return function($scope, $element, $attrs, ctrls) {
              var listCtrl = ctrls[0];
              var scrollCtrl = ctrls[1];
              $timeout(init);
              function init() {
                var listView = listCtrl.listView = new ionic.views.ListView({
                  el: $element[0],
                  listEl: $element.children()[0],
                  scrollEl: scrollCtrl && scrollCtrl.element,
                  scrollView: scrollCtrl && scrollCtrl.scrollView,
                  onReorder: function(el, oldIndex, newIndex) {
                    var itemScope = jqLite(el).scope();
                    if (itemScope && itemScope.$onReorder) {
                      $timeout(function() {
                        itemScope.$onReorder(oldIndex, newIndex);
                      });
                    }
                  },
                  canSwipe: function() {
                    return listCtrl.canSwipeItems();
                  }
                });
                $scope.$on('$destroy', function() {
                  if (listView) {
                    listView.deregister && listView.deregister();
                    listView = null;
                  }
                });
                if (isDefined($attr.canSwipe)) {
                  $scope.$watch('!!(' + $attr.canSwipe + ')', function(value) {
                    listCtrl.canSwipeItems(value);
                  });
                }
                if (isDefined($attr.showDelete)) {
                  $scope.$watch('!!(' + $attr.showDelete + ')', function(value) {
                    listCtrl.showDelete(value);
                  });
                }
                if (isDefined($attr.showReorder)) {
                  $scope.$watch('!!(' + $attr.showReorder + ')', function(value) {
                    listCtrl.showReorder(value);
                  });
                }
                $scope.$watch(function() {
                  return listCtrl.showDelete();
                }, function(isShown, wasShown) {
                  if (!isShown && !wasShown) {
                    return ;
                  }
                  if (isShown)
                    listCtrl.closeOptionButtons();
                  listCtrl.canSwipeItems(!isShown);
                  $element.children().toggleClass('list-left-editing', isShown);
                  $element.toggleClass('disable-pointer-events', isShown);
                  var deleteButton = jqLite($element[0].getElementsByClassName('item-delete'));
                  setButtonShown(deleteButton, listCtrl.showDelete);
                });
                $scope.$watch(function() {
                  return listCtrl.showReorder();
                }, function(isShown, wasShown) {
                  if (!isShown && !wasShown) {
                    return ;
                  }
                  if (isShown)
                    listCtrl.closeOptionButtons();
                  listCtrl.canSwipeItems(!isShown);
                  $element.children().toggleClass('list-right-editing', isShown);
                  $element.toggleClass('disable-pointer-events', isShown);
                  var reorderButton = jqLite($element[0].getElementsByClassName('item-reorder'));
                  setButtonShown(reorderButton, listCtrl.showReorder);
                });
                function setButtonShown(el, shown) {
                  shown() && el.addClass('visible') || el.removeClass('active');
                  ionic.requestAnimationFrame(function() {
                    shown() && el.addClass('active') || el.removeClass('visible');
                  });
                }
              }
            };
          }
        };
      }]);
      IonicModule.directive('menuClose', ['$ionicHistory', '$timeout', function($ionicHistory, $timeout) {
        return {
          restrict: 'AC',
          link: function($scope, $element) {
            $element.bind('click', function() {
              var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');
              if (sideMenuCtrl) {
                $ionicHistory.nextViewOptions({
                  historyRoot: true,
                  disableAnimate: true,
                  expire: 300
                });
                $timeout(function() {
                  $ionicHistory.nextViewOptions({
                    historyRoot: false,
                    disableAnimate: false
                  });
                }, 300);
                sideMenuCtrl.close();
              }
            });
          }
        };
      }]);
      IonicModule.directive('menuToggle', function() {
        return {
          restrict: 'AC',
          link: function($scope, $element, $attr) {
            $scope.$on('$ionicView.beforeEnter', function(ev, viewData) {
              if (viewData.enableBack) {
                var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');
                if (!sideMenuCtrl.enableMenuWithBackViews()) {
                  $element.addClass('hide');
                }
              } else {
                $element.removeClass('hide');
              }
            });
            $element.bind('click', function() {
              var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');
              sideMenuCtrl && sideMenuCtrl.toggle($attr.menuToggle);
            });
          }
        };
      });
      IonicModule.directive('ionModal', [function() {
        return {
          restrict: 'E',
          transclude: true,
          replace: true,
          controller: [function() {}],
          template: '<div class="modal-backdrop">' + '<div class="modal-backdrop-bg"></div>' + '<div class="modal-wrapper" ng-transclude></div>' + '</div>'
        };
      }]);
      IonicModule.directive('ionModalView', function() {
        return {
          restrict: 'E',
          compile: function(element) {
            element.addClass('modal');
          }
        };
      });
      IonicModule.directive('ionNavBackButton', ['$ionicConfig', '$document', function($ionicConfig, $document) {
        return {
          restrict: 'E',
          require: '^ionNavBar',
          compile: function(tElement, tAttrs) {
            var buttonEle = $document[0].createElement('button');
            for (var n in tAttrs.$attr) {
              buttonEle.setAttribute(tAttrs.$attr[n], tAttrs[n]);
            }
            if (!tAttrs.ngClick) {
              buttonEle.setAttribute('ng-click', '$ionicGoBack()');
            }
            buttonEle.className = 'button back-button hide buttons ' + (tElement.attr('class') || '');
            buttonEle.innerHTML = tElement.html() || '';
            var childNode;
            var hasIcon = hasIconClass(tElement[0]);
            var hasInnerText;
            var hasButtonText;
            var hasPreviousTitle;
            for (var x = 0; x < tElement[0].childNodes.length; x++) {
              childNode = tElement[0].childNodes[x];
              if (childNode.nodeType === 1) {
                if (hasIconClass(childNode)) {
                  hasIcon = true;
                } else if (childNode.classList.contains('default-title')) {
                  hasButtonText = true;
                } else if (childNode.classList.contains('previous-title')) {
                  hasPreviousTitle = true;
                }
              } else if (!hasInnerText && childNode.nodeType === 3) {
                hasInnerText = !!childNode.nodeValue.trim();
              }
            }
            function hasIconClass(ele) {
              return /ion-|icon/.test(ele.className);
            }
            var defaultIcon = $ionicConfig.backButton.icon();
            if (!hasIcon && defaultIcon && defaultIcon !== 'none') {
              buttonEle.innerHTML = '<i class="icon ' + defaultIcon + '"></i> ' + buttonEle.innerHTML;
              buttonEle.className += ' button-clear';
            }
            if (!hasInnerText) {
              var buttonTextEle = $document[0].createElement('span');
              buttonTextEle.className = 'back-text';
              if (!hasButtonText && $ionicConfig.backButton.text()) {
                buttonTextEle.innerHTML += '<span class="default-title">' + $ionicConfig.backButton.text() + '</span>';
              }
              if (!hasPreviousTitle && $ionicConfig.backButton.previousTitleText()) {
                buttonTextEle.innerHTML += '<span class="previous-title"></span>';
              }
              buttonEle.appendChild(buttonTextEle);
            }
            tElement.attr('class', 'hide');
            tElement.empty();
            return {pre: function($scope, $element, $attr, navBarCtrl) {
                navBarCtrl.navElement('backButton', buttonEle.outerHTML);
                buttonEle = null;
              }};
          }
        };
      }]);
      IonicModule.directive('ionNavBar', function() {
        return {
          restrict: 'E',
          controller: '$ionicNavBar',
          scope: true,
          link: function($scope, $element, $attr, ctrl) {
            ctrl.init();
          }
        };
      });
      IonicModule.directive('ionNavButtons', ['$document', function($document) {
        return {
          require: '^ionNavBar',
          restrict: 'E',
          compile: function(tElement, tAttrs) {
            var side = 'left';
            if (/^primary|secondary|right$/i.test(tAttrs.side || '')) {
              side = tAttrs.side.toLowerCase();
            }
            var spanEle = $document[0].createElement('span');
            spanEle.className = side + '-buttons';
            spanEle.innerHTML = tElement.html();
            var navElementType = side + 'Buttons';
            tElement.attr('class', 'hide');
            tElement.empty();
            return {pre: function($scope, $element, $attrs, navBarCtrl) {
                var parentViewCtrl = $element.parent().data('$ionViewController');
                if (parentViewCtrl) {
                  parentViewCtrl.navElement(navElementType, spanEle.outerHTML);
                } else {
                  navBarCtrl.navElement(navElementType, spanEle.outerHTML);
                }
                spanEle = null;
              }};
          }
        };
      }]);
      IonicModule.directive('navDirection', ['$ionicViewSwitcher', function($ionicViewSwitcher) {
        return {
          restrict: 'A',
          priority: 1000,
          link: function($scope, $element, $attr) {
            $element.bind('click', function() {
              $ionicViewSwitcher.nextDirection($attr.navDirection);
            });
          }
        };
      }]);
      IonicModule.directive('ionNavTitle', ['$document', function($document) {
        return {
          require: '^ionNavBar',
          restrict: 'E',
          compile: function(tElement, tAttrs) {
            var navElementType = 'title';
            var spanEle = $document[0].createElement('span');
            for (var n in tAttrs.$attr) {
              spanEle.setAttribute(tAttrs.$attr[n], tAttrs[n]);
            }
            spanEle.classList.add('nav-bar-title');
            spanEle.innerHTML = tElement.html();
            tElement.attr('class', 'hide');
            tElement.empty();
            return {pre: function($scope, $element, $attrs, navBarCtrl) {
                var parentViewCtrl = $element.parent().data('$ionViewController');
                if (parentViewCtrl) {
                  parentViewCtrl.navElement(navElementType, spanEle.outerHTML);
                } else {
                  navBarCtrl.navElement(navElementType, spanEle.outerHTML);
                }
                spanEle = null;
              }};
          }
        };
      }]);
      IonicModule.directive('navTransition', ['$ionicViewSwitcher', function($ionicViewSwitcher) {
        return {
          restrict: 'A',
          priority: 1000,
          link: function($scope, $element, $attr) {
            $element.bind('click', function() {
              $ionicViewSwitcher.nextTransition($attr.navTransition);
            });
          }
        };
      }]);
      IonicModule.directive('ionNavView', ['$state', '$ionicConfig', function($state, $ionicConfig) {
        return {
          restrict: 'E',
          terminal: true,
          priority: 2000,
          transclude: true,
          controller: '$ionicNavView',
          compile: function(tElement, tAttrs, transclude) {
            tElement.addClass('view-container');
            ionic.DomUtil.cachedAttr(tElement, 'nav-view-transition', $ionicConfig.views.transition());
            return function($scope, $element, $attr, navViewCtrl) {
              var latestLocals;
              transclude($scope, function(clone) {
                $element.append(clone);
              });
              var viewData = navViewCtrl.init();
              $scope.$on('$stateChangeSuccess', function() {
                updateView(false);
              });
              $scope.$on('$viewContentLoading', function() {
                updateView(false);
              });
              updateView(true);
              function updateView(firstTime) {
                var viewLocals = $state.$current && $state.$current.locals[viewData.name];
                if (!viewLocals || (!firstTime && viewLocals === latestLocals))
                  return ;
                latestLocals = viewLocals;
                viewData.state = viewLocals.$$state;
                navViewCtrl.register(viewLocals);
              }
            };
          }
        };
      }]);
      IonicModule.config(['$provide', function($provide) {
        $provide.decorator('ngClickDirective', ['$delegate', function($delegate) {
          $delegate.shift();
          return $delegate;
        }]);
      }]).factory('$ionicNgClick', ['$parse', function($parse) {
        return function(scope, element, clickExpr) {
          var clickHandler = angular.isFunction(clickExpr) ? clickExpr : $parse(clickExpr);
          element.on('click', function(event) {
            scope.$apply(function() {
              clickHandler(scope, {$event: (event)});
            });
          });
          element.onclick = noop;
        };
      }]).directive('ngClick', ['$ionicNgClick', function($ionicNgClick) {
        return function(scope, element, attr) {
          $ionicNgClick(scope, element, attr.ngClick);
        };
      }]).directive('ionStopEvent', function() {
        return {
          restrict: 'A',
          link: function(scope, element, attr) {
            element.bind(attr.ionStopEvent, eventStopPropagation);
          }
        };
      });
      function eventStopPropagation(e) {
        e.stopPropagation();
      }
      IonicModule.directive('ionPane', function() {
        return {
          restrict: 'E',
          link: function(scope, element) {
            element.addClass('pane');
          }
        };
      });
      IonicModule.directive('ionPopover', [function() {
        return {
          restrict: 'E',
          transclude: true,
          replace: true,
          controller: [function() {}],
          template: '<div class="popover-backdrop">' + '<div class="popover-wrapper" ng-transclude></div>' + '</div>'
        };
      }]);
      IonicModule.directive('ionPopoverView', function() {
        return {
          restrict: 'E',
          compile: function(element) {
            element.append(jqLite('<div class="popover-arrow">'));
            element.addClass('popover');
          }
        };
      });
      IonicModule.directive('ionRadio', function() {
        return {
          restrict: 'E',
          replace: true,
          require: '?ngModel',
          transclude: true,
          template: '<label class="item item-radio">' + '<input type="radio" name="radio-group">' + '<div class="item-content disable-pointer-events" ng-transclude></div>' + '<i class="radio-icon disable-pointer-events icon ion-checkmark"></i>' + '</label>',
          compile: function(element, attr) {
            if (attr.icon) {
              element.children().eq(2).removeClass('ion-checkmark').addClass(attr.icon);
            }
            var input = element.find('input');
            forEach({
              'name': attr.name,
              'value': attr.value,
              'disabled': attr.disabled,
              'ng-value': attr.ngValue,
              'ng-model': attr.ngModel,
              'ng-disabled': attr.ngDisabled,
              'ng-change': attr.ngChange,
              'ng-required': attr.ngRequired,
              'required': attr.required
            }, function(value, name) {
              if (isDefined(value)) {
                input.attr(name, value);
              }
            });
            return function(scope, element, attr) {
              scope.getValue = function() {
                return scope.ngValue || attr.value;
              };
            };
          }
        };
      });
      IonicModule.directive('ionRefresher', [function() {
        return {
          restrict: 'E',
          replace: true,
          require: ['?^$ionicScroll', 'ionRefresher'],
          controller: '$ionicRefresher',
          template: '<div class="scroll-refresher invisible" collection-repeat-ignore>' + '<div class="ionic-refresher-content" ' + 'ng-class="{\'ionic-refresher-with-text\': pullingText || refreshingText}">' + '<div class="icon-pulling" ng-class="{\'pulling-rotation-disabled\':disablePullingRotation}">' + '<i class="icon {{pullingIcon}}"></i>' + '</div>' + '<div class="text-pulling" ng-bind-html="pullingText"></div>' + '<div class="icon-refreshing">' + '<ion-spinner ng-if="showSpinner" icon="{{spinner}}"></ion-spinner>' + '<i ng-if="showIcon" class="icon {{refreshingIcon}}"></i>' + '</div>' + '<div class="text-refreshing" ng-bind-html="refreshingText"></div>' + '</div>' + '</div>',
          link: function($scope, $element, $attrs, ctrls) {
            var scrollCtrl = ctrls[0],
                refresherCtrl = ctrls[1];
            if (!scrollCtrl || scrollCtrl.isNative()) {
              refresherCtrl.init();
            } else {
              $element[0].classList.add('js-scrolling');
              scrollCtrl._setRefresher($scope, $element[0], refresherCtrl.getRefresherDomMethods());
              $scope.$on('scroll.refreshComplete', function() {
                $scope.$evalAsync(function() {
                  scrollCtrl.scrollView.finishPullToRefresh();
                });
              });
            }
          }
        };
      }]);
      IonicModule.directive('ionScroll', ['$timeout', '$controller', '$ionicBind', function($timeout, $controller, $ionicBind) {
        return {
          restrict: 'E',
          scope: true,
          controller: function() {},
          compile: function(element) {
            element.addClass('scroll-view ionic-scroll');
            var innerElement = jqLite('<div class="scroll"></div>');
            innerElement.append(element.contents());
            element.append(innerElement);
            return {pre: prelink};
            function prelink($scope, $element, $attr) {
              $ionicBind($scope, $attr, {
                direction: '@',
                paging: '@',
                $onScroll: '&onScroll',
                scroll: '@',
                scrollbarX: '@',
                scrollbarY: '@',
                zooming: '@',
                minZoom: '@',
                maxZoom: '@'
              });
              $scope.direction = $scope.direction || 'y';
              if (isDefined($attr.padding)) {
                $scope.$watch($attr.padding, function(newVal) {
                  innerElement.toggleClass('padding', !!newVal);
                });
              }
              if ($scope.$eval($scope.paging) === true) {
                innerElement.addClass('scroll-paging');
              }
              if (!$scope.direction) {
                $scope.direction = 'y';
              }
              var isPaging = $scope.$eval($scope.paging) === true;
              var scrollViewOptions = {
                el: $element[0],
                delegateHandle: $attr.delegateHandle,
                locking: ($attr.locking || 'true') === 'true',
                bouncing: $scope.$eval($attr.hasBouncing),
                paging: isPaging,
                scrollbarX: $scope.$eval($scope.scrollbarX) !== false,
                scrollbarY: $scope.$eval($scope.scrollbarY) !== false,
                scrollingX: $scope.direction.indexOf('x') >= 0,
                scrollingY: $scope.direction.indexOf('y') >= 0,
                zooming: $scope.$eval($scope.zooming) === true,
                maxZoom: $scope.$eval($scope.maxZoom) || 3,
                minZoom: $scope.$eval($scope.minZoom) || 0.5,
                preventDefault: true
              };
              if (isPaging) {
                scrollViewOptions.speedMultiplier = 0.8;
                scrollViewOptions.bouncing = false;
              }
              $controller('$ionicScroll', {
                $scope: $scope,
                scrollViewOptions: scrollViewOptions
              });
            }
          }
        };
      }]);
      IonicModule.directive('ionSideMenu', function() {
        return {
          restrict: 'E',
          require: '^ionSideMenus',
          scope: true,
          compile: function(element, attr) {
            angular.isUndefined(attr.isEnabled) && attr.$set('isEnabled', 'true');
            angular.isUndefined(attr.width) && attr.$set('width', '275');
            element.addClass('menu menu-' + attr.side);
            return function($scope, $element, $attr, sideMenuCtrl) {
              $scope.side = $attr.side || 'left';
              var sideMenu = sideMenuCtrl[$scope.side] = new ionic.views.SideMenu({
                width: attr.width,
                el: $element[0],
                isEnabled: true
              });
              $scope.$watch($attr.width, function(val) {
                var numberVal = +val;
                if (numberVal && numberVal == val) {
                  sideMenu.setWidth(+val);
                }
              });
              $scope.$watch($attr.isEnabled, function(val) {
                sideMenu.setIsEnabled(!!val);
              });
            };
          }
        };
      });
      IonicModule.directive('ionSideMenuContent', ['$timeout', '$ionicGesture', '$window', function($timeout, $ionicGesture, $window) {
        return {
          restrict: 'EA',
          require: '^ionSideMenus',
          scope: true,
          compile: function(element, attr) {
            element.addClass('menu-content pane');
            return {pre: prelink};
            function prelink($scope, $element, $attr, sideMenuCtrl) {
              var startCoord = null;
              var primaryScrollAxis = null;
              if (isDefined(attr.dragContent)) {
                $scope.$watch(attr.dragContent, function(value) {
                  sideMenuCtrl.canDragContent(value);
                });
              } else {
                sideMenuCtrl.canDragContent(true);
              }
              if (isDefined(attr.edgeDragThreshold)) {
                $scope.$watch(attr.edgeDragThreshold, function(value) {
                  sideMenuCtrl.edgeDragThreshold(value);
                });
              }
              function onContentTap(gestureEvt) {
                if (sideMenuCtrl.getOpenAmount() !== 0) {
                  sideMenuCtrl.close();
                  gestureEvt.gesture.srcEvent.preventDefault();
                  startCoord = null;
                  primaryScrollAxis = null;
                } else if (!startCoord) {
                  startCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);
                }
              }
              function onDragX(e) {
                if (!sideMenuCtrl.isDraggableTarget(e))
                  return ;
                if (getPrimaryScrollAxis(e) == 'x') {
                  sideMenuCtrl._handleDrag(e);
                  e.gesture.srcEvent.preventDefault();
                }
              }
              function onDragY(e) {
                if (getPrimaryScrollAxis(e) == 'x') {
                  e.gesture.srcEvent.preventDefault();
                }
              }
              function onDragRelease(e) {
                sideMenuCtrl._endDrag(e);
                startCoord = null;
                primaryScrollAxis = null;
              }
              function getPrimaryScrollAxis(gestureEvt) {
                if (primaryScrollAxis) {
                  return primaryScrollAxis;
                }
                if (gestureEvt && gestureEvt.gesture) {
                  if (!startCoord) {
                    startCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);
                  } else {
                    var endCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);
                    var xDistance = Math.abs(endCoord.x - startCoord.x);
                    var yDistance = Math.abs(endCoord.y - startCoord.y);
                    var scrollAxis = (xDistance < yDistance ? 'y' : 'x');
                    if (Math.max(xDistance, yDistance) > 30) {
                      primaryScrollAxis = scrollAxis;
                    }
                    return scrollAxis;
                  }
                }
                return 'y';
              }
              var content = {
                element: element[0],
                onDrag: function() {},
                endDrag: function() {},
                getTranslateX: function() {
                  return $scope.sideMenuContentTranslateX || 0;
                },
                setTranslateX: ionic.animationFrameThrottle(function(amount) {
                  var xTransform = content.offsetX + amount;
                  $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(' + xTransform + 'px,0,0)';
                  $timeout(function() {
                    $scope.sideMenuContentTranslateX = amount;
                  });
                }),
                setMarginLeft: ionic.animationFrameThrottle(function(amount) {
                  if (amount) {
                    amount = parseInt(amount, 10);
                    $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(' + amount + 'px,0,0)';
                    $element[0].style.width = ($window.innerWidth - amount) + 'px';
                    content.offsetX = amount;
                  } else {
                    $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(0,0,0)';
                    $element[0].style.width = '';
                    content.offsetX = 0;
                  }
                }),
                setMarginRight: ionic.animationFrameThrottle(function(amount) {
                  if (amount) {
                    amount = parseInt(amount, 10);
                    $element[0].style.width = ($window.innerWidth - amount) + 'px';
                    content.offsetX = amount;
                  } else {
                    $element[0].style.width = '';
                    content.offsetX = 0;
                  }
                  $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(0,0,0)';
                }),
                enableAnimation: function() {
                  $scope.animationEnabled = true;
                  $element[0].classList.add('menu-animated');
                },
                disableAnimation: function() {
                  $scope.animationEnabled = false;
                  $element[0].classList.remove('menu-animated');
                },
                offsetX: 0
              };
              sideMenuCtrl.setContent(content);
              var gestureOpts = {stop_browser_behavior: false};
              if (ionic.DomUtil.getParentOrSelfWithClass($element[0], 'overflow-scroll')) {
                gestureOpts.prevent_default_directions = ['left', 'right'];
              }
              var contentTapGesture = $ionicGesture.on('tap', onContentTap, $element, gestureOpts);
              var dragRightGesture = $ionicGesture.on('dragright', onDragX, $element, gestureOpts);
              var dragLeftGesture = $ionicGesture.on('dragleft', onDragX, $element, gestureOpts);
              var dragUpGesture = $ionicGesture.on('dragup', onDragY, $element, gestureOpts);
              var dragDownGesture = $ionicGesture.on('dragdown', onDragY, $element, gestureOpts);
              var releaseGesture = $ionicGesture.on('release', onDragRelease, $element, gestureOpts);
              $scope.$on('$destroy', function() {
                if (content) {
                  content.element = null;
                  content = null;
                }
                $ionicGesture.off(dragLeftGesture, 'dragleft', onDragX);
                $ionicGesture.off(dragRightGesture, 'dragright', onDragX);
                $ionicGesture.off(dragUpGesture, 'dragup', onDragY);
                $ionicGesture.off(dragDownGesture, 'dragdown', onDragY);
                $ionicGesture.off(releaseGesture, 'release', onDragRelease);
                $ionicGesture.off(contentTapGesture, 'tap', onContentTap);
              });
            }
          }
        };
      }]);
      IonicModule.directive('ionSideMenus', ['$ionicBody', function($ionicBody) {
        return {
          restrict: 'ECA',
          controller: '$ionicSideMenus',
          compile: function(element, attr) {
            attr.$set('class', (attr['class'] || '') + ' view');
            return {pre: prelink};
            function prelink($scope, $element, $attrs, ctrl) {
              ctrl.enableMenuWithBackViews($scope.$eval($attrs.enableMenuWithBackViews));
              $scope.$on('$ionicExposeAside', function(evt, isAsideExposed) {
                if (!$scope.$exposeAside)
                  $scope.$exposeAside = {};
                $scope.$exposeAside.active = isAsideExposed;
                $ionicBody.enableClass(isAsideExposed, 'aside-open');
              });
              $scope.$on('$ionicView.beforeEnter', function(ev, d) {
                if (d.historyId) {
                  $scope.$activeHistoryId = d.historyId;
                }
              });
              $scope.$on('$destroy', function() {
                $ionicBody.removeClass('menu-open', 'aside-open');
              });
            }
          }
        };
      }]);
      IonicModule.directive('ionSlideBox', ['$timeout', '$compile', '$ionicSlideBoxDelegate', '$ionicHistory', '$ionicScrollDelegate', function($timeout, $compile, $ionicSlideBoxDelegate, $ionicHistory, $ionicScrollDelegate) {
        return {
          restrict: 'E',
          replace: true,
          transclude: true,
          scope: {
            autoPlay: '=',
            doesContinue: '@',
            slideInterval: '@',
            showPager: '@',
            pagerClick: '&',
            disableScroll: '@',
            onSlideChanged: '&',
            activeSlide: '=?'
          },
          controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {
            var _this = this;
            var continuous = $scope.$eval($scope.doesContinue) === true;
            var shouldAutoPlay = isDefined($attrs.autoPlay) ? !!$scope.autoPlay : false;
            var slideInterval = shouldAutoPlay ? $scope.$eval($scope.slideInterval) || 4000 : 0;
            var slider = new ionic.views.Slider({
              el: $element[0],
              auto: slideInterval,
              continuous: continuous,
              startSlide: $scope.activeSlide,
              slidesChanged: function() {
                $scope.currentSlide = slider.currentIndex();
                $timeout(function() {});
              },
              callback: function(slideIndex) {
                $scope.currentSlide = slideIndex;
                $scope.onSlideChanged({
                  index: $scope.currentSlide,
                  $index: $scope.currentSlide
                });
                $scope.$parent.$broadcast('slideBox.slideChanged', slideIndex);
                $scope.activeSlide = slideIndex;
                $timeout(function() {});
              },
              onDrag: function() {
                freezeAllScrolls(true);
              },
              onDragEnd: function() {
                freezeAllScrolls(false);
              }
            });
            function freezeAllScrolls(shouldFreeze) {
              if (shouldFreeze && !_this.isScrollFreeze) {
                $ionicScrollDelegate.freezeAllScrolls(shouldFreeze);
              } else if (!shouldFreeze && _this.isScrollFreeze) {
                $ionicScrollDelegate.freezeAllScrolls(false);
              }
              _this.isScrollFreeze = shouldFreeze;
            }
            slider.enableSlide($scope.$eval($attrs.disableScroll) !== true);
            $scope.$watch('activeSlide', function(nv) {
              if (isDefined(nv)) {
                slider.slide(nv);
              }
            });
            $scope.$on('slideBox.nextSlide', function() {
              slider.next();
            });
            $scope.$on('slideBox.prevSlide', function() {
              slider.prev();
            });
            $scope.$on('slideBox.setSlide', function(e, index) {
              slider.slide(index);
            });
            this.__slider = slider;
            var deregisterInstance = $ionicSlideBoxDelegate._registerInstance(slider, $attrs.delegateHandle, function() {
              return $ionicHistory.isActiveScope($scope);
            });
            $scope.$on('$destroy', function() {
              deregisterInstance();
              slider.kill();
            });
            this.slidesCount = function() {
              return slider.slidesCount();
            };
            this.onPagerClick = function(index) {
              void 0;
              $scope.pagerClick({index: index});
            };
            $timeout(function() {
              slider.load();
            });
          }],
          template: '<div class="slider">' + '<div class="slider-slides" ng-transclude>' + '</div>' + '</div>',
          link: function($scope, $element, $attr) {
            if (!isDefined($attr.showPager)) {
              $scope.showPager = true;
              getPager().toggleClass('hide', !true);
            }
            $attr.$observe('showPager', function(show) {
              if (show === undefined)
                return ;
              show = $scope.$eval(show);
              getPager().toggleClass('hide', !show);
            });
            var pager;
            function getPager() {
              if (!pager) {
                var childScope = $scope.$new();
                pager = jqLite('<ion-pager></ion-pager>');
                $element.append(pager);
                pager = $compile(pager)(childScope);
              }
              return pager;
            }
          }
        };
      }]).directive('ionSlide', function() {
        return {
          restrict: 'E',
          require: '^ionSlideBox',
          compile: function(element) {
            element.addClass('slider-slide');
          }
        };
      }).directive('ionPager', function() {
        return {
          restrict: 'E',
          replace: true,
          require: '^ionSlideBox',
          template: '<div class="slider-pager"><span class="slider-pager-page" ng-repeat="slide in numSlides() track by $index" ng-class="{active: $index == currentSlide}" ng-click="pagerClick($index)"><i class="icon ion-record"></i></span></div>',
          link: function($scope, $element, $attr, slideBox) {
            var selectPage = function(index) {
              var children = $element[0].children;
              var length = children.length;
              for (var i = 0; i < length; i++) {
                if (i == index) {
                  children[i].classList.add('active');
                } else {
                  children[i].classList.remove('active');
                }
              }
            };
            $scope.pagerClick = function(index) {
              slideBox.onPagerClick(index);
            };
            $scope.numSlides = function() {
              return new Array(slideBox.slidesCount());
            };
            $scope.$watch('currentSlide', function(v) {
              selectPage(v);
            });
          }
        };
      });
      IonicModule.directive('ionSpinner', function() {
        return {
          restrict: 'E',
          controller: '$ionicSpinner',
          link: function($scope, $element, $attrs, ctrl) {
            var spinnerName = ctrl.init();
            $element.addClass('spinner spinner-' + spinnerName);
          }
        };
      });
      IonicModule.directive('ionTab', ['$compile', '$ionicConfig', '$ionicBind', '$ionicViewSwitcher', function($compile, $ionicConfig, $ionicBind, $ionicViewSwitcher) {
        function attrStr(k, v) {
          return isDefined(v) ? ' ' + k + '="' + v + '"' : '';
        }
        return {
          restrict: 'E',
          require: ['^ionTabs', 'ionTab'],
          controller: '$ionicTab',
          scope: true,
          compile: function(element, attr) {
            var tabNavTemplate = '<ion-tab-nav' + attrStr('ng-click', attr.ngClick) + attrStr('title', attr.title) + attrStr('icon', attr.icon) + attrStr('icon-on', attr.iconOn) + attrStr('icon-off', attr.iconOff) + attrStr('badge', attr.badge) + attrStr('badge-style', attr.badgeStyle) + attrStr('hidden', attr.hidden) + attrStr('disabled', attr.disabled) + attrStr('class', attr['class']) + '></ion-tab-nav>';
            var tabContentEle = document.createElement('div');
            for (var x = 0; x < element[0].children.length; x++) {
              tabContentEle.appendChild(element[0].children[x].cloneNode(true));
            }
            var childElementCount = tabContentEle.childElementCount;
            element.empty();
            var navViewName,
                isNavView;
            if (childElementCount) {
              if (tabContentEle.children[0].tagName === 'ION-NAV-VIEW') {
                navViewName = tabContentEle.children[0].getAttribute('name');
                tabContentEle.children[0].classList.add('view-container');
                isNavView = true;
              }
              if (childElementCount === 1) {
                tabContentEle = tabContentEle.children[0];
              }
              if (!isNavView)
                tabContentEle.classList.add('pane');
              tabContentEle.classList.add('tab-content');
            }
            return function link($scope, $element, $attr, ctrls) {
              var childScope;
              var childElement;
              var tabsCtrl = ctrls[0];
              var tabCtrl = ctrls[1];
              var isTabContentAttached = false;
              $scope.$tabSelected = false;
              $ionicBind($scope, $attr, {
                onSelect: '&',
                onDeselect: '&',
                title: '@',
                uiSref: '@',
                href: '@'
              });
              tabsCtrl.add($scope);
              $scope.$on('$destroy', function() {
                if (!$scope.$tabsDestroy) {
                  tabsCtrl.remove($scope);
                }
                tabNavElement.isolateScope().$destroy();
                tabNavElement.remove();
                tabNavElement = tabContentEle = childElement = null;
              });
              $element[0].removeAttribute('title');
              if (navViewName) {
                tabCtrl.navViewName = $scope.navViewName = navViewName;
              }
              $scope.$on('$stateChangeSuccess', selectIfMatchesState);
              selectIfMatchesState();
              function selectIfMatchesState() {
                if (tabCtrl.tabMatchesState()) {
                  tabsCtrl.select($scope, false);
                }
              }
              var tabNavElement = jqLite(tabNavTemplate);
              tabNavElement.data('$ionTabsController', tabsCtrl);
              tabNavElement.data('$ionTabController', tabCtrl);
              tabsCtrl.$tabsElement.append($compile(tabNavElement)($scope));
              function tabSelected(isSelected) {
                if (isSelected && childElementCount) {
                  if (!isTabContentAttached) {
                    childScope = $scope.$new();
                    childElement = jqLite(tabContentEle);
                    $ionicViewSwitcher.viewEleIsActive(childElement, true);
                    tabsCtrl.$element.append(childElement);
                    $compile(childElement)(childScope);
                    isTabContentAttached = true;
                  }
                  $ionicViewSwitcher.viewEleIsActive(childElement, true);
                } else if (isTabContentAttached && childElement) {
                  if ($ionicConfig.views.maxCache() > 0) {
                    $ionicViewSwitcher.viewEleIsActive(childElement, false);
                  } else {
                    destroyTab();
                  }
                }
              }
              function destroyTab() {
                childScope && childScope.$destroy();
                isTabContentAttached && childElement && childElement.remove();
                tabContentEle.innerHTML = '';
                isTabContentAttached = childScope = childElement = null;
              }
              $scope.$watch('$tabSelected', tabSelected);
              $scope.$on('$ionicView.afterEnter', function() {
                $ionicViewSwitcher.viewEleIsActive(childElement, $scope.$tabSelected);
              });
              $scope.$on('$ionicView.clearCache', function() {
                if (!$scope.$tabSelected) {
                  destroyTab();
                }
              });
            };
          }
        };
      }]);
      IonicModule.directive('ionTabNav', [function() {
        return {
          restrict: 'E',
          replace: true,
          require: ['^ionTabs', '^ionTab'],
          template: '<a ng-class="{\'tab-item-active\': isTabActive(), \'has-badge\':badge, \'tab-hidden\':isHidden()}" ' + ' ng-disabled="disabled()" class="tab-item">' + '<span class="badge {{badgeStyle}}" ng-if="badge">{{badge}}</span>' + '<i class="icon {{getIconOn()}}" ng-if="getIconOn() && isTabActive()"></i>' + '<i class="icon {{getIconOff()}}" ng-if="getIconOff() && !isTabActive()"></i>' + '<span class="tab-title" ng-bind-html="title"></span>' + '</a>',
          scope: {
            title: '@',
            icon: '@',
            iconOn: '@',
            iconOff: '@',
            badge: '=',
            hidden: '@',
            disabled: '&',
            badgeStyle: '@',
            'class': '@'
          },
          link: function($scope, $element, $attrs, ctrls) {
            var tabsCtrl = ctrls[0],
                tabCtrl = ctrls[1];
            $element[0].removeAttribute('title');
            $scope.selectTab = function(e) {
              e.preventDefault();
              tabsCtrl.select(tabCtrl.$scope, true);
            };
            if (!$attrs.ngClick) {
              $element.on('click', function(event) {
                $scope.$apply(function() {
                  $scope.selectTab(event);
                });
              });
            }
            $scope.isHidden = function() {
              if ($attrs.hidden === 'true' || $attrs.hidden === true)
                return true;
              return false;
            };
            $scope.getIconOn = function() {
              return $scope.iconOn || $scope.icon;
            };
            $scope.getIconOff = function() {
              return $scope.iconOff || $scope.icon;
            };
            $scope.isTabActive = function() {
              return tabsCtrl.selectedTab() === tabCtrl.$scope;
            };
          }
        };
      }]);
      IonicModule.directive('ionTabs', ['$ionicTabsDelegate', '$ionicConfig', function($ionicTabsDelegate, $ionicConfig) {
        return {
          restrict: 'E',
          scope: true,
          controller: '$ionicTabs',
          compile: function(tElement) {
            var innerElement = jqLite('<div class="tab-nav tabs">');
            innerElement.append(tElement.contents());
            tElement.append(innerElement).addClass('tabs-' + $ionicConfig.tabs.position() + ' tabs-' + $ionicConfig.tabs.style());
            return {
              pre: prelink,
              post: postLink
            };
            function prelink($scope, $element, $attr, tabsCtrl) {
              var deregisterInstance = $ionicTabsDelegate._registerInstance(tabsCtrl, $attr.delegateHandle, tabsCtrl.hasActiveScope);
              tabsCtrl.$scope = $scope;
              tabsCtrl.$element = $element;
              tabsCtrl.$tabsElement = jqLite($element[0].querySelector('.tabs'));
              $scope.$watch(function() {
                return $element[0].className;
              }, function(value) {
                var isTabsTop = value.indexOf('tabs-top') !== -1;
                var isHidden = value.indexOf('tabs-item-hide') !== -1;
                $scope.$hasTabs = !isTabsTop && !isHidden;
                $scope.$hasTabsTop = isTabsTop && !isHidden;
                $scope.$emit('$ionicTabs.top', $scope.$hasTabsTop);
              });
              function emitLifecycleEvent(ev, data) {
                ev.stopPropagation();
                var previousSelectedTab = tabsCtrl.previousSelectedTab();
                if (previousSelectedTab) {
                  previousSelectedTab.$broadcast(ev.name.replace('NavView', 'Tabs'), data);
                }
              }
              $scope.$on('$ionicNavView.beforeLeave', emitLifecycleEvent);
              $scope.$on('$ionicNavView.afterLeave', emitLifecycleEvent);
              $scope.$on('$ionicNavView.leave', emitLifecycleEvent);
              $scope.$on('$destroy', function() {
                $scope.$tabsDestroy = true;
                deregisterInstance();
                tabsCtrl.$tabsElement = tabsCtrl.$element = tabsCtrl.$scope = innerElement = null;
                delete $scope.$hasTabs;
                delete $scope.$hasTabsTop;
              });
            }
            function postLink($scope, $element, $attr, tabsCtrl) {
              if (!tabsCtrl.selectedTab()) {
                tabsCtrl.select(0);
              }
            }
          }
        };
      }]);
      IonicModule.directive('ionToggle', ['$timeout', '$ionicConfig', function($timeout, $ionicConfig) {
        return {
          restrict: 'E',
          replace: true,
          require: '?ngModel',
          transclude: true,
          template: '<div class="item item-toggle">' + '<div ng-transclude></div>' + '<label class="toggle">' + '<input type="checkbox">' + '<div class="track">' + '<div class="handle"></div>' + '</div>' + '</label>' + '</div>',
          compile: function(element, attr) {
            var input = element.find('input');
            forEach({
              'name': attr.name,
              'ng-value': attr.ngValue,
              'ng-model': attr.ngModel,
              'ng-checked': attr.ngChecked,
              'ng-disabled': attr.ngDisabled,
              'ng-true-value': attr.ngTrueValue,
              'ng-false-value': attr.ngFalseValue,
              'ng-change': attr.ngChange,
              'ng-required': attr.ngRequired,
              'required': attr.required
            }, function(value, name) {
              if (isDefined(value)) {
                input.attr(name, value);
              }
            });
            if (attr.toggleClass) {
              element[0].getElementsByTagName('label')[0].classList.add(attr.toggleClass);
            }
            element.addClass('toggle-' + $ionicConfig.form.toggle());
            return function($scope, $element) {
              var el = $element[0].getElementsByTagName('label')[0];
              var checkbox = el.children[0];
              var track = el.children[1];
              var handle = track.children[0];
              var ngModelController = jqLite(checkbox).controller('ngModel');
              $scope.toggle = new ionic.views.Toggle({
                el: el,
                track: track,
                checkbox: checkbox,
                handle: handle,
                onChange: function() {
                  if (ngModelController) {
                    ngModelController.$setViewValue(checkbox.checked);
                    $scope.$apply();
                  }
                }
              });
              $scope.$on('$destroy', function() {
                $scope.toggle.destroy();
              });
            };
          }
        };
      }]);
      IonicModule.directive('ionView', function() {
        return {
          restrict: 'EA',
          priority: 1000,
          controller: '$ionicView',
          compile: function(tElement) {
            tElement.addClass('pane');
            tElement[0].removeAttribute('title');
            return function link($scope, $element, $attrs, viewCtrl) {
              viewCtrl.init();
            };
          }
        };
      });
    })();
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, false);
});

System.register("github:angular/bower-angular-resource@1.4.4", ["github:angular/bower-angular-resource@1.4.4/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:angular/bower-angular-resource@1.4.4/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.18/library/fn/object/define-property", ["npm:core-js@0.9.18/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.18/library/modules/$");
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
  global.define = __define;
  return module.exports;
});

System.register("github:driftyco/ionic-bower@1.1.0", ["github:driftyco/ionic-bower@1.1.0/js/ionic-angular"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:driftyco/ionic-bower@1.1.0/js/ionic-angular");
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.8.20/core-js/object/define-property", ["npm:core-js@0.9.18/library/fn/object/define-property"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("npm:core-js@0.9.18/library/fn/object/define-property"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.8.20/helpers/create-class", ["npm:babel-runtime@5.8.20/core-js/object/define-property"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var _Object$defineProperty = require("npm:babel-runtime@5.8.20/core-js/object/define-property")["default"];
  exports["default"] = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.register('webapp/js/states/auth/login/login.controller', ['npm:babel-runtime@5.8.20/helpers/create-class', 'npm:babel-runtime@5.8.20/helpers/class-call-check'], function (_export) {
  var _createClass, _classCallCheck, LoginController;

  return {
    setters: [function (_npmBabelRuntime5820HelpersCreateClass) {
      _createClass = _npmBabelRuntime5820HelpersCreateClass['default'];
    }, function (_npmBabelRuntime5820HelpersClassCallCheck) {
      _classCallCheck = _npmBabelRuntime5820HelpersClassCallCheck['default'];
    }],
    execute: function () {
      'use strict';

      LoginController = (function () {
        function LoginController($scope, $state, AuthenticationService, $log) {
          'ngInject';

          _classCallCheck(this, LoginController);

          this.AuthenticationService = AuthenticationService;
          this.authCtrl = $scope.$parent.$parent.$parent.authCtrl;

          this.$state = $state;
          this.$log = $log;
          this.model = {
            username: null,
            password: null
          };
        }

        _createClass(LoginController, [{
          key: 'doLogin',
          value: function doLogin() {
            var _this = this;

            this.AuthenticationService.login(this.model).then(function (result) {
              _this.close();
              _this.$state.go('layout');
            }, function (error) {
              _this.$log.debug('not logged');
            });
          }
        }, {
          key: 'close',
          value: function close() {
            this.authCtrl.closeLogin();
          }
        }]);

        return LoginController;
      })();

      _export('default', LoginController);
    }
  };
});
System.register('webapp/js/states/auth/signup/signup.controller', ['npm:babel-runtime@5.8.20/helpers/create-class', 'npm:babel-runtime@5.8.20/helpers/class-call-check'], function (_export) {
  var _createClass, _classCallCheck, SignupController;

  return {
    setters: [function (_npmBabelRuntime5820HelpersCreateClass) {
      _createClass = _npmBabelRuntime5820HelpersCreateClass['default'];
    }, function (_npmBabelRuntime5820HelpersClassCallCheck) {
      _classCallCheck = _npmBabelRuntime5820HelpersClassCallCheck['default'];
    }],
    execute: function () {
      'use strict';

      SignupController = (function () {
        function SignupController($scope, AuthenticationService, $log) {
          'ngInject';

          _classCallCheck(this, SignupController);

          this.AuthenticationService = AuthenticationService;
          this.authCtrl = $scope.$parent.$parent.$parent.authCtrl;

          this.$log = $log;
          this.model = {
            username: null,
            password: null
          };
        }

        _createClass(SignupController, [{
          key: 'doSignup',
          value: function doSignup() {
            var _this = this;

            this.AuthenticationService.signup(this.model).then(function (result) {
              _this.$log.debug('signed up successfully');
            }, function (error) {
              _this.$log.debug('not signed up');
            });
          }
        }, {
          key: 'close',
          value: function close() {
            this.authCtrl.closeSignup();
          }
        }]);

        return SignupController;
      })();

      _export('default', SignupController);
    }
  };
});
System.register('webapp/js/states/people/people.controller', ['npm:babel-runtime@5.8.20/helpers/class-call-check'], function (_export) {
  var _classCallCheck, PeopleController;

  return {
    setters: [function (_npmBabelRuntime5820HelpersClassCallCheck) {
      _classCallCheck = _npmBabelRuntime5820HelpersClassCallCheck['default'];
    }],
    execute: function () {
      'use strict';

      PeopleController = function PeopleController(PeopleService, LocationService, $log) {
        var _this = this;

        _classCallCheck(this, PeopleController);

        this.people = [];

        var location = null;
        LocationService.startWatchPosition().then(function (position) {
          $log.debug('position: ', position);
          location = position;
          return PeopleService.getPeople();
        }, function (error) {
          $log.debug('Error occurred during getting location: ', error);
        }).then(function (people) {
          for (var index in people) {
            people[index].distance = LocationService.getDistanceFromLocation(location[0], location[1], people[index].latitude, people[index].longitude);
          }
          _this.people = people;
        }, function (error) {
          $log.debug('Error occurred during getting people: ', error);
        });
      };

      _export('default', PeopleController);
    }
  };
});
System.register('webapp/js/states/places/places.controller', ['npm:babel-runtime@5.8.20/helpers/class-call-check'], function (_export) {
  var _classCallCheck, PlacesController;

  return {
    setters: [function (_npmBabelRuntime5820HelpersClassCallCheck) {
      _classCallCheck = _npmBabelRuntime5820HelpersClassCallCheck['default'];
    }],
    execute: function () {
      'use strict';

      PlacesController = function PlacesController(PlacesService, LocationService, $log) {
        var _this = this;

        _classCallCheck(this, PlacesController);

        this.places = [];
        var location = null;

        LocationService.startWatchPosition().then(function (position) {
          $log.debug('position: ', position);
          location = position;
          return PlacesService.getPlaces();
        }, function (error) {
          $log.debug('Error occurred during getting location: ', error);
        }).then(function (places) {
          for (var index in places) {
            places[index].distance = LocationService.getDistanceFromLocation(location[0], location[1], places[index].latitude, places[index].longitude);
          }
          _this.places = places;
        }, function (error) {
          $log.debug('Error occurred during getting people: ', error);
        });
      };

      _export('default', PlacesController);
    }
  };
});
System.register('webapp/js/states/places/places.service', ['npm:babel-runtime@5.8.20/helpers/create-class', 'npm:babel-runtime@5.8.20/helpers/class-call-check', 'webapp/js/core/settings/config'], function (_export) {
  var _createClass, _classCallCheck, config, PlacesService;

  return {
    setters: [function (_npmBabelRuntime5820HelpersCreateClass) {
      _createClass = _npmBabelRuntime5820HelpersCreateClass['default'];
    }, function (_npmBabelRuntime5820HelpersClassCallCheck) {
      _classCallCheck = _npmBabelRuntime5820HelpersClassCallCheck['default'];
    }, function (_webappJsCoreSettingsConfig) {
      config = _webappJsCoreSettingsConfig['default'];
    }],
    execute: function () {
      'use strict';

      PlacesService = (function () {
        function PlacesService($resource, $q) {
          _classCallCheck(this, PlacesService);

          this.$q = $q;
          this.service = $resource(config.serviceUrl + '/api/places', null);
        }

        _createClass(PlacesService, [{
          key: 'getPlaces',
          value: function getPlaces() {
            return this.service.get().$promise.then(function (data) {
              return data.result;
            });
          }
        }]);

        return PlacesService;
      })();

      _export('default', PlacesService);
    }
  };
});
System.register('webapp/js/core/services/authentication.service', ['npm:babel-runtime@5.8.20/helpers/create-class', 'npm:babel-runtime@5.8.20/helpers/class-call-check', 'webapp/js/core/settings/config'], function (_export) {
  var _createClass, _classCallCheck, config, AuthenticationService;

  return {
    setters: [function (_npmBabelRuntime5820HelpersCreateClass) {
      _createClass = _npmBabelRuntime5820HelpersCreateClass['default'];
    }, function (_npmBabelRuntime5820HelpersClassCallCheck) {
      _classCallCheck = _npmBabelRuntime5820HelpersClassCallCheck['default'];
    }, function (_webappJsCoreSettingsConfig) {
      config = _webappJsCoreSettingsConfig['default'];
    }],
    execute: function () {
      'use strict';

      AuthenticationService = (function () {
        function AuthenticationService($resource, $log, $q, $window) {
          _classCallCheck(this, AuthenticationService);

          this.resource = $resource;
          this.logger = $log;
          this.$q = $q;
          this.sessionStorage = $window.sessionStorage;
        }

        _createClass(AuthenticationService, [{
          key: 'login',
          value: function login(model) {
            var self = this;
            return self.resource(config.serviceUrl + '/auth/login', null, {
              login: { method: 'POST' }
            }).login(model).$promise.then(function (data) {
              self.sessionStorage.token = data.token;
              return data;
            }, function (error) {
              delete self.sessionStorage.token;
              return self.$q.reject({ errorCode: error.status });
            });
          }
        }, {
          key: 'logout',
          value: function logout() {
            var _this = this;

            return this.resource(config.serviceUrl + '/auth/logout', null, {
              get: { method: 'GET' }
            }).get().$promise.then(function (data) {
              delete _this.sessionStorage.token;
              _this.logger.debug({
                info: 'Session is destroyed.',
                result: data.result
              });
            }, function () {
              delete _this.sessionStorage.token;
            });
          }
        }, {
          key: 'isAuthenticated',
          value: function isAuthenticated() {
            return !!this.sessionStorage.token;
          }
        }, {
          key: 'register',
          value: function register() {}
        }]);

        return AuthenticationService;
      })();

      _export('default', AuthenticationService);
    }
  };
});
System.register('webapp/js/core/services/location.service', ['npm:babel-runtime@5.8.20/helpers/create-class', 'npm:babel-runtime@5.8.20/helpers/class-call-check'], function (_export) {
  var _createClass, _classCallCheck, LocationService;

  return {
    setters: [function (_npmBabelRuntime5820HelpersCreateClass) {
      _createClass = _npmBabelRuntime5820HelpersCreateClass['default'];
    }, function (_npmBabelRuntime5820HelpersClassCallCheck) {
      _classCallCheck = _npmBabelRuntime5820HelpersClassCallCheck['default'];
    }],
    execute: function () {
      'use strict';

      LocationService = (function () {
        function LocationService($resource, $q) {
          _classCallCheck(this, LocationService);

          this.location = $q.defer();
          this.$q = $q;
          this.service = $resource('/location', null, {
            post: { method: 'post' }
          });
          this.posOptions = { maximumAge: 10000, timeout: 5000, enableHighAccuracy: true };
        }

        _createClass(LocationService, [{
          key: 'startWatchPosition',
          value: function startWatchPosition() {
            var _this = this;

            navigator.geolocation.watchPosition(function (position) {
              _this.location.resolve([position.coords.latitude, position.coords.longitude]);
            }, function (err) {
              _this.location.reject(err);
            }, this.posOptions);
            return this.location.promise;
          }
        }, {
          key: 'getDistanceFromLocation',
          value: function getDistanceFromLocation(lat1, lon1, lat2, lon2) {
            function deg2rad(deg) {
              return deg * (Math.PI / 180);
            }

            var R = 6371; // Radius of the earth in km
            var dLat = deg2rad(lat2 - lat1); // deg2rad below
            var dLon = deg2rad(lon2 - lon1);
            var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            var d = R * c; // Distance in km
            if (d > 1) {
              d = d.toFixed(2) + ' km';
            } else {
              // Distance in m
              d = (d * 1000).toFixed(0) + ' m';
            }
            return d;
          }
        }, {
          key: 'shareGeolocation',
          value: function shareGeolocation(data) {
            this.service.post(data).$promise.then(function (data) {}, function (error) {});
          }
        }, {
          key: 'clearWatch',
          value: function clearWatch(watch) {
            navigator.geolocation.clearWatch(watch);
          }
        }]);

        return LocationService;
      })();

      _export('default', LocationService);

      /*
       * Range of allowed values can be evaluated as rectangle:
       *  for latitude 0.01 ~ 1.11km
       *  for longitude 0.01 ~ 689m
       *
       * */
    }
  };
});
System.register('webapp/js/core/interceptors', [], function (_export) {
    'use strict';

    function interceptors($log, $q, $window, $injector) {
        var sessionStorage = $window.sessionStorage;

        return {
            'request': function request(config) {
                config.headers.Authorization = 'Bearer ' + sessionStorage.token;
                $log.debug(config);
                return config;
            },
            'response': function response(_response) {
                $log.debug(_response);
                return _response;
            },
            'responseError': function responseError(response) {
                var deferred = $q.defer(),
                    $state = $injector.get('$state');

                if (response.data && response.data.code) {
                    deferred.reject(response.data.code);
                } else {
                    deferred.reject(response.status);
                }
                if (response.status === 401) {
                    delete sessionStorage.token;
                    $state.go('auth');
                }
                return $q.reject(response);
            }
        };
    }

    return {
        setters: [],
        execute: function () {
            _export('default', interceptors);
        }
    };
});
System.register("webapp/js/states/layout/layout.controller", ["npm:babel-runtime@5.8.20/helpers/class-call-check"], function (_export) {
  var _classCallCheck, MenuController;

  return {
    setters: [function (_npmBabelRuntime5820HelpersClassCallCheck) {
      _classCallCheck = _npmBabelRuntime5820HelpersClassCallCheck["default"];
    }],
    execute: function () {
      "use strict";

      MenuController = function MenuController() {
        _classCallCheck(this, MenuController);
      };

      _export("default", MenuController);
    }
  };
});
System.register('webapp/js/core/settings/config', ['./webapp/app.config.json!github:systemjs/plugin-text@0.0.2'], function (_export) {
  'use strict';

  var config, configObject;
  return {
    setters: [function (_webappAppConfigJsonGithubSystemjsPluginText002) {
      config = _webappAppConfigJsonGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      configObject = JSON.parse(config);

      _export('default', configObject);
    }
  };
});
System.register('webapp/js/states/places/places', ['webapp/js/states/places/places.controller', 'webapp/js/states/places/places.service', 'webapp/js/states/places/places.html!github:systemjs/plugin-text@0.0.2'], function (_export) {
  'use strict';

  var PlacesController, PlacesService, template;
  return {
    setters: [function (_webappJsStatesPlacesPlacesController) {
      PlacesController = _webappJsStatesPlacesPlacesController['default'];
    }, function (_webappJsStatesPlacesPlacesService) {
      PlacesService = _webappJsStatesPlacesPlacesService['default'];
    }, function (_webappJsStatesPlacesPlacesHtmlGithubSystemjsPluginText002) {
      template = _webappJsStatesPlacesPlacesHtmlGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      _export('default', angular.module('app.places', []).controller('PlacesController', PlacesController).service('PlacesService', PlacesService).config(function ($stateProvider) {

        $stateProvider.state('layout.places', {
          cache: false,
          url: '/places',
          template: template
        });
      }).run(function ($templateCache) {
        'ngInject';

        $templateCache.put('template:places', template);
      }));
    }
  };
});
System.register('webapp/js/core/core', ['webapp/js/core/services/authentication.service', 'webapp/js/core/services/location.service'], function (_export) {
  'use strict';

  var AuthenticationService, LocationService;
  return {
    setters: [function (_webappJsCoreServicesAuthenticationService) {
      AuthenticationService = _webappJsCoreServicesAuthenticationService['default'];
    }, function (_webappJsCoreServicesLocationService) {
      LocationService = _webappJsCoreServicesLocationService['default'];
    }],
    execute: function () {
      _export('default', angular.module('app.core', []).service('AuthenticationService', AuthenticationService).service('LocationService', LocationService));
    }
  };
});
System.register('webapp/js/states/layout/layout', ['webapp/js/states/layout/layout.html!github:systemjs/plugin-text@0.0.2', 'webapp/js/states/layout/layout.controller'], function (_export) {
  'use strict';

  var template, LayoutController;
  return {
    setters: [function (_webappJsStatesLayoutLayoutHtmlGithubSystemjsPluginText002) {
      template = _webappJsStatesLayoutLayoutHtmlGithubSystemjsPluginText002['default'];
    }, function (_webappJsStatesLayoutLayoutController) {
      LayoutController = _webappJsStatesLayoutLayoutController['default'];
    }],
    execute: function () {
      _export('default', angular.module('app.layout', []).controller('LayoutController', LayoutController).config(function ($stateProvider) {
        'ngInject';

        $stateProvider.state('layout', {
          url: '/layout',
          template: template
        });
      }));
    }
  };
});
System.register('webapp/js/states/people/people.service', ['npm:babel-runtime@5.8.20/helpers/create-class', 'npm:babel-runtime@5.8.20/helpers/class-call-check', 'webapp/js/core/settings/config'], function (_export) {
  var _createClass, _classCallCheck, config, PeopleService;

  return {
    setters: [function (_npmBabelRuntime5820HelpersCreateClass) {
      _createClass = _npmBabelRuntime5820HelpersCreateClass['default'];
    }, function (_npmBabelRuntime5820HelpersClassCallCheck) {
      _classCallCheck = _npmBabelRuntime5820HelpersClassCallCheck['default'];
    }, function (_webappJsCoreSettingsConfig) {
      config = _webappJsCoreSettingsConfig['default'];
    }],
    execute: function () {
      'use strict';

      PeopleService = (function () {
        function PeopleService($resource) {
          _classCallCheck(this, PeopleService);

          this.service = $resource(config.serviceUrl + '/api/users', null);
        }

        _createClass(PeopleService, [{
          key: 'getPeople',
          value: function getPeople() {
            return this.service.get().$promise.then(function (data) {
              return data.result;
            });
          }
        }]);

        return PeopleService;
      })();

      _export('default', PeopleService);
    }
  };
});
System.register('webapp/js/states/people/people', ['webapp/js/states/people/people.controller', 'webapp/js/states/people/people.service', 'webapp/js/states/people/people.html!github:systemjs/plugin-text@0.0.2'], function (_export) {
  'use strict';

  var PeopleController, PeopleService, template;
  return {
    setters: [function (_webappJsStatesPeoplePeopleController) {
      PeopleController = _webappJsStatesPeoplePeopleController['default'];
    }, function (_webappJsStatesPeoplePeopleService) {
      PeopleService = _webappJsStatesPeoplePeopleService['default'];
    }, function (_webappJsStatesPeoplePeopleHtmlGithubSystemjsPluginText002) {
      template = _webappJsStatesPeoplePeopleHtmlGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      _export('default', angular.module('app.people', []).controller('PeopleController', PeopleController).service('PeopleService', PeopleService)

      //.config(function ($stateProvider) {
      //
      //  $stateProvider.state('layout.people', {
      //    cache: false,
      //    url: '/people',
      //    template: template
      //  });
      //})

      .run(function ($templateCache) {
        $templateCache.put('template:people', template);
      }));
    }
  };
});
System.register('webapp/js/states/auth/auth.controller', ['npm:babel-runtime@5.8.20/helpers/create-class', 'npm:babel-runtime@5.8.20/helpers/class-call-check', 'webapp/js/states/auth/login/login.html!github:systemjs/plugin-text@0.0.2', 'webapp/js/states/auth/signup/signup.html!github:systemjs/plugin-text@0.0.2'], function (_export) {
  var _createClass, _classCallCheck, loginTemplate, signupTemplate, AuthController;

  return {
    setters: [function (_npmBabelRuntime5820HelpersCreateClass) {
      _createClass = _npmBabelRuntime5820HelpersCreateClass['default'];
    }, function (_npmBabelRuntime5820HelpersClassCallCheck) {
      _classCallCheck = _npmBabelRuntime5820HelpersClassCallCheck['default'];
    }, function (_webappJsStatesAuthLoginLoginHtmlGithubSystemjsPluginText002) {
      loginTemplate = _webappJsStatesAuthLoginLoginHtmlGithubSystemjsPluginText002['default'];
    }, function (_webappJsStatesAuthSignupSignupHtmlGithubSystemjsPluginText002) {
      signupTemplate = _webappJsStatesAuthSignupSignupHtmlGithubSystemjsPluginText002['default'];
    }],
    execute: function () {
      'use strict';

      AuthController = (function () {
        function AuthController($ionicModal, $scope, $log) {
          'ngInject';

          _classCallCheck(this, AuthController);

          this.$log = $log;

          this.modalLogin = $ionicModal.fromTemplate(loginTemplate, {
            scope: $scope
          });
          this.modalSignup = $ionicModal.fromTemplate(signupTemplate, {
            scope: $scope
          });
        }

        _createClass(AuthController, [{
          key: 'login',
          value: function login() {
            this.modalLogin.show();
          }
        }, {
          key: 'signup',
          value: function signup() {
            this.modalSignup.show();
          }
        }, {
          key: 'closeLogin',
          value: function closeLogin() {
            this.modalLogin.hide();
          }
        }, {
          key: 'closeSignup',
          value: function closeSignup() {
            this.modalSignup.hide();
          }
        }]);

        return AuthController;
      })();

      _export('default', AuthController);
    }
  };
});
System.register('webapp/js/states/auth/auth', ['webapp/js/states/auth/auth.html!github:systemjs/plugin-text@0.0.2', 'webapp/js/states/auth/auth.controller', 'webapp/js/states/auth/login/login.controller', 'webapp/js/states/auth/signup/signup.controller'], function (_export) {
  'use strict';

  var template, AuthController, LoginController, SignupController;
  return {
    setters: [function (_webappJsStatesAuthAuthHtmlGithubSystemjsPluginText002) {
      template = _webappJsStatesAuthAuthHtmlGithubSystemjsPluginText002['default'];
    }, function (_webappJsStatesAuthAuthController) {
      AuthController = _webappJsStatesAuthAuthController['default'];
    }, function (_webappJsStatesAuthLoginLoginController) {
      LoginController = _webappJsStatesAuthLoginLoginController['default'];
    }, function (_webappJsStatesAuthSignupSignupController) {
      SignupController = _webappJsStatesAuthSignupSignupController['default'];
    }],
    execute: function () {
      _export('default', angular.module('app.auth', []).controller('AuthController', AuthController).controller('LoginController', LoginController).controller('SignupController', SignupController).config(function ($stateProvider) {
        'ngInject';

        $stateProvider.state('auth', {
          url: '/auth',
          template: template
        });
      }));
    }
  };
});
System.register('webapp/js/main', ['github:driftyco/ionic-bower@1.1.0', 'github:components/jquery@2.1.4', 'github:angular/bower-angular-resource@1.4.4', 'webapp/js/states/layout/layout', 'webapp/js/states/auth/auth', 'webapp/js/states/people/people', 'webapp/js/states/places/places', 'webapp/js/core/core', 'webapp/js/core/interceptors'], function (_export) {
  'use strict';

  var layoutModule, authModule, peopleModule, placesModule, coreModule, interceptors, application;
  return {
    setters: [function (_githubDriftycoIonicBower110) {}, function (_githubComponentsJquery214) {}, function (_githubAngularBowerAngularResource144) {}, function (_webappJsStatesLayoutLayout) {
      layoutModule = _webappJsStatesLayoutLayout['default'];
    }, function (_webappJsStatesAuthAuth) {
      authModule = _webappJsStatesAuthAuth['default'];
    }, function (_webappJsStatesPeoplePeople) {
      peopleModule = _webappJsStatesPeoplePeople['default'];
    }, function (_webappJsStatesPlacesPlaces) {
      placesModule = _webappJsStatesPlacesPlaces['default'];
    }, function (_webappJsCoreCore) {
      coreModule = _webappJsCoreCore['default'];
    }, function (_webappJsCoreInterceptors) {
      interceptors = _webappJsCoreInterceptors['default'];
    }],
    execute: function () {
      application = angular.module('application', ['ionic', 'ngResource', 'ui.router', layoutModule.name, coreModule.name, authModule.name, peopleModule.name, placesModule.name]).run(function ($ionicPlatform, $state, $rootScope, AuthenticationService) {

        $ionicPlatform.ready(function () {
          // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard
          // for form inputs)
          if (window.cordova && window.cordova.plugins.Keyboard) {
            cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
            cordova.plugins.Keyboard.disableScroll(true);
          }
          if (window.StatusBar) {
            // org.apache.cordova.statusbar required
            StatusBar.styleDefault();
          }
        });

        $rootScope.defaultState = 'layout';
        $rootScope.$on('$stateChangeStart', function (event, toState) {
          $rootScope.toState = toState;
          if (AuthenticationService.isAuthenticated()) {
            if (toState.name.indexOf('auth') > -1) {
              $state.go($rootScope.defaultState);
              event.preventDefault();
            }
          } else if (toState.name.indexOf('auth') < 0) {
            $state.go('auth');
            event.preventDefault();
          }
        });
      }).config(function ($urlRouterProvider, $httpProvider) {

        $urlRouterProvider.otherwise('/layout');
        $httpProvider.interceptors.push(interceptors);
      });

      angular.element(document.body).ready(function () {
        angular.bootstrap(document.body, [application.name]);
      });
    }
  };
});
System.register('github:driftyco/ionic-bower@1.1.0/css/ionic.css!github:systemjs/plugin-css@0.1.14', [], false, function() {});
(function(c){var d=document,a='appendChild',i='styleSheet',s=d.createElement('style');s.type='text/css';d.getElementsByTagName('head')[0][a](s);s[i]?s[i].cssText=c:s[a](d.createTextNode(c));})
("/*!\n * Copyright 2014 Drifty Co.\n * http://drifty.com/\n *\n * Ionic, v1.1.0\n * A powerful HTML5 mobile app framework.\n * http://ionicframework.com/\n *\n * By @maxlynch, @benjsperry, @adamdbradley <3\n *\n * Licensed under the MIT license. Please see LICENSE for more information.\n *\n *//*!\n  Ionicons, v2.0.1\n  Created by Ben Sperry for the Ionic Framework, http://ionicons.com/\n  https://twitter.com/benjsperry  https://twitter.com/ionicframework\n  MIT License: https://github.com/driftyco/ionicons\n\n  Android-style icons originally built by Googles\n  Material Design Icons: https://github.com/google/material-design-icons\n  used under CC BY http://creativecommons.org/licenses/by/4.0/\n  Modified icons to fit ionicons grid from original.\n*/@font-face{font-family:Ionicons;src:url(jspm_packages/github/driftyco/ionic-bower@1.1.0/fonts/ionicons.eot?v=2.0.1);src:url(jspm_packages/github/driftyco/ionic-bower@1.1.0/fonts/ionicons.eot?v=2.0.1#iefix) format(\"embedded-opentype\"),url(jspm_packages/github/driftyco/ionic-bower@1.1.0/fonts/ionicons.ttf?v=2.0.1) format(\"truetype\"),url(jspm_packages/github/driftyco/ionic-bower@1.1.0/fonts/ionicons.woff?v=2.0.1) format(\"woff\"),url(jspm_packages/github/driftyco/ionic-bower@1.1.0/fonts/ionicons.woff) format(\"woff\"),url(jspm_packages/github/driftyco/ionic-bower@1.1.0/fonts/ionicons.svg?v=2.0.1#Ionicons) format(\"svg\");font-weight:400;font-style:normal}.ion,.ion-alert-circled:before,.ion-alert:before,.ion-android-add-circle:before,.ion-android-add:before,.ion-android-alarm-clock:before,.ion-android-alert:before,.ion-android-apps:before,.ion-android-archive:before,.ion-android-arrow-back:before,.ion-android-arrow-down:before,.ion-android-arrow-dropdown-circle:before,.ion-android-arrow-dropdown:before,.ion-android-arrow-dropleft-circle:before,.ion-android-arrow-dropleft:before,.ion-android-arrow-dropright-circle:before,.ion-android-arrow-dropright:before,.ion-android-arrow-dropup-circle:before,.ion-android-arrow-dropup:before,.ion-android-arrow-forward:before,.ion-android-arrow-up:before,.ion-android-attach:before,.ion-android-bar:before,.ion-android-bicycle:before,.ion-android-boat:before,.ion-android-bookmark:before,.ion-android-bulb:before,.ion-android-bus:before,.ion-android-calendar:before,.ion-android-call:before,.ion-android-camera:before,.ion-android-cancel:before,.ion-android-car:before,.ion-android-cart:before,.ion-android-chat:before,.ion-android-checkbox-blank:before,.ion-android-checkbox-outline-blank:before,.ion-android-checkbox-outline:before,.ion-android-checkbox:before,.ion-android-checkmark-circle:before,.ion-android-clipboard:before,.ion-android-close:before,.ion-android-cloud-circle:before,.ion-android-cloud-done:before,.ion-android-cloud-outline:before,.ion-android-cloud:before,.ion-android-color-palette:before,.ion-android-compass:before,.ion-android-contact:before,.ion-android-contacts:before,.ion-android-contract:before,.ion-android-create:before,.ion-android-delete:before,.ion-android-desktop:before,.ion-android-document:before,.ion-android-done-all:before,.ion-android-done:before,.ion-android-download:before,.ion-android-drafts:before,.ion-android-exit:before,.ion-android-expand:before,.ion-android-favorite-outline:before,.ion-android-favorite:before,.ion-android-film:before,.ion-android-folder-open:before,.ion-android-folder:before,.ion-android-funnel:before,.ion-android-globe:before,.ion-android-hand:before,.ion-android-hangout:before,.ion-android-happy:before,.ion-android-home:before,.ion-android-image:before,.ion-android-laptop:before,.ion-android-list:before,.ion-android-locate:before,.ion-android-lock:before,.ion-android-mail:before,.ion-android-map:before,.ion-android-menu:before,.ion-android-microphone-off:before,.ion-android-microphone:before,.ion-android-more-horizontal:before,.ion-android-more-vertical:before,.ion-android-navigate:before,.ion-android-notifications-none:before,.ion-android-notifications-off:before,.ion-android-notifications:before,.ion-android-open:before,.ion-android-options:before,.ion-android-people:before,.ion-android-person-add:before,.ion-android-person:before,.ion-android-phone-landscape:before,.ion-android-phone-portrait:before,.ion-android-pin:before,.ion-android-plane:before,.ion-android-playstore:before,.ion-android-print:before,.ion-android-radio-button-off:before,.ion-android-radio-button-on:before,.ion-android-refresh:before,.ion-android-remove-circle:before,.ion-android-remove:before,.ion-android-restaurant:before,.ion-android-sad:before,.ion-android-search:before,.ion-android-send:before,.ion-android-settings:before,.ion-android-share-alt:before,.ion-android-share:before,.ion-android-star-half:before,.ion-android-star-outline:before,.ion-android-star:before,.ion-android-stopwatch:before,.ion-android-subway:before,.ion-android-sunny:before,.ion-android-sync:before,.ion-android-textsms:before,.ion-android-time:before,.ion-android-train:before,.ion-android-unlock:before,.ion-android-upload:before,.ion-android-volume-down:before,.ion-android-volume-mute:before,.ion-android-volume-off:before,.ion-android-volume-up:before,.ion-android-walk:before,.ion-android-warning:before,.ion-android-watch:before,.ion-android-wifi:before,.ion-aperture:before,.ion-archive:before,.ion-arrow-down-a:before,.ion-arrow-down-b:before,.ion-arrow-down-c:before,.ion-arrow-expand:before,.ion-arrow-graph-down-left:before,.ion-arrow-graph-down-right:before,.ion-arrow-graph-up-left:before,.ion-arrow-graph-up-right:before,.ion-arrow-left-a:before,.ion-arrow-left-b:before,.ion-arrow-left-c:before,.ion-arrow-move:before,.ion-arrow-resize:before,.ion-arrow-return-left:before,.ion-arrow-return-right:before,.ion-arrow-right-a:before,.ion-arrow-right-b:before,.ion-arrow-right-c:before,.ion-arrow-shrink:before,.ion-arrow-swap:before,.ion-arrow-up-a:before,.ion-arrow-up-b:before,.ion-arrow-up-c:before,.ion-asterisk:before,.ion-at:before,.ion-backspace-outline:before,.ion-backspace:before,.ion-bag:before,.ion-battery-charging:before,.ion-battery-empty:before,.ion-battery-full:before,.ion-battery-half:before,.ion-battery-low:before,.ion-beaker:before,.ion-beer:before,.ion-bluetooth:before,.ion-bonfire:before,.ion-bookmark:before,.ion-bowtie:before,.ion-briefcase:before,.ion-bug:before,.ion-calculator:before,.ion-calendar:before,.ion-camera:before,.ion-card:before,.ion-cash:before,.ion-chatbox-working:before,.ion-chatbox:before,.ion-chatboxes:before,.ion-chatbubble-working:before,.ion-chatbubble:before,.ion-chatbubbles:before,.ion-checkmark-circled:before,.ion-checkmark-round:before,.ion-checkmark:before,.ion-chevron-down:before,.ion-chevron-left:before,.ion-chevron-right:before,.ion-chevron-up:before,.ion-clipboard:before,.ion-clock:before,.ion-close-circled:before,.ion-close-round:before,.ion-close:before,.ion-closed-captioning:before,.ion-cloud:before,.ion-code-download:before,.ion-code-working:before,.ion-code:before,.ion-coffee:before,.ion-compass:before,.ion-compose:before,.ion-connection-bars:before,.ion-contrast:before,.ion-crop:before,.ion-cube:before,.ion-disc:before,.ion-document-text:before,.ion-document:before,.ion-drag:before,.ion-earth:before,.ion-easel:before,.ion-edit:before,.ion-egg:before,.ion-eject:before,.ion-email-unread:before,.ion-email:before,.ion-erlenmeyer-flask-bubbles:before,.ion-erlenmeyer-flask:before,.ion-eye-disabled:before,.ion-eye:before,.ion-female:before,.ion-filing:before,.ion-film-marker:before,.ion-fireball:before,.ion-flag:before,.ion-flame:before,.ion-flash-off:before,.ion-flash:before,.ion-folder:before,.ion-fork-repo:before,.ion-fork:before,.ion-forward:before,.ion-funnel:before,.ion-gear-a:before,.ion-gear-b:before,.ion-grid:before,.ion-hammer:before,.ion-happy-outline:before,.ion-happy:before,.ion-headphone:before,.ion-heart-broken:before,.ion-heart:before,.ion-help-buoy:before,.ion-help-circled:before,.ion-help:before,.ion-home:before,.ion-icecream:before,.ion-image:before,.ion-images:before,.ion-information-circled:before,.ion-information:before,.ion-ionic:before,.ion-ios-alarm-outline:before,.ion-ios-alarm:before,.ion-ios-albums-outline:before,.ion-ios-albums:before,.ion-ios-americanfootball-outline:before,.ion-ios-americanfootball:before,.ion-ios-analytics-outline:before,.ion-ios-analytics:before,.ion-ios-arrow-back:before,.ion-ios-arrow-down:before,.ion-ios-arrow-forward:before,.ion-ios-arrow-left:before,.ion-ios-arrow-right:before,.ion-ios-arrow-thin-down:before,.ion-ios-arrow-thin-left:before,.ion-ios-arrow-thin-right:before,.ion-ios-arrow-thin-up:before,.ion-ios-arrow-up:before,.ion-ios-at-outline:before,.ion-ios-at:before,.ion-ios-barcode-outline:before,.ion-ios-barcode:before,.ion-ios-baseball-outline:before,.ion-ios-baseball:before,.ion-ios-basketball-outline:before,.ion-ios-basketball:before,.ion-ios-bell-outline:before,.ion-ios-bell:before,.ion-ios-body-outline:before,.ion-ios-body:before,.ion-ios-bolt-outline:before,.ion-ios-bolt:before,.ion-ios-book-outline:before,.ion-ios-book:before,.ion-ios-bookmarks-outline:before,.ion-ios-bookmarks:before,.ion-ios-box-outline:before,.ion-ios-box:before,.ion-ios-briefcase-outline:before,.ion-ios-briefcase:before,.ion-ios-browsers-outline:before,.ion-ios-browsers:before,.ion-ios-calculator-outline:before,.ion-ios-calculator:before,.ion-ios-calendar-outline:before,.ion-ios-calendar:before,.ion-ios-camera-outline:before,.ion-ios-camera:before,.ion-ios-cart-outline:before,.ion-ios-cart:before,.ion-ios-chatboxes-outline:before,.ion-ios-chatboxes:before,.ion-ios-chatbubble-outline:before,.ion-ios-chatbubble:before,.ion-ios-checkmark-empty:before,.ion-ios-checkmark-outline:before,.ion-ios-checkmark:before,.ion-ios-circle-filled:before,.ion-ios-circle-outline:before,.ion-ios-clock-outline:before,.ion-ios-clock:before,.ion-ios-close-empty:before,.ion-ios-close-outline:before,.ion-ios-close:before,.ion-ios-cloud-download-outline:before,.ion-ios-cloud-download:before,.ion-ios-cloud-outline:before,.ion-ios-cloud-upload-outline:before,.ion-ios-cloud-upload:before,.ion-ios-cloud:before,.ion-ios-cloudy-night-outline:before,.ion-ios-cloudy-night:before,.ion-ios-cloudy-outline:before,.ion-ios-cloudy:before,.ion-ios-cog-outline:before,.ion-ios-cog:before,.ion-ios-color-filter-outline:before,.ion-ios-color-filter:before,.ion-ios-color-wand-outline:before,.ion-ios-color-wand:before,.ion-ios-compose-outline:before,.ion-ios-compose:before,.ion-ios-contact-outline:before,.ion-ios-contact:before,.ion-ios-copy-outline:before,.ion-ios-copy:before,.ion-ios-crop-strong:before,.ion-ios-crop:before,.ion-ios-download-outline:before,.ion-ios-download:before,.ion-ios-drag:before,.ion-ios-email-outline:before,.ion-ios-email:before,.ion-ios-eye-outline:before,.ion-ios-eye:before,.ion-ios-fastforward-outline:before,.ion-ios-fastforward:before,.ion-ios-filing-outline:before,.ion-ios-filing:before,.ion-ios-film-outline:before,.ion-ios-film:before,.ion-ios-flag-outline:before,.ion-ios-flag:before,.ion-ios-flame-outline:before,.ion-ios-flame:before,.ion-ios-flask-outline:before,.ion-ios-flask:before,.ion-ios-flower-outline:before,.ion-ios-flower:before,.ion-ios-folder-outline:before,.ion-ios-folder:before,.ion-ios-football-outline:before,.ion-ios-football:before,.ion-ios-game-controller-a-outline:before,.ion-ios-game-controller-a:before,.ion-ios-game-controller-b-outline:before,.ion-ios-game-controller-b:before,.ion-ios-gear-outline:before,.ion-ios-gear:before,.ion-ios-glasses-outline:before,.ion-ios-glasses:before,.ion-ios-grid-view-outline:before,.ion-ios-grid-view:before,.ion-ios-heart-outline:before,.ion-ios-heart:before,.ion-ios-help-empty:before,.ion-ios-help-outline:before,.ion-ios-help:before,.ion-ios-home-outline:before,.ion-ios-home:before,.ion-ios-infinite-outline:before,.ion-ios-infinite:before,.ion-ios-information-empty:before,.ion-ios-information-outline:before,.ion-ios-information:before,.ion-ios-ionic-outline:before,.ion-ios-keypad-outline:before,.ion-ios-keypad:before,.ion-ios-lightbulb-outline:before,.ion-ios-lightbulb:before,.ion-ios-list-outline:before,.ion-ios-list:before,.ion-ios-location-outline:before,.ion-ios-location:before,.ion-ios-locked-outline:before,.ion-ios-locked:before,.ion-ios-loop-strong:before,.ion-ios-loop:before,.ion-ios-medical-outline:before,.ion-ios-medical:before,.ion-ios-medkit-outline:before,.ion-ios-medkit:before,.ion-ios-mic-off:before,.ion-ios-mic-outline:before,.ion-ios-mic:before,.ion-ios-minus-empty:before,.ion-ios-minus-outline:before,.ion-ios-minus:before,.ion-ios-monitor-outline:before,.ion-ios-monitor:before,.ion-ios-moon-outline:before,.ion-ios-moon:before,.ion-ios-more-outline:before,.ion-ios-more:before,.ion-ios-musical-note:before,.ion-ios-musical-notes:before,.ion-ios-navigate-outline:before,.ion-ios-navigate:before,.ion-ios-nutrition-outline:before,.ion-ios-nutrition:before,.ion-ios-paper-outline:before,.ion-ios-paper:before,.ion-ios-paperplane-outline:before,.ion-ios-paperplane:before,.ion-ios-partlysunny-outline:before,.ion-ios-partlysunny:before,.ion-ios-pause-outline:before,.ion-ios-pause:before,.ion-ios-paw-outline:before,.ion-ios-paw:before,.ion-ios-people-outline:before,.ion-ios-people:before,.ion-ios-person-outline:before,.ion-ios-person:before,.ion-ios-personadd-outline:before,.ion-ios-personadd:before,.ion-ios-photos-outline:before,.ion-ios-photos:before,.ion-ios-pie-outline:before,.ion-ios-pie:before,.ion-ios-pint-outline:before,.ion-ios-pint:before,.ion-ios-play-outline:before,.ion-ios-play:before,.ion-ios-plus-empty:before,.ion-ios-plus-outline:before,.ion-ios-plus:before,.ion-ios-pricetag-outline:before,.ion-ios-pricetag:before,.ion-ios-pricetags-outline:before,.ion-ios-pricetags:before,.ion-ios-printer-outline:before,.ion-ios-printer:before,.ion-ios-pulse-strong:before,.ion-ios-pulse:before,.ion-ios-rainy-outline:before,.ion-ios-rainy:before,.ion-ios-recording-outline:before,.ion-ios-recording:before,.ion-ios-redo-outline:before,.ion-ios-redo:before,.ion-ios-refresh-empty:before,.ion-ios-refresh-outline:before,.ion-ios-refresh:before,.ion-ios-reload:before,.ion-ios-reverse-camera-outline:before,.ion-ios-reverse-camera:before,.ion-ios-rewind-outline:before,.ion-ios-rewind:before,.ion-ios-rose-outline:before,.ion-ios-rose:before,.ion-ios-search-strong:before,.ion-ios-search:before,.ion-ios-settings-strong:before,.ion-ios-settings:before,.ion-ios-shuffle-strong:before,.ion-ios-shuffle:before,.ion-ios-skipbackward-outline:before,.ion-ios-skipbackward:before,.ion-ios-skipforward-outline:before,.ion-ios-skipforward:before,.ion-ios-snowy:before,.ion-ios-speedometer-outline:before,.ion-ios-speedometer:before,.ion-ios-star-half:before,.ion-ios-star-outline:before,.ion-ios-star:before,.ion-ios-stopwatch-outline:before,.ion-ios-stopwatch:before,.ion-ios-sunny-outline:before,.ion-ios-sunny:before,.ion-ios-telephone-outline:before,.ion-ios-telephone:before,.ion-ios-tennisball-outline:before,.ion-ios-tennisball:before,.ion-ios-thunderstorm-outline:before,.ion-ios-thunderstorm:before,.ion-ios-time-outline:before,.ion-ios-time:before,.ion-ios-timer-outline:before,.ion-ios-timer:before,.ion-ios-toggle-outline:before,.ion-ios-toggle:before,.ion-ios-trash-outline:before,.ion-ios-trash:before,.ion-ios-undo-outline:before,.ion-ios-undo:before,.ion-ios-unlocked-outline:before,.ion-ios-unlocked:before,.ion-ios-upload-outline:before,.ion-ios-upload:before,.ion-ios-videocam-outline:before,.ion-ios-videocam:before,.ion-ios-volume-high:before,.ion-ios-volume-low:before,.ion-ios-wineglass-outline:before,.ion-ios-wineglass:before,.ion-ios-world-outline:before,.ion-ios-world:before,.ion-ipad:before,.ion-iphone:before,.ion-ipod:before,.ion-jet:before,.ion-key:before,.ion-knife:before,.ion-laptop:before,.ion-leaf:before,.ion-levels:before,.ion-lightbulb:before,.ion-link:before,.ion-load-a:before,.ion-load-b:before,.ion-load-c:before,.ion-load-d:before,.ion-location:before,.ion-lock-combination:before,.ion-locked:before,.ion-log-in:before,.ion-log-out:before,.ion-loop:before,.ion-magnet:before,.ion-male:before,.ion-man:before,.ion-map:before,.ion-medkit:before,.ion-merge:before,.ion-mic-a:before,.ion-mic-b:before,.ion-mic-c:before,.ion-minus-circled:before,.ion-minus-round:before,.ion-minus:before,.ion-model-s:before,.ion-monitor:before,.ion-more:before,.ion-mouse:before,.ion-music-note:before,.ion-navicon-round:before,.ion-navicon:before,.ion-navigate:before,.ion-network:before,.ion-no-smoking:before,.ion-nuclear:before,.ion-outlet:before,.ion-paintbrush:before,.ion-paintbucket:before,.ion-paper-airplane:before,.ion-paperclip:before,.ion-pause:before,.ion-person-add:before,.ion-person-stalker:before,.ion-person:before,.ion-pie-graph:before,.ion-pin:before,.ion-pinpoint:before,.ion-pizza:before,.ion-plane:before,.ion-planet:before,.ion-play:before,.ion-playstation:before,.ion-plus-circled:before,.ion-plus-round:before,.ion-plus:before,.ion-podium:before,.ion-pound:before,.ion-power:before,.ion-pricetag:before,.ion-pricetags:before,.ion-printer:before,.ion-pull-request:before,.ion-qr-scanner:before,.ion-quote:before,.ion-radio-waves:before,.ion-record:before,.ion-refresh:before,.ion-reply-all:before,.ion-reply:before,.ion-ribbon-a:before,.ion-ribbon-b:before,.ion-sad-outline:before,.ion-sad:before,.ion-scissors:before,.ion-search:before,.ion-settings:before,.ion-share:before,.ion-shuffle:before,.ion-skip-backward:before,.ion-skip-forward:before,.ion-social-android-outline:before,.ion-social-android:before,.ion-social-angular-outline:before,.ion-social-angular:before,.ion-social-apple-outline:before,.ion-social-apple:before,.ion-social-bitcoin-outline:before,.ion-social-bitcoin:before,.ion-social-buffer-outline:before,.ion-social-buffer:before,.ion-social-chrome-outline:before,.ion-social-chrome:before,.ion-social-codepen-outline:before,.ion-social-codepen:before,.ion-social-css3-outline:before,.ion-social-css3:before,.ion-social-designernews-outline:before,.ion-social-designernews:before,.ion-social-dribbble-outline:before,.ion-social-dribbble:before,.ion-social-dropbox-outline:before,.ion-social-dropbox:before,.ion-social-euro-outline:before,.ion-social-euro:before,.ion-social-facebook-outline:before,.ion-social-facebook:before,.ion-social-foursquare-outline:before,.ion-social-foursquare:before,.ion-social-freebsd-devil:before,.ion-social-github-outline:before,.ion-social-github:before,.ion-social-google-outline:before,.ion-social-google:before,.ion-social-googleplus-outline:before,.ion-social-googleplus:before,.ion-social-hackernews-outline:before,.ion-social-hackernews:before,.ion-social-html5-outline:before,.ion-social-html5:before,.ion-social-instagram-outline:before,.ion-social-instagram:before,.ion-social-javascript-outline:before,.ion-social-javascript:before,.ion-social-linkedin-outline:before,.ion-social-linkedin:before,.ion-social-markdown:before,.ion-social-nodejs:before,.ion-social-octocat:before,.ion-social-pinterest-outline:before,.ion-social-pinterest:before,.ion-social-python:before,.ion-social-reddit-outline:before,.ion-social-reddit:before,.ion-social-rss-outline:before,.ion-social-rss:before,.ion-social-sass:before,.ion-social-skype-outline:before,.ion-social-skype:before,.ion-social-snapchat-outline:before,.ion-social-snapchat:before,.ion-social-tumblr-outline:before,.ion-social-tumblr:before,.ion-social-tux:before,.ion-social-twitch-outline:before,.ion-social-twitch:before,.ion-social-twitter-outline:before,.ion-social-twitter:before,.ion-social-usd-outline:before,.ion-social-usd:before,.ion-social-vimeo-outline:before,.ion-social-vimeo:before,.ion-social-whatsapp-outline:before,.ion-social-whatsapp:before,.ion-social-windows-outline:before,.ion-social-windows:before,.ion-social-wordpress-outline:before,.ion-social-wordpress:before,.ion-social-yahoo-outline:before,.ion-social-yahoo:before,.ion-social-yen-outline:before,.ion-social-yen:before,.ion-social-youtube-outline:before,.ion-social-youtube:before,.ion-soup-can-outline:before,.ion-soup-can:before,.ion-speakerphone:before,.ion-speedometer:before,.ion-spoon:before,.ion-star:before,.ion-stats-bars:before,.ion-steam:before,.ion-stop:before,.ion-thermometer:before,.ion-thumbsdown:before,.ion-thumbsup:before,.ion-toggle-filled:before,.ion-toggle:before,.ion-transgender:before,.ion-trash-a:before,.ion-trash-b:before,.ion-trophy:before,.ion-tshirt-outline:before,.ion-tshirt:before,.ion-umbrella:before,.ion-university:before,.ion-unlocked:before,.ion-upload:before,.ion-usb:before,.ion-videocamera:before,.ion-volume-high:before,.ion-volume-low:before,.ion-volume-medium:before,.ion-volume-mute:before,.ion-wand:before,.ion-waterdrop:before,.ion-wifi:before,.ion-wineglass:before,.ion-woman:before,.ion-wrench:before,.ion-xbox:before,.ionicons{display:inline-block;font-family:Ionicons;speak:none;font-style:normal;font-weight:400;font-variant:normal;text-transform:none;text-rendering:auto;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.ion-alert:before{content:\"\\f101\"}.ion-alert-circled:before{content:\"\\f100\"}.ion-android-add:before{content:\"\\f2c7\"}.ion-android-add-circle:before{content:\"\\f359\"}.ion-android-alarm-clock:before{content:\"\\f35a\"}.ion-android-alert:before{content:\"\\f35b\"}.ion-android-apps:before{content:\"\\f35c\"}.ion-android-archive:before{content:\"\\f2c9\"}.ion-android-arrow-back:before{content:\"\\f2ca\"}.ion-android-arrow-down:before{content:\"\\f35d\"}.ion-android-arrow-dropdown:before{content:\"\\f35f\"}.ion-android-arrow-dropdown-circle:before{content:\"\\f35e\"}.ion-android-arrow-dropleft:before{content:\"\\f361\"}.ion-android-arrow-dropleft-circle:before{content:\"\\f360\"}.ion-android-arrow-dropright:before{content:\"\\f363\"}.ion-android-arrow-dropright-circle:before{content:\"\\f362\"}.ion-android-arrow-dropup:before{content:\"\\f365\"}.ion-android-arrow-dropup-circle:before{content:\"\\f364\"}.ion-android-arrow-forward:before{content:\"\\f30f\"}.ion-android-arrow-up:before{content:\"\\f366\"}.ion-android-attach:before{content:\"\\f367\"}.ion-android-bar:before{content:\"\\f368\"}.ion-android-bicycle:before{content:\"\\f369\"}.ion-android-boat:before{content:\"\\f36a\"}.ion-android-bookmark:before{content:\"\\f36b\"}.ion-android-bulb:before{content:\"\\f36c\"}.ion-android-bus:before{content:\"\\f36d\"}.ion-android-calendar:before{content:\"\\f2d1\"}.ion-android-call:before{content:\"\\f2d2\"}.ion-android-camera:before{content:\"\\f2d3\"}.ion-android-cancel:before{content:\"\\f36e\"}.ion-android-car:before{content:\"\\f36f\"}.ion-android-cart:before{content:\"\\f370\"}.ion-android-chat:before{content:\"\\f2d4\"}.ion-android-checkbox:before{content:\"\\f374\"}.ion-android-checkbox-blank:before{content:\"\\f371\"}.ion-android-checkbox-outline:before{content:\"\\f373\"}.ion-android-checkbox-outline-blank:before{content:\"\\f372\"}.ion-android-checkmark-circle:before{content:\"\\f375\"}.ion-android-clipboard:before{content:\"\\f376\"}.ion-android-close:before{content:\"\\f2d7\"}.ion-android-cloud:before{content:\"\\f37a\"}.ion-android-cloud-circle:before{content:\"\\f377\"}.ion-android-cloud-done:before{content:\"\\f378\"}.ion-android-cloud-outline:before{content:\"\\f379\"}.ion-android-color-palette:before{content:\"\\f37b\"}.ion-android-compass:before{content:\"\\f37c\"}.ion-android-contact:before{content:\"\\f2d8\"}.ion-android-contacts:before{content:\"\\f2d9\"}.ion-android-contract:before{content:\"\\f37d\"}.ion-android-create:before{content:\"\\f37e\"}.ion-android-delete:before{content:\"\\f37f\"}.ion-android-desktop:before{content:\"\\f380\"}.ion-android-document:before{content:\"\\f381\"}.ion-android-done:before{content:\"\\f383\"}.ion-android-done-all:before{content:\"\\f382\"}.ion-android-download:before{content:\"\\f2dd\"}.ion-android-drafts:before{content:\"\\f384\"}.ion-android-exit:before{content:\"\\f385\"}.ion-android-expand:before{content:\"\\f386\"}.ion-android-favorite:before{content:\"\\f388\"}.ion-android-favorite-outline:before{content:\"\\f387\"}.ion-android-film:before{content:\"\\f389\"}.ion-android-folder:before{content:\"\\f2e0\"}.ion-android-folder-open:before{content:\"\\f38a\"}.ion-android-funnel:before{content:\"\\f38b\"}.ion-android-globe:before{content:\"\\f38c\"}.ion-android-hand:before{content:\"\\f2e3\"}.ion-android-hangout:before{content:\"\\f38d\"}.ion-android-happy:before{content:\"\\f38e\"}.ion-android-home:before{content:\"\\f38f\"}.ion-android-image:before{content:\"\\f2e4\"}.ion-android-laptop:before{content:\"\\f390\"}.ion-android-list:before{content:\"\\f391\"}.ion-android-locate:before{content:\"\\f2e9\"}.ion-android-lock:before{content:\"\\f392\"}.ion-android-mail:before{content:\"\\f2eb\"}.ion-android-map:before{content:\"\\f393\"}.ion-android-menu:before{content:\"\\f394\"}.ion-android-microphone:before{content:\"\\f2ec\"}.ion-android-microphone-off:before{content:\"\\f395\"}.ion-android-more-horizontal:before{content:\"\\f396\"}.ion-android-more-vertical:before{content:\"\\f397\"}.ion-android-navigate:before{content:\"\\f398\"}.ion-android-notifications:before{content:\"\\f39b\"}.ion-android-notifications-none:before{content:\"\\f399\"}.ion-android-notifications-off:before{content:\"\\f39a\"}.ion-android-open:before{content:\"\\f39c\"}.ion-android-options:before{content:\"\\f39d\"}.ion-android-people:before{content:\"\\f39e\"}.ion-android-person:before{content:\"\\f3a0\"}.ion-android-person-add:before{content:\"\\f39f\"}.ion-android-phone-landscape:before{content:\"\\f3a1\"}.ion-android-phone-portrait:before{content:\"\\f3a2\"}.ion-android-pin:before{content:\"\\f3a3\"}.ion-android-plane:before{content:\"\\f3a4\"}.ion-android-playstore:before{content:\"\\f2f0\"}.ion-android-print:before{content:\"\\f3a5\"}.ion-android-radio-button-off:before{content:\"\\f3a6\"}.ion-android-radio-button-on:before{content:\"\\f3a7\"}.ion-android-refresh:before{content:\"\\f3a8\"}.ion-android-remove:before{content:\"\\f2f4\"}.ion-android-remove-circle:before{content:\"\\f3a9\"}.ion-android-restaurant:before{content:\"\\f3aa\"}.ion-android-sad:before{content:\"\\f3ab\"}.ion-android-search:before{content:\"\\f2f5\"}.ion-android-send:before{content:\"\\f2f6\"}.ion-android-settings:before{content:\"\\f2f7\"}.ion-android-share:before{content:\"\\f2f8\"}.ion-android-share-alt:before{content:\"\\f3ac\"}.ion-android-star:before{content:\"\\f2fc\"}.ion-android-star-half:before{content:\"\\f3ad\"}.ion-android-star-outline:before{content:\"\\f3ae\"}.ion-android-stopwatch:before{content:\"\\f2fd\"}.ion-android-subway:before{content:\"\\f3af\"}.ion-android-sunny:before{content:\"\\f3b0\"}.ion-android-sync:before{content:\"\\f3b1\"}.ion-android-textsms:before{content:\"\\f3b2\"}.ion-android-time:before{content:\"\\f3b3\"}.ion-android-train:before{content:\"\\f3b4\"}.ion-android-unlock:before{content:\"\\f3b5\"}.ion-android-upload:before{content:\"\\f3b6\"}.ion-android-volume-down:before{content:\"\\f3b7\"}.ion-android-volume-mute:before{content:\"\\f3b8\"}.ion-android-volume-off:before{content:\"\\f3b9\"}.ion-android-volume-up:before{content:\"\\f3ba\"}.ion-android-walk:before{content:\"\\f3bb\"}.ion-android-warning:before{content:\"\\f3bc\"}.ion-android-watch:before{content:\"\\f3bd\"}.ion-android-wifi:before{content:\"\\f305\"}.ion-aperture:before{content:\"\\f313\"}.ion-archive:before{content:\"\\f102\"}.ion-arrow-down-a:before{content:\"\\f103\"}.ion-arrow-down-b:before{content:\"\\f104\"}.ion-arrow-down-c:before{content:\"\\f105\"}.ion-arrow-expand:before{content:\"\\f25e\"}.ion-arrow-graph-down-left:before{content:\"\\f25f\"}.ion-arrow-graph-down-right:before{content:\"\\f260\"}.ion-arrow-graph-up-left:before{content:\"\\f261\"}.ion-arrow-graph-up-right:before{content:\"\\f262\"}.ion-arrow-left-a:before{content:\"\\f106\"}.ion-arrow-left-b:before{content:\"\\f107\"}.ion-arrow-left-c:before{content:\"\\f108\"}.ion-arrow-move:before{content:\"\\f263\"}.ion-arrow-resize:before{content:\"\\f264\"}.ion-arrow-return-left:before{content:\"\\f265\"}.ion-arrow-return-right:before{content:\"\\f266\"}.ion-arrow-right-a:before{content:\"\\f109\"}.ion-arrow-right-b:before{content:\"\\f10a\"}.ion-arrow-right-c:before{content:\"\\f10b\"}.ion-arrow-shrink:before{content:\"\\f267\"}.ion-arrow-swap:before{content:\"\\f268\"}.ion-arrow-up-a:before{content:\"\\f10c\"}.ion-arrow-up-b:before{content:\"\\f10d\"}.ion-arrow-up-c:before{content:\"\\f10e\"}.ion-asterisk:before{content:\"\\f314\"}.ion-at:before{content:\"\\f10f\"}.ion-backspace:before{content:\"\\f3bf\"}.ion-backspace-outline:before{content:\"\\f3be\"}.ion-bag:before{content:\"\\f110\"}.ion-battery-charging:before{content:\"\\f111\"}.ion-battery-empty:before{content:\"\\f112\"}.ion-battery-full:before{content:\"\\f113\"}.ion-battery-half:before{content:\"\\f114\"}.ion-battery-low:before{content:\"\\f115\"}.ion-beaker:before{content:\"\\f269\"}.ion-beer:before{content:\"\\f26a\"}.ion-bluetooth:before{content:\"\\f116\"}.ion-bonfire:before{content:\"\\f315\"}.ion-bookmark:before{content:\"\\f26b\"}.ion-bowtie:before{content:\"\\f3c0\"}.ion-briefcase:before{content:\"\\f26c\"}.ion-bug:before{content:\"\\f2be\"}.ion-calculator:before{content:\"\\f26d\"}.ion-calendar:before{content:\"\\f117\"}.ion-camera:before{content:\"\\f118\"}.ion-card:before{content:\"\\f119\"}.ion-cash:before{content:\"\\f316\"}.ion-chatbox:before{content:\"\\f11b\"}.ion-chatbox-working:before{content:\"\\f11a\"}.ion-chatboxes:before{content:\"\\f11c\"}.ion-chatbubble:before{content:\"\\f11e\"}.ion-chatbubble-working:before{content:\"\\f11d\"}.ion-chatbubbles:before{content:\"\\f11f\"}.ion-checkmark:before{content:\"\\f122\"}.ion-checkmark-circled:before{content:\"\\f120\"}.ion-checkmark-round:before{content:\"\\f121\"}.ion-chevron-down:before{content:\"\\f123\"}.ion-chevron-left:before{content:\"\\f124\"}.ion-chevron-right:before{content:\"\\f125\"}.ion-chevron-up:before{content:\"\\f126\"}.ion-clipboard:before{content:\"\\f127\"}.ion-clock:before{content:\"\\f26e\"}.ion-close:before{content:\"\\f12a\"}.ion-close-circled:before{content:\"\\f128\"}.ion-close-round:before{content:\"\\f129\"}.ion-closed-captioning:before{content:\"\\f317\"}.ion-cloud:before{content:\"\\f12b\"}.ion-code:before{content:\"\\f271\"}.ion-code-download:before{content:\"\\f26f\"}.ion-code-working:before{content:\"\\f270\"}.ion-coffee:before{content:\"\\f272\"}.ion-compass:before{content:\"\\f273\"}.ion-compose:before{content:\"\\f12c\"}.ion-connection-bars:before{content:\"\\f274\"}.ion-contrast:before{content:\"\\f275\"}.ion-crop:before{content:\"\\f3c1\"}.ion-cube:before{content:\"\\f318\"}.ion-disc:before{content:\"\\f12d\"}.ion-document:before{content:\"\\f12f\"}.ion-document-text:before{content:\"\\f12e\"}.ion-drag:before{content:\"\\f130\"}.ion-earth:before{content:\"\\f276\"}.ion-easel:before{content:\"\\f3c2\"}.ion-edit:before{content:\"\\f2bf\"}.ion-egg:before{content:\"\\f277\"}.ion-eject:before{content:\"\\f131\"}.ion-email:before{content:\"\\f132\"}.ion-email-unread:before{content:\"\\f3c3\"}.ion-erlenmeyer-flask:before{content:\"\\f3c5\"}.ion-erlenmeyer-flask-bubbles:before{content:\"\\f3c4\"}.ion-eye:before{content:\"\\f133\"}.ion-eye-disabled:before{content:\"\\f306\"}.ion-female:before{content:\"\\f278\"}.ion-filing:before{content:\"\\f134\"}.ion-film-marker:before{content:\"\\f135\"}.ion-fireball:before{content:\"\\f319\"}.ion-flag:before{content:\"\\f279\"}.ion-flame:before{content:\"\\f31a\"}.ion-flash:before{content:\"\\f137\"}.ion-flash-off:before{content:\"\\f136\"}.ion-folder:before{content:\"\\f139\"}.ion-fork:before{content:\"\\f27a\"}.ion-fork-repo:before{content:\"\\f2c0\"}.ion-forward:before{content:\"\\f13a\"}.ion-funnel:before{content:\"\\f31b\"}.ion-gear-a:before{content:\"\\f13d\"}.ion-gear-b:before{content:\"\\f13e\"}.ion-grid:before{content:\"\\f13f\"}.ion-hammer:before{content:\"\\f27b\"}.ion-happy:before{content:\"\\f31c\"}.ion-happy-outline:before{content:\"\\f3c6\"}.ion-headphone:before{content:\"\\f140\"}.ion-heart:before{content:\"\\f141\"}.ion-heart-broken:before{content:\"\\f31d\"}.ion-help:before{content:\"\\f143\"}.ion-help-buoy:before{content:\"\\f27c\"}.ion-help-circled:before{content:\"\\f142\"}.ion-home:before{content:\"\\f144\"}.ion-icecream:before{content:\"\\f27d\"}.ion-image:before{content:\"\\f147\"}.ion-images:before{content:\"\\f148\"}.ion-information:before{content:\"\\f14a\"}.ion-information-circled:before{content:\"\\f149\"}.ion-ionic:before{content:\"\\f14b\"}.ion-ios-alarm:before{content:\"\\f3c8\"}.ion-ios-alarm-outline:before{content:\"\\f3c7\"}.ion-ios-albums:before{content:\"\\f3ca\"}.ion-ios-albums-outline:before{content:\"\\f3c9\"}.ion-ios-americanfootball:before{content:\"\\f3cc\"}.ion-ios-americanfootball-outline:before{content:\"\\f3cb\"}.ion-ios-analytics:before{content:\"\\f3ce\"}.ion-ios-analytics-outline:before{content:\"\\f3cd\"}.ion-ios-arrow-back:before{content:\"\\f3cf\"}.ion-ios-arrow-down:before{content:\"\\f3d0\"}.ion-ios-arrow-forward:before{content:\"\\f3d1\"}.ion-ios-arrow-left:before{content:\"\\f3d2\"}.ion-ios-arrow-right:before{content:\"\\f3d3\"}.ion-ios-arrow-thin-down:before{content:\"\\f3d4\"}.ion-ios-arrow-thin-left:before{content:\"\\f3d5\"}.ion-ios-arrow-thin-right:before{content:\"\\f3d6\"}.ion-ios-arrow-thin-up:before{content:\"\\f3d7\"}.ion-ios-arrow-up:before{content:\"\\f3d8\"}.ion-ios-at:before{content:\"\\f3da\"}.ion-ios-at-outline:before{content:\"\\f3d9\"}.ion-ios-barcode:before{content:\"\\f3dc\"}.ion-ios-barcode-outline:before{content:\"\\f3db\"}.ion-ios-baseball:before{content:\"\\f3de\"}.ion-ios-baseball-outline:before{content:\"\\f3dd\"}.ion-ios-basketball:before{content:\"\\f3e0\"}.ion-ios-basketball-outline:before{content:\"\\f3df\"}.ion-ios-bell:before{content:\"\\f3e2\"}.ion-ios-bell-outline:before{content:\"\\f3e1\"}.ion-ios-body:before{content:\"\\f3e4\"}.ion-ios-body-outline:before{content:\"\\f3e3\"}.ion-ios-bolt:before{content:\"\\f3e6\"}.ion-ios-bolt-outline:before{content:\"\\f3e5\"}.ion-ios-book:before{content:\"\\f3e8\"}.ion-ios-book-outline:before{content:\"\\f3e7\"}.ion-ios-bookmarks:before{content:\"\\f3ea\"}.ion-ios-bookmarks-outline:before{content:\"\\f3e9\"}.ion-ios-box:before{content:\"\\f3ec\"}.ion-ios-box-outline:before{content:\"\\f3eb\"}.ion-ios-briefcase:before{content:\"\\f3ee\"}.ion-ios-briefcase-outline:before{content:\"\\f3ed\"}.ion-ios-browsers:before{content:\"\\f3f0\"}.ion-ios-browsers-outline:before{content:\"\\f3ef\"}.ion-ios-calculator:before{content:\"\\f3f2\"}.ion-ios-calculator-outline:before{content:\"\\f3f1\"}.ion-ios-calendar:before{content:\"\\f3f4\"}.ion-ios-calendar-outline:before{content:\"\\f3f3\"}.ion-ios-camera:before{content:\"\\f3f6\"}.ion-ios-camera-outline:before{content:\"\\f3f5\"}.ion-ios-cart:before{content:\"\\f3f8\"}.ion-ios-cart-outline:before{content:\"\\f3f7\"}.ion-ios-chatboxes:before{content:\"\\f3fa\"}.ion-ios-chatboxes-outline:before{content:\"\\f3f9\"}.ion-ios-chatbubble:before{content:\"\\f3fc\"}.ion-ios-chatbubble-outline:before{content:\"\\f3fb\"}.ion-ios-checkmark:before{content:\"\\f3ff\"}.ion-ios-checkmark-empty:before{content:\"\\f3fd\"}.ion-ios-checkmark-outline:before{content:\"\\f3fe\"}.ion-ios-circle-filled:before{content:\"\\f400\"}.ion-ios-circle-outline:before{content:\"\\f401\"}.ion-ios-clock:before{content:\"\\f403\"}.ion-ios-clock-outline:before{content:\"\\f402\"}.ion-ios-close:before{content:\"\\f406\"}.ion-ios-close-empty:before{content:\"\\f404\"}.ion-ios-close-outline:before{content:\"\\f405\"}.ion-ios-cloud:before{content:\"\\f40c\"}.ion-ios-cloud-download:before{content:\"\\f408\"}.ion-ios-cloud-download-outline:before{content:\"\\f407\"}.ion-ios-cloud-outline:before{content:\"\\f409\"}.ion-ios-cloud-upload:before{content:\"\\f40b\"}.ion-ios-cloud-upload-outline:before{content:\"\\f40a\"}.ion-ios-cloudy:before{content:\"\\f410\"}.ion-ios-cloudy-night:before{content:\"\\f40e\"}.ion-ios-cloudy-night-outline:before{content:\"\\f40d\"}.ion-ios-cloudy-outline:before{content:\"\\f40f\"}.ion-ios-cog:before{content:\"\\f412\"}.ion-ios-cog-outline:before{content:\"\\f411\"}.ion-ios-color-filter:before{content:\"\\f414\"}.ion-ios-color-filter-outline:before{content:\"\\f413\"}.ion-ios-color-wand:before{content:\"\\f416\"}.ion-ios-color-wand-outline:before{content:\"\\f415\"}.ion-ios-compose:before{content:\"\\f418\"}.ion-ios-compose-outline:before{content:\"\\f417\"}.ion-ios-contact:before{content:\"\\f41a\"}.ion-ios-contact-outline:before{content:\"\\f419\"}.ion-ios-copy:before{content:\"\\f41c\"}.ion-ios-copy-outline:before{content:\"\\f41b\"}.ion-ios-crop:before{content:\"\\f41e\"}.ion-ios-crop-strong:before{content:\"\\f41d\"}.ion-ios-download:before{content:\"\\f420\"}.ion-ios-download-outline:before{content:\"\\f41f\"}.ion-ios-drag:before{content:\"\\f421\"}.ion-ios-email:before{content:\"\\f423\"}.ion-ios-email-outline:before{content:\"\\f422\"}.ion-ios-eye:before{content:\"\\f425\"}.ion-ios-eye-outline:before{content:\"\\f424\"}.ion-ios-fastforward:before{content:\"\\f427\"}.ion-ios-fastforward-outline:before{content:\"\\f426\"}.ion-ios-filing:before{content:\"\\f429\"}.ion-ios-filing-outline:before{content:\"\\f428\"}.ion-ios-film:before{content:\"\\f42b\"}.ion-ios-film-outline:before{content:\"\\f42a\"}.ion-ios-flag:before{content:\"\\f42d\"}.ion-ios-flag-outline:before{content:\"\\f42c\"}.ion-ios-flame:before{content:\"\\f42f\"}.ion-ios-flame-outline:before{content:\"\\f42e\"}.ion-ios-flask:before{content:\"\\f431\"}.ion-ios-flask-outline:before{content:\"\\f430\"}.ion-ios-flower:before{content:\"\\f433\"}.ion-ios-flower-outline:before{content:\"\\f432\"}.ion-ios-folder:before{content:\"\\f435\"}.ion-ios-folder-outline:before{content:\"\\f434\"}.ion-ios-football:before{content:\"\\f437\"}.ion-ios-football-outline:before{content:\"\\f436\"}.ion-ios-game-controller-a:before{content:\"\\f439\"}.ion-ios-game-controller-a-outline:before{content:\"\\f438\"}.ion-ios-game-controller-b:before{content:\"\\f43b\"}.ion-ios-game-controller-b-outline:before{content:\"\\f43a\"}.ion-ios-gear:before{content:\"\\f43d\"}.ion-ios-gear-outline:before{content:\"\\f43c\"}.ion-ios-glasses:before{content:\"\\f43f\"}.ion-ios-glasses-outline:before{content:\"\\f43e\"}.ion-ios-grid-view:before{content:\"\\f441\"}.ion-ios-grid-view-outline:before{content:\"\\f440\"}.ion-ios-heart:before{content:\"\\f443\"}.ion-ios-heart-outline:before{content:\"\\f442\"}.ion-ios-help:before{content:\"\\f446\"}.ion-ios-help-empty:before{content:\"\\f444\"}.ion-ios-help-outline:before{content:\"\\f445\"}.ion-ios-home:before{content:\"\\f448\"}.ion-ios-home-outline:before{content:\"\\f447\"}.ion-ios-infinite:before{content:\"\\f44a\"}.ion-ios-infinite-outline:before{content:\"\\f449\"}.ion-ios-information:before{content:\"\\f44d\"}.ion-ios-information-empty:before{content:\"\\f44b\"}.ion-ios-information-outline:before{content:\"\\f44c\"}.ion-ios-ionic-outline:before{content:\"\\f44e\"}.ion-ios-keypad:before{content:\"\\f450\"}.ion-ios-keypad-outline:before{content:\"\\f44f\"}.ion-ios-lightbulb:before{content:\"\\f452\"}.ion-ios-lightbulb-outline:before{content:\"\\f451\"}.ion-ios-list:before{content:\"\\f454\"}.ion-ios-list-outline:before{content:\"\\f453\"}.ion-ios-location:before{content:\"\\f456\"}.ion-ios-location-outline:before{content:\"\\f455\"}.ion-ios-locked:before{content:\"\\f458\"}.ion-ios-locked-outline:before{content:\"\\f457\"}.ion-ios-loop:before{content:\"\\f45a\"}.ion-ios-loop-strong:before{content:\"\\f459\"}.ion-ios-medical:before{content:\"\\f45c\"}.ion-ios-medical-outline:before{content:\"\\f45b\"}.ion-ios-medkit:before{content:\"\\f45e\"}.ion-ios-medkit-outline:before{content:\"\\f45d\"}.ion-ios-mic:before{content:\"\\f461\"}.ion-ios-mic-off:before{content:\"\\f45f\"}.ion-ios-mic-outline:before{content:\"\\f460\"}.ion-ios-minus:before{content:\"\\f464\"}.ion-ios-minus-empty:before{content:\"\\f462\"}.ion-ios-minus-outline:before{content:\"\\f463\"}.ion-ios-monitor:before{content:\"\\f466\"}.ion-ios-monitor-outline:before{content:\"\\f465\"}.ion-ios-moon:before{content:\"\\f468\"}.ion-ios-moon-outline:before{content:\"\\f467\"}.ion-ios-more:before{content:\"\\f46a\"}.ion-ios-more-outline:before{content:\"\\f469\"}.ion-ios-musical-note:before{content:\"\\f46b\"}.ion-ios-musical-notes:before{content:\"\\f46c\"}.ion-ios-navigate:before{content:\"\\f46e\"}.ion-ios-navigate-outline:before{content:\"\\f46d\"}.ion-ios-nutrition:before{content:\"\\f470\"}.ion-ios-nutrition-outline:before{content:\"\\f46f\"}.ion-ios-paper:before{content:\"\\f472\"}.ion-ios-paper-outline:before{content:\"\\f471\"}.ion-ios-paperplane:before{content:\"\\f474\"}.ion-ios-paperplane-outline:before{content:\"\\f473\"}.ion-ios-partlysunny:before{content:\"\\f476\"}.ion-ios-partlysunny-outline:before{content:\"\\f475\"}.ion-ios-pause:before{content:\"\\f478\"}.ion-ios-pause-outline:before{content:\"\\f477\"}.ion-ios-paw:before{content:\"\\f47a\"}.ion-ios-paw-outline:before{content:\"\\f479\"}.ion-ios-people:before{content:\"\\f47c\"}.ion-ios-people-outline:before{content:\"\\f47b\"}.ion-ios-person:before{content:\"\\f47e\"}.ion-ios-person-outline:before{content:\"\\f47d\"}.ion-ios-personadd:before{content:\"\\f480\"}.ion-ios-personadd-outline:before{content:\"\\f47f\"}.ion-ios-photos:before{content:\"\\f482\"}.ion-ios-photos-outline:before{content:\"\\f481\"}.ion-ios-pie:before{content:\"\\f484\"}.ion-ios-pie-outline:before{content:\"\\f483\"}.ion-ios-pint:before{content:\"\\f486\"}.ion-ios-pint-outline:before{content:\"\\f485\"}.ion-ios-play:before{content:\"\\f488\"}.ion-ios-play-outline:before{content:\"\\f487\"}.ion-ios-plus:before{content:\"\\f48b\"}.ion-ios-plus-empty:before{content:\"\\f489\"}.ion-ios-plus-outline:before{content:\"\\f48a\"}.ion-ios-pricetag:before{content:\"\\f48d\"}.ion-ios-pricetag-outline:before{content:\"\\f48c\"}.ion-ios-pricetags:before{content:\"\\f48f\"}.ion-ios-pricetags-outline:before{content:\"\\f48e\"}.ion-ios-printer:before{content:\"\\f491\"}.ion-ios-printer-outline:before{content:\"\\f490\"}.ion-ios-pulse:before{content:\"\\f493\"}.ion-ios-pulse-strong:before{content:\"\\f492\"}.ion-ios-rainy:before{content:\"\\f495\"}.ion-ios-rainy-outline:before{content:\"\\f494\"}.ion-ios-recording:before{content:\"\\f497\"}.ion-ios-recording-outline:before{content:\"\\f496\"}.ion-ios-redo:before{content:\"\\f499\"}.ion-ios-redo-outline:before{content:\"\\f498\"}.ion-ios-refresh:before{content:\"\\f49c\"}.ion-ios-refresh-empty:before{content:\"\\f49a\"}.ion-ios-refresh-outline:before{content:\"\\f49b\"}.ion-ios-reload:before{content:\"\\f49d\"}.ion-ios-reverse-camera:before{content:\"\\f49f\"}.ion-ios-reverse-camera-outline:before{content:\"\\f49e\"}.ion-ios-rewind:before{content:\"\\f4a1\"}.ion-ios-rewind-outline:before{content:\"\\f4a0\"}.ion-ios-rose:before{content:\"\\f4a3\"}.ion-ios-rose-outline:before{content:\"\\f4a2\"}.ion-ios-search:before{content:\"\\f4a5\"}.ion-ios-search-strong:before{content:\"\\f4a4\"}.ion-ios-settings:before{content:\"\\f4a7\"}.ion-ios-settings-strong:before{content:\"\\f4a6\"}.ion-ios-shuffle:before{content:\"\\f4a9\"}.ion-ios-shuffle-strong:before{content:\"\\f4a8\"}.ion-ios-skipbackward:before{content:\"\\f4ab\"}.ion-ios-skipbackward-outline:before{content:\"\\f4aa\"}.ion-ios-skipforward:before{content:\"\\f4ad\"}.ion-ios-skipforward-outline:before{content:\"\\f4ac\"}.ion-ios-snowy:before{content:\"\\f4ae\"}.ion-ios-speedometer:before{content:\"\\f4b0\"}.ion-ios-speedometer-outline:before{content:\"\\f4af\"}.ion-ios-star:before{content:\"\\f4b3\"}.ion-ios-star-half:before{content:\"\\f4b1\"}.ion-ios-star-outline:before{content:\"\\f4b2\"}.ion-ios-stopwatch:before{content:\"\\f4b5\"}.ion-ios-stopwatch-outline:before{content:\"\\f4b4\"}.ion-ios-sunny:before{content:\"\\f4b7\"}.ion-ios-sunny-outline:before{content:\"\\f4b6\"}.ion-ios-telephone:before{content:\"\\f4b9\"}.ion-ios-telephone-outline:before{content:\"\\f4b8\"}.ion-ios-tennisball:before{content:\"\\f4bb\"}.ion-ios-tennisball-outline:before{content:\"\\f4ba\"}.ion-ios-thunderstorm:before{content:\"\\f4bd\"}.ion-ios-thunderstorm-outline:before{content:\"\\f4bc\"}.ion-ios-time:before{content:\"\\f4bf\"}.ion-ios-time-outline:before{content:\"\\f4be\"}.ion-ios-timer:before{content:\"\\f4c1\"}.ion-ios-timer-outline:before{content:\"\\f4c0\"}.ion-ios-toggle:before{content:\"\\f4c3\"}.ion-ios-toggle-outline:before{content:\"\\f4c2\"}.ion-ios-trash:before{content:\"\\f4c5\"}.ion-ios-trash-outline:before{content:\"\\f4c4\"}.ion-ios-undo:before{content:\"\\f4c7\"}.ion-ios-undo-outline:before{content:\"\\f4c6\"}.ion-ios-unlocked:before{content:\"\\f4c9\"}.ion-ios-unlocked-outline:before{content:\"\\f4c8\"}.ion-ios-upload:before{content:\"\\f4cb\"}.ion-ios-upload-outline:before{content:\"\\f4ca\"}.ion-ios-videocam:before{content:\"\\f4cd\"}.ion-ios-videocam-outline:before{content:\"\\f4cc\"}.ion-ios-volume-high:before{content:\"\\f4ce\"}.ion-ios-volume-low:before{content:\"\\f4cf\"}.ion-ios-wineglass:before{content:\"\\f4d1\"}.ion-ios-wineglass-outline:before{content:\"\\f4d0\"}.ion-ios-world:before{content:\"\\f4d3\"}.ion-ios-world-outline:before{content:\"\\f4d2\"}.ion-ipad:before{content:\"\\f1f9\"}.ion-iphone:before{content:\"\\f1fa\"}.ion-ipod:before{content:\"\\f1fb\"}.ion-jet:before{content:\"\\f295\"}.ion-key:before{content:\"\\f296\"}.ion-knife:before{content:\"\\f297\"}.ion-laptop:before{content:\"\\f1fc\"}.ion-leaf:before{content:\"\\f1fd\"}.ion-levels:before{content:\"\\f298\"}.ion-lightbulb:before{content:\"\\f299\"}.ion-link:before{content:\"\\f1fe\"}.ion-load-a:before{content:\"\\f29a\"}.ion-load-b:before{content:\"\\f29b\"}.ion-load-c:before{content:\"\\f29c\"}.ion-load-d:before{content:\"\\f29d\"}.ion-location:before{content:\"\\f1ff\"}.ion-lock-combination:before{content:\"\\f4d4\"}.ion-locked:before{content:\"\\f200\"}.ion-log-in:before{content:\"\\f29e\"}.ion-log-out:before{content:\"\\f29f\"}.ion-loop:before{content:\"\\f201\"}.ion-magnet:before{content:\"\\f2a0\"}.ion-male:before{content:\"\\f2a1\"}.ion-man:before{content:\"\\f202\"}.ion-map:before{content:\"\\f203\"}.ion-medkit:before{content:\"\\f2a2\"}.ion-merge:before{content:\"\\f33f\"}.ion-mic-a:before{content:\"\\f204\"}.ion-mic-b:before{content:\"\\f205\"}.ion-mic-c:before{content:\"\\f206\"}.ion-minus:before{content:\"\\f209\"}.ion-minus-circled:before{content:\"\\f207\"}.ion-minus-round:before{content:\"\\f208\"}.ion-model-s:before{content:\"\\f2c1\"}.ion-monitor:before{content:\"\\f20a\"}.ion-more:before{content:\"\\f20b\"}.ion-mouse:before{content:\"\\f340\"}.ion-music-note:before{content:\"\\f20c\"}.ion-navicon:before{content:\"\\f20e\"}.ion-navicon-round:before{content:\"\\f20d\"}.ion-navigate:before{content:\"\\f2a3\"}.ion-network:before{content:\"\\f341\"}.ion-no-smoking:before{content:\"\\f2c2\"}.ion-nuclear:before{content:\"\\f2a4\"}.ion-outlet:before{content:\"\\f342\"}.ion-paintbrush:before{content:\"\\f4d5\"}.ion-paintbucket:before{content:\"\\f4d6\"}.ion-paper-airplane:before{content:\"\\f2c3\"}.ion-paperclip:before{content:\"\\f20f\"}.ion-pause:before{content:\"\\f210\"}.ion-person:before{content:\"\\f213\"}.ion-person-add:before{content:\"\\f211\"}.ion-person-stalker:before{content:\"\\f212\"}.ion-pie-graph:before{content:\"\\f2a5\"}.ion-pin:before{content:\"\\f2a6\"}.ion-pinpoint:before{content:\"\\f2a7\"}.ion-pizza:before{content:\"\\f2a8\"}.ion-plane:before{content:\"\\f214\"}.ion-planet:before{content:\"\\f343\"}.ion-play:before{content:\"\\f215\"}.ion-playstation:before{content:\"\\f30a\"}.ion-plus:before{content:\"\\f218\"}.ion-plus-circled:before{content:\"\\f216\"}.ion-plus-round:before{content:\"\\f217\"}.ion-podium:before{content:\"\\f344\"}.ion-pound:before{content:\"\\f219\"}.ion-power:before{content:\"\\f2a9\"}.ion-pricetag:before{content:\"\\f2aa\"}.ion-pricetags:before{content:\"\\f2ab\"}.ion-printer:before{content:\"\\f21a\"}.ion-pull-request:before{content:\"\\f345\"}.ion-qr-scanner:before{content:\"\\f346\"}.ion-quote:before{content:\"\\f347\"}.ion-radio-waves:before{content:\"\\f2ac\"}.ion-record:before{content:\"\\f21b\"}.ion-refresh:before{content:\"\\f21c\"}.ion-reply:before{content:\"\\f21e\"}.ion-reply-all:before{content:\"\\f21d\"}.ion-ribbon-a:before{content:\"\\f348\"}.ion-ribbon-b:before{content:\"\\f349\"}.ion-sad:before{content:\"\\f34a\"}.ion-sad-outline:before{content:\"\\f4d7\"}.ion-scissors:before{content:\"\\f34b\"}.ion-search:before{content:\"\\f21f\"}.ion-settings:before{content:\"\\f2ad\"}.ion-share:before{content:\"\\f220\"}.ion-shuffle:before{content:\"\\f221\"}.ion-skip-backward:before{content:\"\\f222\"}.ion-skip-forward:before{content:\"\\f223\"}.ion-social-android:before{content:\"\\f225\"}.ion-social-android-outline:before{content:\"\\f224\"}.ion-social-angular:before{content:\"\\f4d9\"}.ion-social-angular-outline:before{content:\"\\f4d8\"}.ion-social-apple:before{content:\"\\f227\"}.ion-social-apple-outline:before{content:\"\\f226\"}.ion-social-bitcoin:before{content:\"\\f2af\"}.ion-social-bitcoin-outline:before{content:\"\\f2ae\"}.ion-social-buffer:before{content:\"\\f229\"}.ion-social-buffer-outline:before{content:\"\\f228\"}.ion-social-chrome:before{content:\"\\f4db\"}.ion-social-chrome-outline:before{content:\"\\f4da\"}.ion-social-codepen:before{content:\"\\f4dd\"}.ion-social-codepen-outline:before{content:\"\\f4dc\"}.ion-social-css3:before{content:\"\\f4df\"}.ion-social-css3-outline:before{content:\"\\f4de\"}.ion-social-designernews:before{content:\"\\f22b\"}.ion-social-designernews-outline:before{content:\"\\f22a\"}.ion-social-dribbble:before{content:\"\\f22d\"}.ion-social-dribbble-outline:before{content:\"\\f22c\"}.ion-social-dropbox:before{content:\"\\f22f\"}.ion-social-dropbox-outline:before{content:\"\\f22e\"}.ion-social-euro:before{content:\"\\f4e1\"}.ion-social-euro-outline:before{content:\"\\f4e0\"}.ion-social-facebook:before{content:\"\\f231\"}.ion-social-facebook-outline:before{content:\"\\f230\"}.ion-social-foursquare:before{content:\"\\f34d\"}.ion-social-foursquare-outline:before{content:\"\\f34c\"}.ion-social-freebsd-devil:before{content:\"\\f2c4\"}.ion-social-github:before{content:\"\\f233\"}.ion-social-github-outline:before{content:\"\\f232\"}.ion-social-google:before{content:\"\\f34f\"}.ion-social-google-outline:before{content:\"\\f34e\"}.ion-social-googleplus:before{content:\"\\f235\"}.ion-social-googleplus-outline:before{content:\"\\f234\"}.ion-social-hackernews:before{content:\"\\f237\"}.ion-social-hackernews-outline:before{content:\"\\f236\"}.ion-social-html5:before{content:\"\\f4e3\"}.ion-social-html5-outline:before{content:\"\\f4e2\"}.ion-social-instagram:before{content:\"\\f351\"}.ion-social-instagram-outline:before{content:\"\\f350\"}.ion-social-javascript:before{content:\"\\f4e5\"}.ion-social-javascript-outline:before{content:\"\\f4e4\"}.ion-social-linkedin:before{content:\"\\f239\"}.ion-social-linkedin-outline:before{content:\"\\f238\"}.ion-social-markdown:before{content:\"\\f4e6\"}.ion-social-nodejs:before{content:\"\\f4e7\"}.ion-social-octocat:before{content:\"\\f4e8\"}.ion-social-pinterest:before{content:\"\\f2b1\"}.ion-social-pinterest-outline:before{content:\"\\f2b0\"}.ion-social-python:before{content:\"\\f4e9\"}.ion-social-reddit:before{content:\"\\f23b\"}.ion-social-reddit-outline:before{content:\"\\f23a\"}.ion-social-rss:before{content:\"\\f23d\"}.ion-social-rss-outline:before{content:\"\\f23c\"}.ion-social-sass:before{content:\"\\f4ea\"}.ion-social-skype:before{content:\"\\f23f\"}.ion-social-skype-outline:before{content:\"\\f23e\"}.ion-social-snapchat:before{content:\"\\f4ec\"}.ion-social-snapchat-outline:before{content:\"\\f4eb\"}.ion-social-tumblr:before{content:\"\\f241\"}.ion-social-tumblr-outline:before{content:\"\\f240\"}.ion-social-tux:before{content:\"\\f2c5\"}.ion-social-twitch:before{content:\"\\f4ee\"}.ion-social-twitch-outline:before{content:\"\\f4ed\"}.ion-social-twitter:before{content:\"\\f243\"}.ion-social-twitter-outline:before{content:\"\\f242\"}.ion-social-usd:before{content:\"\\f353\"}.ion-social-usd-outline:before{content:\"\\f352\"}.ion-social-vimeo:before{content:\"\\f245\"}.ion-social-vimeo-outline:before{content:\"\\f244\"}.ion-social-whatsapp:before{content:\"\\f4f0\"}.ion-social-whatsapp-outline:before{content:\"\\f4ef\"}.ion-social-windows:before{content:\"\\f247\"}.ion-social-windows-outline:before{content:\"\\f246\"}.ion-social-wordpress:before{content:\"\\f249\"}.ion-social-wordpress-outline:before{content:\"\\f248\"}.ion-social-yahoo:before{content:\"\\f24b\"}.ion-social-yahoo-outline:before{content:\"\\f24a\"}.ion-social-yen:before{content:\"\\f4f2\"}.ion-social-yen-outline:before{content:\"\\f4f1\"}.ion-social-youtube:before{content:\"\\f24d\"}.ion-social-youtube-outline:before{content:\"\\f24c\"}.ion-soup-can:before{content:\"\\f4f4\"}.ion-soup-can-outline:before{content:\"\\f4f3\"}.ion-speakerphone:before{content:\"\\f2b2\"}.ion-speedometer:before{content:\"\\f2b3\"}.ion-spoon:before{content:\"\\f2b4\"}.ion-star:before{content:\"\\f24e\"}.ion-stats-bars:before{content:\"\\f2b5\"}.ion-steam:before{content:\"\\f30b\"}.ion-stop:before{content:\"\\f24f\"}.ion-thermometer:before{content:\"\\f2b6\"}.ion-thumbsdown:before{content:\"\\f250\"}.ion-thumbsup:before{content:\"\\f251\"}.ion-toggle:before{content:\"\\f355\"}.ion-toggle-filled:before{content:\"\\f354\"}.ion-transgender:before{content:\"\\f4f5\"}.ion-trash-a:before{content:\"\\f252\"}.ion-trash-b:before{content:\"\\f253\"}.ion-trophy:before{content:\"\\f356\"}.ion-tshirt:before{content:\"\\f4f7\"}.ion-tshirt-outline:before{content:\"\\f4f6\"}.ion-umbrella:before{content:\"\\f2b7\"}.ion-university:before{content:\"\\f357\"}.ion-unlocked:before{content:\"\\f254\"}.ion-upload:before{content:\"\\f255\"}.ion-usb:before{content:\"\\f2b8\"}.ion-videocamera:before{content:\"\\f256\"}.ion-volume-high:before{content:\"\\f257\"}.ion-volume-low:before{content:\"\\f258\"}.ion-volume-medium:before{content:\"\\f259\"}.ion-volume-mute:before{content:\"\\f25a\"}.ion-wand:before{content:\"\\f358\"}.ion-waterdrop:before{content:\"\\f25b\"}.ion-wifi:before{content:\"\\f25c\"}.ion-wineglass:before{content:\"\\f2b9\"}.ion-woman:before{content:\"\\f25d\"}.ion-wrench:before{content:\"\\f2ba\"}.ion-xbox:before{content:\"\\f30c\"}a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;vertical-align:baseline;font:inherit;font-size:100%}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:after,blockquote:before,q:after,q:before{content:'';content:none}audio:not([controls]){display:none;height:0}[hidden],template{display:none}script{display:none!important}html{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;font-family:sans-serif;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0;line-height:1}:focus,a,a:active,a:focus,a:hover,button,button:focus{outline:0}a{-webkit-user-drag:none;-webkit-tap-highlight-color:transparent;-webkit-tap-highlight-color:transparent}a[href]:hover{cursor:pointer}b,strong{font-weight:700}dfn{font-style:italic}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}code,kbd,pre,samp{font-size:1em;font-family:monospace,serif}pre{white-space:pre-wrap}q{quotes:\"\\201C\" \"\\201D\" \"\\2018\" \"\\2019\"}small{font-size:80%}sub,sup{position:relative;vertical-align:baseline;font-size:75%;line-height:0}sup{top:-.5em}sub{bottom:-.25em}fieldset{margin:0 2px;padding:.35em .625em .75em;border:1px solid silver}legend{padding:0;border:0}button,input,select,textarea{margin:0;font-size:100%;font-family:inherit;outline-offset:0;outline-style:none;outline-width:0;-webkit-font-smoothing:inherit;background-image:none}button,input{line-height:normal}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{cursor:pointer;-webkit-appearance:button}button[disabled],html input[disabled]{cursor:default}input[type=search]{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;-webkit-appearance:textfield}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}textarea{overflow:auto;vertical-align:top}img{-webkit-user-drag:none}table{border-spacing:0;border-collapse:collapse}*,:after,:before{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}html{overflow:hidden;-ms-touch-action:pan-y;touch-action:pan-y}.ionic-body,body{-webkit-touch-callout:none;-webkit-font-smoothing:antialiased;font-smoothing:antialiased;-webkit-text-size-adjust:none;-moz-text-size-adjust:none;text-size-adjust:none;-webkit-tap-highlight-color:transparent;-webkit-tap-highlight-color:transparent;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;top:0;right:0;bottom:0;left:0;overflow:hidden;margin:0;padding:0;color:#000;word-wrap:break-word;font-size:14px;font-family:\"Helvetica Neue\",Roboto,\"Segoe UI\",sans-serif;line-height:20px;text-rendering:optimizeLegibility;-webkit-backface-visibility:hidden;-webkit-user-drag:none;-ms-content-zooming:none}body.grade-b,body.grade-c{text-rendering:auto}.content{position:relative}.scroll-content{position:absolute;top:0;right:0;bottom:0;left:0;overflow:hidden;margin-top:-1px;padding-top:1px;margin-bottom:-1px;width:auto;height:auto}.menu .scroll-content.scroll-content-false{z-index:11}.scroll-view{position:relative;display:block;overflow:hidden;margin-top:-1px}.scroll{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-touch-callout:none;-webkit-text-size-adjust:none;-moz-text-size-adjust:none;text-size-adjust:none;-webkit-transform-origin:left top;transform-origin:left top}@-ms-viewport{width:device-width}.scroll-bar{position:absolute;z-index:9999}.ng-animate .scroll-bar{visibility:hidden}.scroll-bar-h{right:2px;bottom:3px;left:2px;height:3px}.scroll-bar-h .scroll-bar-indicator{height:100%}.scroll-bar-v{top:2px;right:3px;bottom:2px;width:3px}.scroll-bar-v .scroll-bar-indicator{width:100%}.scroll-bar-indicator{position:absolute;border-radius:4px;background:rgba(0,0,0,.3);opacity:1;-webkit-transition:opacity .3s linear;transition:opacity .3s linear}.scroll-bar-indicator.scroll-bar-fade-out{opacity:0}.platform-android .scroll-bar-indicator{border-radius:0}.grade-b .scroll-bar-indicator,.grade-c .scroll-bar-indicator{background:#aaa}.grade-b .scroll-bar-indicator.scroll-bar-fade-out,.grade-c .scroll-bar-indicator.scroll-bar-fade-out{-webkit-transition:none;transition:none}ion-infinite-scroll{height:60px;width:100%;display:block;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-direction:normal;-webkit-box-orient:horizontal;-webkit-flex-direction:row;-moz-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;-moz-justify-content:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center}ion-infinite-scroll .icon{color:#666;font-size:30px;color:#666}ion-infinite-scroll:not(.active) .icon:before,ion-infinite-scroll:not(.active) .spinner{display:none}.overflow-scroll{overflow-x:hidden;overflow-y:scroll;-webkit-overflow-scrolling:touch;top:0;right:0;bottom:0;left:0;position:absolute}.overflow-scroll .scroll{position:static;height:100%;-webkit-transform:translate3d(0,0,0)}.has-header{top:44px}.no-header{top:0}.has-subheader{top:88px}.has-tabs-top{top:93px}.has-header.has-subheader.has-tabs-top{top:137px}.has-footer{bottom:44px}.has-subfooter{bottom:88px}.bar-footer.has-tabs,.has-tabs{bottom:49px}.bar-footer.has-tabs.pane,.has-tabs.pane{bottom:49px;height:auto}.has-footer.has-tabs{bottom:93px}.pane{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);-webkit-transition-duration:0;transition-duration:0;z-index:1}.view{z-index:1}.pane,.view{position:absolute;top:0;right:0;bottom:0;left:0;width:100%;height:100%;background-color:#fff;overflow:hidden}.view-container{position:absolute;display:block;width:100%;height:100%}p{margin:0 0 10px}small{font-size:85%}cite{font-style:normal}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}.h1,.h2,.h3,.h4,.h5,.h6,h1,h2,h3,h4,h5,h6{color:#000;font-weight:500;font-family:\"Helvetica Neue\",Roboto,\"Segoe UI\",sans-serif;line-height:1.2}.h1 small,.h2 small,.h3 small,.h4 small,.h5 small,.h6 small,h1 small,h2 small,h3 small,h4 small,h5 small,h6 small{font-weight:400;line-height:1}.h1,.h2,.h3,h1,h2,h3{margin-top:20px;margin-bottom:10px}.h1:first-child,.h2:first-child,.h3:first-child,h1:first-child,h2:first-child,h3:first-child{margin-top:0}.h1+.h1,.h1+.h2,.h1+.h3,.h1+h1,.h1+h2,.h1+h3,.h2+.h1,.h2+.h2,.h2+.h3,.h2+h1,.h2+h2,.h2+h3,.h3+.h1,.h3+.h2,.h3+.h3,.h3+h1,.h3+h2,.h3+h3,h1+.h1,h1+.h2,h1+.h3,h1+h1,h1+h2,h1+h3,h2+.h1,h2+.h2,h2+.h3,h2+h1,h2+h2,h2+h3,h3+.h1,h3+.h2,h3+.h3,h3+h1,h3+h2,h3+h3{margin-top:10px}.h4,.h5,.h6,h4,h5,h6{margin-top:10px;margin-bottom:10px}.h1,h1{font-size:36px}.h2,h2{font-size:30px}.h3,h3{font-size:24px}.h4,h4{font-size:18px}.h5,h5{font-size:14px}.h6,h6{font-size:9pt}.h1 small,h1 small{font-size:24px}.h2 small,h2 small{font-size:18px}.h3 small,.h4 small,h3 small,h4 small{font-size:14px}dl{margin-bottom:20px}dd,dt{line-height:1.42857}dt{font-weight:700}blockquote{margin:0 0 20px;padding:10px 20px;border-left:5px solid gray}blockquote p{font-weight:300;font-size:17.5px;line-height:1.25}blockquote p:last-child{margin-bottom:0}blockquote small{display:block;line-height:1.42857}blockquote small:before{content:'\\2014 \\00A0'}blockquote:after,blockquote:before,q:after,q:before{content:\"\"}address{display:block;margin-bottom:20px;font-style:normal;line-height:1.42857}a.subdued{padding-right:10px;color:#888;text-decoration:none}a.subdued:hover{text-decoration:none}a.subdued:last-child{padding-right:0}.action-sheet-backdrop{-webkit-transition:background-color 150ms ease-in-out;transition:background-color 150ms ease-in-out;position:fixed;top:0;left:0;z-index:11;width:100%;height:100%;background-color:transparent}.action-sheet-backdrop.active{background-color:rgba(0,0,0,.4)}.action-sheet-wrapper{-webkit-transform:translate3d(0,100%,0);transform:translate3d(0,100%,0);-webkit-transition:all cubic-bezier(.36,.66,.04,1) .5s;transition:all cubic-bezier(.36,.66,.04,1) .5s;position:absolute;bottom:0;left:0;right:0;width:100%;max-width:500px;margin:auto}.action-sheet-up{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}.action-sheet{margin-left:8px;margin-right:8px;width:auto;z-index:11;overflow:hidden}.action-sheet .button{display:block;padding:1px;width:100%;border-radius:0;border-color:#d1d3d6;background-color:transparent;color:#007aff;font-size:21px}.action-sheet .button:hover{color:#007aff}.action-sheet .button.destructive{color:#ff3b30}.action-sheet .button.destructive:hover{color:#ff3b30}.action-sheet .button.activated,.action-sheet .button.active{box-shadow:none;border-color:#d1d3d6;color:#007aff;background:#e4e5e7}.action-sheet-has-icons .icon{position:absolute;left:1pc}.action-sheet-title{padding:1pc;color:#8f8f8f;text-align:center;font-size:13px}.action-sheet-group{margin-bottom:8px;border-radius:4px;background-color:#fff;overflow:hidden}.action-sheet-group .button{border-width:1px 0 0 0}.action-sheet-group .button:first-child:last-child{border-width:0}.action-sheet-options{background:#f1f2f3}.action-sheet-cancel .button{font-weight:500}.action-sheet-open{pointer-events:none}.action-sheet-open.modal-open .modal{pointer-events:none}.action-sheet-open .action-sheet-backdrop{pointer-events:auto}.platform-android .action-sheet-backdrop.active{background-color:rgba(0,0,0,.2)}.platform-android .action-sheet{margin:0}.platform-android .action-sheet .action-sheet-title,.platform-android .action-sheet .button{text-align:left;border-color:transparent;font-size:1pc;color:inherit}.platform-android .action-sheet .action-sheet-title{font-size:14px;padding:1pc;color:#666}.platform-android .action-sheet .button.activated,.platform-android .action-sheet .button.active{background:#e8e8e8}.platform-android .action-sheet-group{margin:0;border-radius:0;background-color:#fafafa}.platform-android .action-sheet-cancel{display:none}.platform-android .action-sheet-has-icons .button{padding-left:56px}.backdrop{position:fixed;top:0;left:0;z-index:11;width:100%;height:100%;background-color:rgba(0,0,0,.4);visibility:hidden;opacity:0;-webkit-transition:.1s opacity linear;transition:.1s opacity linear}.backdrop.visible{visibility:visible}.backdrop.active{opacity:1}.bar{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:absolute;right:0;left:0;z-index:9;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:5px;width:100%;height:44px;border-width:0;border-style:solid;border-top:1px solid transparent;border-bottom:1px solid #ddd;background-color:#fff;background-size:0}@media (min--moz-device-pixel-ratio:1.5),(-webkit-min-device-pixel-ratio:1.5),(min-device-pixel-ratio:1.5),(min-resolution:144dpi),(min-resolution:1.5dppx){.bar{border:none;background-image:linear-gradient(0deg,#ddd,#ddd 50%,transparent 50%);background-position:bottom;background-size:100% 1px;background-repeat:no-repeat}}.bar.bar-clear{border:none;background:0 0;color:#fff}.bar.bar-clear .button{color:#fff}.bar.bar-clear .title{color:#fff}.bar.item-input-inset .item-input-wrapper{margin-top:-1px}.bar.item-input-inset .item-input-wrapper input{padding-left:8px;width:94%;height:28px;background:0 0}.bar.bar-light{border-color:#ddd;background-color:#fff;background-image:linear-gradient(0deg,#ddd,#ddd 50%,transparent 50%);color:#444}.bar.bar-light .title{color:#444}.bar.bar-light.bar-footer{background-image:linear-gradient(180deg,#ddd,#ddd 50%,transparent 50%)}.bar.bar-stable{border-color:#b2b2b2;background-color:#f8f8f8;background-image:linear-gradient(0deg,#b2b2b2,#b2b2b2 50%,transparent 50%);color:#444}.bar.bar-stable .title{color:#444}.bar.bar-stable.bar-footer{background-image:linear-gradient(180deg,#b2b2b2,#b2b2b2 50%,transparent 50%)}.bar.bar-positive{border-color:#0c63ee;background-color:#387ef5;background-image:linear-gradient(0deg,#0c63ee,#0c63ee 50%,transparent 50%);color:#fff}.bar.bar-positive .title{color:#fff}.bar.bar-positive.bar-footer{background-image:linear-gradient(180deg,#0c63ee,#0c63ee 50%,transparent 50%)}.bar.bar-calm{border-color:#0a9ec7;background-color:#11c1f3;background-image:linear-gradient(0deg,#0a9ec7,#0a9ec7 50%,transparent 50%);color:#fff}.bar.bar-calm .title{color:#fff}.bar.bar-calm.bar-footer{background-image:linear-gradient(180deg,#0a9ec7,#0a9ec7 50%,transparent 50%)}.bar.bar-assertive{border-color:#e42012;background-color:#ef473a;background-image:linear-gradient(0deg,#e42012,#e42012 50%,transparent 50%);color:#fff}.bar.bar-assertive .title{color:#fff}.bar.bar-assertive.bar-footer{background-image:linear-gradient(180deg,#e42012,#e42012 50%,transparent 50%)}.bar.bar-balanced{border-color:#28a54c;background-color:#33cd5f;background-image:linear-gradient(0deg,#28a54c,#28a54c 50%,transparent 50%);color:#fff}.bar.bar-balanced .title{color:#fff}.bar.bar-balanced.bar-footer{background-image:linear-gradient(180deg,#28a54c,#0c63ee 50%,transparent 50%)}.bar.bar-energized{border-color:#e6b400;background-color:#ffc900;background-image:linear-gradient(0deg,#e6b400,#e6b400 50%,transparent 50%);color:#fff}.bar.bar-energized .title{color:#fff}.bar.bar-energized.bar-footer{background-image:linear-gradient(180deg,#e6b400,#e6b400 50%,transparent 50%)}.bar.bar-royal{border-color:#6b46e5;background-color:#886aea;background-image:linear-gradient(0deg,#6b46e5,#6b46e5 50%,transparent 50%);color:#fff}.bar.bar-royal .title{color:#fff}.bar.bar-royal.bar-footer{background-image:linear-gradient(180deg,#6b46e5,#6b46e5 50%,transparent 50%)}.bar.bar-dark{border-color:#111;background-color:#444;background-image:linear-gradient(0deg,#111,#111 50%,transparent 50%);color:#fff}.bar.bar-dark .title{color:#fff}.bar.bar-dark.bar-footer{background-image:linear-gradient(180deg,#111,#111 50%,transparent 50%)}.bar .title{position:absolute;top:0;right:0;left:0;z-index:0;overflow:hidden;margin:0 10px;min-width:30px;height:43px;text-align:center;text-overflow:ellipsis;white-space:nowrap;font-size:17px;font-weight:500;line-height:44px}.bar .title.title-left{text-align:left}.bar .title.title-right{text-align:right}.bar .title a{color:inherit}.bar .button{z-index:1;padding:0 8px;min-width:initial;min-height:31px;font-weight:400;font-size:13px;line-height:2pc}.bar .button .icon:before,.bar .button.button-icon:before,.bar .button.icon-left:before,.bar .button.icon-right:before,.bar .button.icon:before{padding-right:2px;padding-left:2px;font-size:20px;line-height:2pc}.bar .button.button-icon{font-size:17px}.bar .button.button-icon .icon:before,.bar .button.button-icon.icon-left:before,.bar .button.button-icon.icon-right:before,.bar .button.button-icon:before{vertical-align:top;font-size:2pc;line-height:2pc}.bar .button.button-clear{padding-right:2px;padding-left:2px;font-weight:300;font-size:17px}.bar .button.button-clear .icon:before,.bar .button.button-clear.icon-left:before,.bar .button.button-clear.icon-right:before,.bar .button.button-clear.icon:before{font-size:2pc;line-height:2pc}.bar .button.back-button{display:block;margin-right:5px;padding:0;white-space:nowrap;font-weight:400}.bar .button.back-button.activated,.bar .button.back-button.active{opacity:.2}.bar .button-bar>.button,.bar .buttons>.button{min-height:31px;line-height:2pc}.bar .button+.button-bar,.bar .button-bar+.button{margin-left:5px}.bar .buttons,.bar .buttons.primary-buttons,.bar .buttons.secondary-buttons{display:inherit}.bar .buttons span{display:inline-block}.bar .buttons-left span{margin-right:5px;display:inherit}.bar .buttons-right span{margin-left:5px;display:inherit}.bar .buttons.pull-right,.bar .title+.button:last-child,.bar .title+.buttons,.bar>.button+.button:last-child,.bar>.button.pull-right{position:absolute;top:5px;right:5px;bottom:5px}.platform-android .nav-bar-has-subheader .bar{background-image:none}.platform-android .bar .back-button .icon:before{font-size:24px}.platform-android .bar .title{font-size:19px;line-height:44px}.bar-light .button{border-color:#ddd;background-color:#fff;color:#444}.bar-light .button:hover{color:#444;text-decoration:none}.bar-light .button.activated,.bar-light .button.active{border-color:#ccc;background-color:#fafafa;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.bar-light .button.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#444;font-size:17px}.bar-light .button.button-icon{border-color:transparent;background:0 0}.bar-stable .button{border-color:#b2b2b2;background-color:#f8f8f8;color:#444}.bar-stable .button:hover{color:#444;text-decoration:none}.bar-stable .button.activated,.bar-stable .button.active{border-color:#a2a2a2;background-color:#e5e5e5;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.bar-stable .button.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#444;font-size:17px}.bar-stable .button.button-icon{border-color:transparent;background:0 0}.bar-positive .button{border-color:#0c63ee;background-color:#387ef5;color:#fff}.bar-positive .button:hover{color:#fff;text-decoration:none}.bar-positive .button.activated,.bar-positive .button.active{border-color:#0c63ee;background-color:#0c63ee;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.bar-positive .button.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#fff;font-size:17px}.bar-positive .button.button-icon{border-color:transparent;background:0 0}.bar-calm .button{border-color:#0a9ec7;background-color:#11c1f3;color:#fff}.bar-calm .button:hover{color:#fff;text-decoration:none}.bar-calm .button.activated,.bar-calm .button.active{border-color:#0a9ec7;background-color:#0a9ec7;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.bar-calm .button.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#fff;font-size:17px}.bar-calm .button.button-icon{border-color:transparent;background:0 0}.bar-assertive .button{border-color:#e42012;background-color:#ef473a;color:#fff}.bar-assertive .button:hover{color:#fff;text-decoration:none}.bar-assertive .button.activated,.bar-assertive .button.active{border-color:#e42012;background-color:#e42012;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.bar-assertive .button.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#fff;font-size:17px}.bar-assertive .button.button-icon{border-color:transparent;background:0 0}.bar-balanced .button{border-color:#28a54c;background-color:#33cd5f;color:#fff}.bar-balanced .button:hover{color:#fff;text-decoration:none}.bar-balanced .button.activated,.bar-balanced .button.active{border-color:#28a54c;background-color:#28a54c;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.bar-balanced .button.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#fff;font-size:17px}.bar-balanced .button.button-icon{border-color:transparent;background:0 0}.bar-energized .button{border-color:#e6b400;background-color:#ffc900;color:#fff}.bar-energized .button:hover{color:#fff;text-decoration:none}.bar-energized .button.activated,.bar-energized .button.active{border-color:#e6b400;background-color:#e6b400;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.bar-energized .button.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#fff;font-size:17px}.bar-energized .button.button-icon{border-color:transparent;background:0 0}.bar-royal .button{border-color:#6b46e5;background-color:#886aea;color:#fff}.bar-royal .button:hover{color:#fff;text-decoration:none}.bar-royal .button.activated,.bar-royal .button.active{border-color:#6b46e5;background-color:#6b46e5;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.bar-royal .button.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#fff;font-size:17px}.bar-royal .button.button-icon{border-color:transparent;background:0 0}.bar-dark .button{border-color:#111;background-color:#444;color:#fff}.bar-dark .button:hover{color:#fff;text-decoration:none}.bar-dark .button.activated,.bar-dark .button.active{border-color:#000;background-color:#262626;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.bar-dark .button.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#fff;font-size:17px}.bar-dark .button.button-icon{border-color:transparent;background:0 0}.bar-header{top:0;border-top-width:0;border-bottom-width:1px}.bar-header.has-tabs-top{border-bottom-width:0;background-image:none}.tabs-top .bar-header{border-bottom-width:0;background-image:none}.bar-footer{bottom:0;border-top-width:1px;border-bottom-width:0;background-position:top;height:44px}.bar-footer.item-input-inset{position:absolute}.bar-tabs{padding:0}.bar-subheader{top:44px;display:block;height:44px}.bar-subfooter{bottom:44px;display:block;height:44px}.nav-bar-block{position:absolute;top:0;right:0;left:0;z-index:9}.bar .back-button.hide,.bar .buttons .hide{display:none}.nav-bar-tabs-top .bar{background-image:none}.tabs{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-direction:normal;-webkit-box-orient:horizontal;-webkit-flex-direction:horizontal;-moz-flex-direction:horizontal;-ms-flex-direction:horizontal;flex-direction:horizontal;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;-moz-justify-content:center;justify-content:center;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);border-color:#b2b2b2;background-color:#f8f8f8;background-image:linear-gradient(0deg,#b2b2b2,#b2b2b2 50%,transparent 50%);color:#444;position:absolute;bottom:0;z-index:5;width:100%;height:49px;border-style:solid;border-top-width:1px;background-size:0;line-height:49px}.tabs .tab-item .badge{background-color:#444;color:#f8f8f8}@media (min--moz-device-pixel-ratio:1.5),(-webkit-min-device-pixel-ratio:1.5),(min-device-pixel-ratio:1.5),(min-resolution:144dpi),(min-resolution:1.5dppx){.tabs{padding-top:2px;border-top:none!important;border-bottom:none;background-position:top;background-size:100% 1px;background-repeat:no-repeat}}.tabs-light>.tabs,.tabs.tabs-light{border-color:#ddd;background-color:#fff;background-image:linear-gradient(0deg,#ddd,#ddd 50%,transparent 50%);color:#444}.tabs-light>.tabs .tab-item .badge,.tabs.tabs-light .tab-item .badge{background-color:#444;color:#fff}.tabs-stable>.tabs,.tabs.tabs-stable{border-color:#b2b2b2;background-color:#f8f8f8;background-image:linear-gradient(0deg,#b2b2b2,#b2b2b2 50%,transparent 50%);color:#444}.tabs-stable>.tabs .tab-item .badge,.tabs.tabs-stable .tab-item .badge{background-color:#444;color:#f8f8f8}.tabs-positive>.tabs,.tabs.tabs-positive{border-color:#0c63ee;background-color:#387ef5;background-image:linear-gradient(0deg,#0c63ee,#0c63ee 50%,transparent 50%);color:#fff}.tabs-positive>.tabs .tab-item .badge,.tabs.tabs-positive .tab-item .badge{background-color:#fff;color:#387ef5}.tabs-calm>.tabs,.tabs.tabs-calm{border-color:#0a9ec7;background-color:#11c1f3;background-image:linear-gradient(0deg,#0a9ec7,#0a9ec7 50%,transparent 50%);color:#fff}.tabs-calm>.tabs .tab-item .badge,.tabs.tabs-calm .tab-item .badge{background-color:#fff;color:#11c1f3}.tabs-assertive>.tabs,.tabs.tabs-assertive{border-color:#e42012;background-color:#ef473a;background-image:linear-gradient(0deg,#e42012,#e42012 50%,transparent 50%);color:#fff}.tabs-assertive>.tabs .tab-item .badge,.tabs.tabs-assertive .tab-item .badge{background-color:#fff;color:#ef473a}.tabs-balanced>.tabs,.tabs.tabs-balanced{border-color:#28a54c;background-color:#33cd5f;background-image:linear-gradient(0deg,#28a54c,#28a54c 50%,transparent 50%);color:#fff}.tabs-balanced>.tabs .tab-item .badge,.tabs.tabs-balanced .tab-item .badge{background-color:#fff;color:#33cd5f}.tabs-energized>.tabs,.tabs.tabs-energized{border-color:#e6b400;background-color:#ffc900;background-image:linear-gradient(0deg,#e6b400,#e6b400 50%,transparent 50%);color:#fff}.tabs-energized>.tabs .tab-item .badge,.tabs.tabs-energized .tab-item .badge{background-color:#fff;color:#ffc900}.tabs-royal>.tabs,.tabs.tabs-royal{border-color:#6b46e5;background-color:#886aea;background-image:linear-gradient(0deg,#6b46e5,#6b46e5 50%,transparent 50%);color:#fff}.tabs-royal>.tabs .tab-item .badge,.tabs.tabs-royal .tab-item .badge{background-color:#fff;color:#886aea}.tabs-dark>.tabs,.tabs.tabs-dark{border-color:#111;background-color:#444;background-image:linear-gradient(0deg,#111,#111 50%,transparent 50%);color:#fff}.tabs-dark>.tabs .tab-item .badge,.tabs.tabs-dark .tab-item .badge{background-color:#fff;color:#444}.tabs-striped .tabs{background-color:#fff;background-image:none;border:none;border-bottom:1px solid #ddd;padding-top:2px}.tabs-striped .tab-item.activated,.tabs-striped .tab-item.active,.tabs-striped .tab-item.tab-item-active{margin-top:-2px;border-style:solid;border-width:2px 0 0 0;border-color:#444}.tabs-striped .tab-item.activated .badge,.tabs-striped .tab-item.active .badge,.tabs-striped .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-light .tabs{background-color:#fff}.tabs-striped.tabs-light .tab-item{color:rgba(68,68,68,.4);opacity:1}.tabs-striped.tabs-light .tab-item .badge{opacity:.4}.tabs-striped.tabs-light .tab-item.activated,.tabs-striped.tabs-light .tab-item.active,.tabs-striped.tabs-light .tab-item.tab-item-active{margin-top:-2px;color:#444;border-style:solid;border-width:2px 0 0 0;border-color:#444}.tabs-striped.tabs-top .tab-item.activated .badge,.tabs-striped.tabs-top .tab-item.active .badge,.tabs-striped.tabs-top .tab-item.tab-item-active .badge{top:4%}.tabs-striped.tabs-stable .tabs{background-color:#f8f8f8}.tabs-striped.tabs-stable .tab-item{color:rgba(68,68,68,.4);opacity:1}.tabs-striped.tabs-stable .tab-item .badge{opacity:.4}.tabs-striped.tabs-stable .tab-item.activated,.tabs-striped.tabs-stable .tab-item.active,.tabs-striped.tabs-stable .tab-item.tab-item-active{margin-top:-2px;color:#444;border-style:solid;border-width:2px 0 0 0;border-color:#444}.tabs-striped.tabs-top .tab-item.activated .badge,.tabs-striped.tabs-top .tab-item.active .badge,.tabs-striped.tabs-top .tab-item.tab-item-active .badge{top:4%}.tabs-striped.tabs-positive .tabs{background-color:#387ef5}.tabs-striped.tabs-positive .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-positive .tab-item .badge{opacity:.4}.tabs-striped.tabs-positive .tab-item.activated,.tabs-striped.tabs-positive .tab-item.active,.tabs-striped.tabs-positive .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0 0;border-color:#fff}.tabs-striped.tabs-top .tab-item.activated .badge,.tabs-striped.tabs-top .tab-item.active .badge,.tabs-striped.tabs-top .tab-item.tab-item-active .badge{top:4%}.tabs-striped.tabs-calm .tabs{background-color:#11c1f3}.tabs-striped.tabs-calm .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-calm .tab-item .badge{opacity:.4}.tabs-striped.tabs-calm .tab-item.activated,.tabs-striped.tabs-calm .tab-item.active,.tabs-striped.tabs-calm .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0 0;border-color:#fff}.tabs-striped.tabs-top .tab-item.activated .badge,.tabs-striped.tabs-top .tab-item.active .badge,.tabs-striped.tabs-top .tab-item.tab-item-active .badge{top:4%}.tabs-striped.tabs-assertive .tabs{background-color:#ef473a}.tabs-striped.tabs-assertive .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-assertive .tab-item .badge{opacity:.4}.tabs-striped.tabs-assertive .tab-item.activated,.tabs-striped.tabs-assertive .tab-item.active,.tabs-striped.tabs-assertive .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0 0;border-color:#fff}.tabs-striped.tabs-top .tab-item.activated .badge,.tabs-striped.tabs-top .tab-item.active .badge,.tabs-striped.tabs-top .tab-item.tab-item-active .badge{top:4%}.tabs-striped.tabs-balanced .tabs{background-color:#33cd5f}.tabs-striped.tabs-balanced .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-balanced .tab-item .badge{opacity:.4}.tabs-striped.tabs-balanced .tab-item.activated,.tabs-striped.tabs-balanced .tab-item.active,.tabs-striped.tabs-balanced .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0 0;border-color:#fff}.tabs-striped.tabs-top .tab-item.activated .badge,.tabs-striped.tabs-top .tab-item.active .badge,.tabs-striped.tabs-top .tab-item.tab-item-active .badge{top:4%}.tabs-striped.tabs-energized .tabs{background-color:#ffc900}.tabs-striped.tabs-energized .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-energized .tab-item .badge{opacity:.4}.tabs-striped.tabs-energized .tab-item.activated,.tabs-striped.tabs-energized .tab-item.active,.tabs-striped.tabs-energized .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0 0;border-color:#fff}.tabs-striped.tabs-top .tab-item.activated .badge,.tabs-striped.tabs-top .tab-item.active .badge,.tabs-striped.tabs-top .tab-item.tab-item-active .badge{top:4%}.tabs-striped.tabs-royal .tabs{background-color:#886aea}.tabs-striped.tabs-royal .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-royal .tab-item .badge{opacity:.4}.tabs-striped.tabs-royal .tab-item.activated,.tabs-striped.tabs-royal .tab-item.active,.tabs-striped.tabs-royal .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0 0;border-color:#fff}.tabs-striped.tabs-top .tab-item.activated .badge,.tabs-striped.tabs-top .tab-item.active .badge,.tabs-striped.tabs-top .tab-item.tab-item-active .badge{top:4%}.tabs-striped.tabs-dark .tabs{background-color:#444}.tabs-striped.tabs-dark .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-dark .tab-item .badge{opacity:.4}.tabs-striped.tabs-dark .tab-item.activated,.tabs-striped.tabs-dark .tab-item.active,.tabs-striped.tabs-dark .tab-item.tab-item-active{margin-top:-2px;color:#fff;border-style:solid;border-width:2px 0 0 0;border-color:#fff}.tabs-striped.tabs-top .tab-item.activated .badge,.tabs-striped.tabs-top .tab-item.active .badge,.tabs-striped.tabs-top .tab-item.tab-item-active .badge{top:4%}.tabs-striped.tabs-background-light .tabs{background-color:#fff;background-image:none}.tabs-striped.tabs-background-stable .tabs{background-color:#f8f8f8;background-image:none}.tabs-striped.tabs-background-positive .tabs{background-color:#387ef5;background-image:none}.tabs-striped.tabs-background-calm .tabs{background-color:#11c1f3;background-image:none}.tabs-striped.tabs-background-assertive .tabs{background-color:#ef473a;background-image:none}.tabs-striped.tabs-background-balanced .tabs{background-color:#33cd5f;background-image:none}.tabs-striped.tabs-background-energized .tabs{background-color:#ffc900;background-image:none}.tabs-striped.tabs-background-royal .tabs{background-color:#886aea;background-image:none}.tabs-striped.tabs-background-dark .tabs{background-color:#444;background-image:none}.tabs-striped.tabs-color-light .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-striped.tabs-color-light .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-light .tab-item.activated,.tabs-striped.tabs-color-light .tab-item.active,.tabs-striped.tabs-color-light .tab-item.tab-item-active{margin-top:-2px;color:#fff;border:0 solid #fff;border-top-width:2px}.tabs-striped.tabs-color-light .tab-item.activated .badge,.tabs-striped.tabs-color-light .tab-item.active .badge,.tabs-striped.tabs-color-light .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-stable .tab-item{color:rgba(248,248,248,.4);opacity:1}.tabs-striped.tabs-color-stable .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-stable .tab-item.activated,.tabs-striped.tabs-color-stable .tab-item.active,.tabs-striped.tabs-color-stable .tab-item.tab-item-active{margin-top:-2px;color:#f8f8f8;border:0 solid #f8f8f8;border-top-width:2px}.tabs-striped.tabs-color-stable .tab-item.activated .badge,.tabs-striped.tabs-color-stable .tab-item.active .badge,.tabs-striped.tabs-color-stable .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-positive .tab-item{color:rgba(56,126,245,.4);opacity:1}.tabs-striped.tabs-color-positive .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-positive .tab-item.activated,.tabs-striped.tabs-color-positive .tab-item.active,.tabs-striped.tabs-color-positive .tab-item.tab-item-active{margin-top:-2px;color:#387ef5;border:0 solid #387ef5;border-top-width:2px}.tabs-striped.tabs-color-positive .tab-item.activated .badge,.tabs-striped.tabs-color-positive .tab-item.active .badge,.tabs-striped.tabs-color-positive .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-calm .tab-item{color:rgba(17,193,243,.4);opacity:1}.tabs-striped.tabs-color-calm .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-calm .tab-item.activated,.tabs-striped.tabs-color-calm .tab-item.active,.tabs-striped.tabs-color-calm .tab-item.tab-item-active{margin-top:-2px;color:#11c1f3;border:0 solid #11c1f3;border-top-width:2px}.tabs-striped.tabs-color-calm .tab-item.activated .badge,.tabs-striped.tabs-color-calm .tab-item.active .badge,.tabs-striped.tabs-color-calm .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-assertive .tab-item{color:rgba(239,71,58,.4);opacity:1}.tabs-striped.tabs-color-assertive .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-assertive .tab-item.activated,.tabs-striped.tabs-color-assertive .tab-item.active,.tabs-striped.tabs-color-assertive .tab-item.tab-item-active{margin-top:-2px;color:#ef473a;border:0 solid #ef473a;border-top-width:2px}.tabs-striped.tabs-color-assertive .tab-item.activated .badge,.tabs-striped.tabs-color-assertive .tab-item.active .badge,.tabs-striped.tabs-color-assertive .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-balanced .tab-item{color:rgba(51,205,95,.4);opacity:1}.tabs-striped.tabs-color-balanced .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-balanced .tab-item.activated,.tabs-striped.tabs-color-balanced .tab-item.active,.tabs-striped.tabs-color-balanced .tab-item.tab-item-active{margin-top:-2px;color:#33cd5f;border:0 solid #33cd5f;border-top-width:2px}.tabs-striped.tabs-color-balanced .tab-item.activated .badge,.tabs-striped.tabs-color-balanced .tab-item.active .badge,.tabs-striped.tabs-color-balanced .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-energized .tab-item{color:rgba(255,201,0,.4);opacity:1}.tabs-striped.tabs-color-energized .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-energized .tab-item.activated,.tabs-striped.tabs-color-energized .tab-item.active,.tabs-striped.tabs-color-energized .tab-item.tab-item-active{margin-top:-2px;color:#ffc900;border:0 solid #ffc900;border-top-width:2px}.tabs-striped.tabs-color-energized .tab-item.activated .badge,.tabs-striped.tabs-color-energized .tab-item.active .badge,.tabs-striped.tabs-color-energized .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-royal .tab-item{color:rgba(136,106,234,.4);opacity:1}.tabs-striped.tabs-color-royal .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-royal .tab-item.activated,.tabs-striped.tabs-color-royal .tab-item.active,.tabs-striped.tabs-color-royal .tab-item.tab-item-active{margin-top:-2px;color:#886aea;border:0 solid #886aea;border-top-width:2px}.tabs-striped.tabs-color-royal .tab-item.activated .badge,.tabs-striped.tabs-color-royal .tab-item.active .badge,.tabs-striped.tabs-color-royal .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-striped.tabs-color-dark .tab-item{color:rgba(68,68,68,.4);opacity:1}.tabs-striped.tabs-color-dark .tab-item .badge{opacity:.4}.tabs-striped.tabs-color-dark .tab-item.activated,.tabs-striped.tabs-color-dark .tab-item.active,.tabs-striped.tabs-color-dark .tab-item.tab-item-active{margin-top:-2px;color:#444;border:0 solid #444;border-top-width:2px}.tabs-striped.tabs-color-dark .tab-item.activated .badge,.tabs-striped.tabs-color-dark .tab-item.active .badge,.tabs-striped.tabs-color-dark .tab-item.tab-item-active .badge{top:2px;opacity:1}.tabs-background-light .tabs,.tabs-background-light>.tabs{background-color:#fff;background-image:linear-gradient(0deg,#ddd,#ddd 50%,transparent 50%);border-color:#ddd}.tabs-background-stable .tabs,.tabs-background-stable>.tabs{background-color:#f8f8f8;background-image:linear-gradient(0deg,#b2b2b2,#b2b2b2 50%,transparent 50%);border-color:#b2b2b2}.tabs-background-positive .tabs,.tabs-background-positive>.tabs{background-color:#387ef5;background-image:linear-gradient(0deg,#0c63ee,#0c63ee 50%,transparent 50%);border-color:#0c63ee}.tabs-background-calm .tabs,.tabs-background-calm>.tabs{background-color:#11c1f3;background-image:linear-gradient(0deg,#0a9ec7,#0a9ec7 50%,transparent 50%);border-color:#0a9ec7}.tabs-background-assertive .tabs,.tabs-background-assertive>.tabs{background-color:#ef473a;background-image:linear-gradient(0deg,#e42012,#e42012 50%,transparent 50%);border-color:#e42012}.tabs-background-balanced .tabs,.tabs-background-balanced>.tabs{background-color:#33cd5f;background-image:linear-gradient(0deg,#28a54c,#28a54c 50%,transparent 50%);border-color:#28a54c}.tabs-background-energized .tabs,.tabs-background-energized>.tabs{background-color:#ffc900;background-image:linear-gradient(0deg,#e6b400,#e6b400 50%,transparent 50%);border-color:#e6b400}.tabs-background-royal .tabs,.tabs-background-royal>.tabs{background-color:#886aea;background-image:linear-gradient(0deg,#6b46e5,#6b46e5 50%,transparent 50%);border-color:#6b46e5}.tabs-background-dark .tabs,.tabs-background-dark>.tabs{background-color:#444;background-image:linear-gradient(0deg,#111,#111 50%,transparent 50%);border-color:#111}.tabs-color-light .tab-item{color:rgba(255,255,255,.4);opacity:1}.tabs-color-light .tab-item .badge{opacity:.4}.tabs-color-light .tab-item.activated,.tabs-color-light .tab-item.active,.tabs-color-light .tab-item.tab-item-active{color:#fff;border:0 solid #fff}.tabs-color-light .tab-item.activated .badge,.tabs-color-light .tab-item.active .badge,.tabs-color-light .tab-item.tab-item-active .badge{opacity:1}.tabs-color-stable .tab-item{color:rgba(248,248,248,.4);opacity:1}.tabs-color-stable .tab-item .badge{opacity:.4}.tabs-color-stable .tab-item.activated,.tabs-color-stable .tab-item.active,.tabs-color-stable .tab-item.tab-item-active{color:#f8f8f8;border:0 solid #f8f8f8}.tabs-color-stable .tab-item.activated .badge,.tabs-color-stable .tab-item.active .badge,.tabs-color-stable .tab-item.tab-item-active .badge{opacity:1}.tabs-color-positive .tab-item{color:rgba(56,126,245,.4);opacity:1}.tabs-color-positive .tab-item .badge{opacity:.4}.tabs-color-positive .tab-item.activated,.tabs-color-positive .tab-item.active,.tabs-color-positive .tab-item.tab-item-active{color:#387ef5;border:0 solid #387ef5}.tabs-color-positive .tab-item.activated .badge,.tabs-color-positive .tab-item.active .badge,.tabs-color-positive .tab-item.tab-item-active .badge{opacity:1}.tabs-color-calm .tab-item{color:rgba(17,193,243,.4);opacity:1}.tabs-color-calm .tab-item .badge{opacity:.4}.tabs-color-calm .tab-item.activated,.tabs-color-calm .tab-item.active,.tabs-color-calm .tab-item.tab-item-active{color:#11c1f3;border:0 solid #11c1f3}.tabs-color-calm .tab-item.activated .badge,.tabs-color-calm .tab-item.active .badge,.tabs-color-calm .tab-item.tab-item-active .badge{opacity:1}.tabs-color-assertive .tab-item{color:rgba(239,71,58,.4);opacity:1}.tabs-color-assertive .tab-item .badge{opacity:.4}.tabs-color-assertive .tab-item.activated,.tabs-color-assertive .tab-item.active,.tabs-color-assertive .tab-item.tab-item-active{color:#ef473a;border:0 solid #ef473a}.tabs-color-assertive .tab-item.activated .badge,.tabs-color-assertive .tab-item.active .badge,.tabs-color-assertive .tab-item.tab-item-active .badge{opacity:1}.tabs-color-balanced .tab-item{color:rgba(51,205,95,.4);opacity:1}.tabs-color-balanced .tab-item .badge{opacity:.4}.tabs-color-balanced .tab-item.activated,.tabs-color-balanced .tab-item.active,.tabs-color-balanced .tab-item.tab-item-active{color:#33cd5f;border:0 solid #33cd5f}.tabs-color-balanced .tab-item.activated .badge,.tabs-color-balanced .tab-item.active .badge,.tabs-color-balanced .tab-item.tab-item-active .badge{opacity:1}.tabs-color-energized .tab-item{color:rgba(255,201,0,.4);opacity:1}.tabs-color-energized .tab-item .badge{opacity:.4}.tabs-color-energized .tab-item.activated,.tabs-color-energized .tab-item.active,.tabs-color-energized .tab-item.tab-item-active{color:#ffc900;border:0 solid #ffc900}.tabs-color-energized .tab-item.activated .badge,.tabs-color-energized .tab-item.active .badge,.tabs-color-energized .tab-item.tab-item-active .badge{opacity:1}.tabs-color-royal .tab-item{color:rgba(136,106,234,.4);opacity:1}.tabs-color-royal .tab-item .badge{opacity:.4}.tabs-color-royal .tab-item.activated,.tabs-color-royal .tab-item.active,.tabs-color-royal .tab-item.tab-item-active{color:#886aea;border:0 solid #886aea}.tabs-color-royal .tab-item.activated .badge,.tabs-color-royal .tab-item.active .badge,.tabs-color-royal .tab-item.tab-item-active .badge{opacity:1}.tabs-color-dark .tab-item{color:rgba(68,68,68,.4);opacity:1}.tabs-color-dark .tab-item .badge{opacity:.4}.tabs-color-dark .tab-item.activated,.tabs-color-dark .tab-item.active,.tabs-color-dark .tab-item.tab-item-active{color:#444;border:0 solid #444}.tabs-color-dark .tab-item.activated .badge,.tabs-color-dark .tab-item.active .badge,.tabs-color-dark .tab-item.tab-item-active .badge{opacity:1}ion-tabs.tabs-color-active-light .tab-item{color:#444}ion-tabs.tabs-color-active-light .tab-item.activated,ion-tabs.tabs-color-active-light .tab-item.active,ion-tabs.tabs-color-active-light .tab-item.tab-item-active{color:#fff}ion-tabs.tabs-color-active-stable .tab-item{color:#444}ion-tabs.tabs-color-active-stable .tab-item.activated,ion-tabs.tabs-color-active-stable .tab-item.active,ion-tabs.tabs-color-active-stable .tab-item.tab-item-active{color:#f8f8f8}ion-tabs.tabs-color-active-positive .tab-item{color:#444}ion-tabs.tabs-color-active-positive .tab-item.activated,ion-tabs.tabs-color-active-positive .tab-item.active,ion-tabs.tabs-color-active-positive .tab-item.tab-item-active{color:#387ef5}ion-tabs.tabs-color-active-calm .tab-item{color:#444}ion-tabs.tabs-color-active-calm .tab-item.activated,ion-tabs.tabs-color-active-calm .tab-item.active,ion-tabs.tabs-color-active-calm .tab-item.tab-item-active{color:#11c1f3}ion-tabs.tabs-color-active-assertive .tab-item{color:#444}ion-tabs.tabs-color-active-assertive .tab-item.activated,ion-tabs.tabs-color-active-assertive .tab-item.active,ion-tabs.tabs-color-active-assertive .tab-item.tab-item-active{color:#ef473a}ion-tabs.tabs-color-active-balanced .tab-item{color:#444}ion-tabs.tabs-color-active-balanced .tab-item.activated,ion-tabs.tabs-color-active-balanced .tab-item.active,ion-tabs.tabs-color-active-balanced .tab-item.tab-item-active{color:#33cd5f}ion-tabs.tabs-color-active-energized .tab-item{color:#444}ion-tabs.tabs-color-active-energized .tab-item.activated,ion-tabs.tabs-color-active-energized .tab-item.active,ion-tabs.tabs-color-active-energized .tab-item.tab-item-active{color:#ffc900}ion-tabs.tabs-color-active-royal .tab-item{color:#444}ion-tabs.tabs-color-active-royal .tab-item.activated,ion-tabs.tabs-color-active-royal .tab-item.active,ion-tabs.tabs-color-active-royal .tab-item.tab-item-active{color:#886aea}ion-tabs.tabs-color-active-dark .tab-item{color:#fff}ion-tabs.tabs-color-active-dark .tab-item.activated,ion-tabs.tabs-color-active-dark .tab-item.active,ion-tabs.tabs-color-active-dark .tab-item.tab-item-active{color:#444}.tabs-top.tabs-striped{padding-bottom:0}.tabs-top.tabs-striped .tab-item{background:0 0;-webkit-transition:color .1s ease;-moz-transition:color .1s ease;-ms-transition:color .1s ease;-o-transition:color .1s ease;transition:color .1s ease}.tabs-top.tabs-striped .tab-item.activated,.tabs-top.tabs-striped .tab-item.active,.tabs-top.tabs-striped .tab-item.tab-item-active{margin-top:1px;border-width:0 0 2px 0!important;border-style:solid}.tabs-top.tabs-striped .tab-item.activated>.badge,.tabs-top.tabs-striped .tab-item.activated>i,.tabs-top.tabs-striped .tab-item.active>.badge,.tabs-top.tabs-striped .tab-item.active>i,.tabs-top.tabs-striped .tab-item.tab-item-active>.badge,.tabs-top.tabs-striped .tab-item.tab-item-active>i{margin-top:-1px}.tabs-top.tabs-striped .tab-item .badge{-webkit-transition:color .2s ease;-moz-transition:color .2s ease;-ms-transition:color .2s ease;-o-transition:color .2s ease;transition:color .2s ease}.tabs-top.tabs-striped:not(.tabs-icon-left):not(.tabs-icon-top) .tab-item.activated .tab-title,.tabs-top.tabs-striped:not(.tabs-icon-left):not(.tabs-icon-top) .tab-item.activated i,.tabs-top.tabs-striped:not(.tabs-icon-left):not(.tabs-icon-top) .tab-item.active .tab-title,.tabs-top.tabs-striped:not(.tabs-icon-left):not(.tabs-icon-top) .tab-item.active i,.tabs-top.tabs-striped:not(.tabs-icon-left):not(.tabs-icon-top) .tab-item.tab-item-active .tab-title,.tabs-top.tabs-striped:not(.tabs-icon-left):not(.tabs-icon-top) .tab-item.tab-item-active i{display:block;margin-top:-1px}.tabs-top.tabs-striped.tabs-icon-left .tab-item{margin-top:1px}.tabs-top.tabs-striped.tabs-icon-left .tab-item.activated .tab-title,.tabs-top.tabs-striped.tabs-icon-left .tab-item.activated i,.tabs-top.tabs-striped.tabs-icon-left .tab-item.active .tab-title,.tabs-top.tabs-striped.tabs-icon-left .tab-item.active i,.tabs-top.tabs-striped.tabs-icon-left .tab-item.tab-item-active .tab-title,.tabs-top.tabs-striped.tabs-icon-left .tab-item.tab-item-active i{margin-top:-.1em}.tabs-top>.tabs,.tabs.tabs-top{top:44px;padding-top:0;background-position:bottom;border-top-width:0;border-bottom-width:1px}.tabs-top>.tabs .tab-item.activated .badge,.tabs-top>.tabs .tab-item.active .badge,.tabs-top>.tabs .tab-item.tab-item-active .badge,.tabs.tabs-top .tab-item.activated .badge,.tabs.tabs-top .tab-item.active .badge,.tabs.tabs-top .tab-item.tab-item-active .badge{top:4%}.tabs-top~.bar-header{border-bottom-width:0}.tab-item{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;display:block;overflow:hidden;max-width:150px;height:100%;color:inherit;text-align:center;text-decoration:none;text-overflow:ellipsis;white-space:nowrap;font-weight:400;font-size:14px;font-family:\"Helvetica Neue\",Roboto,\"Segoe UI\",sans-serif;opacity:.7}.tab-item:hover{cursor:pointer}.tab-item.tab-hidden{display:none}.tabs-item-hide>.tabs,.tabs.tabs-item-hide{display:none}.tabs-icon-bottom.tabs .tab-item,.tabs-icon-bottom>.tabs .tab-item,.tabs-icon-top.tabs .tab-item,.tabs-icon-top>.tabs .tab-item{font-size:10px;line-height:14px}.tab-item .icon{display:block;margin:0 auto;height:2pc;font-size:2pc}.tabs-icon-left.tabs .tab-item,.tabs-icon-left>.tabs .tab-item,.tabs-icon-right.tabs .tab-item,.tabs-icon-right>.tabs .tab-item{font-size:10px}.tabs-icon-left.tabs .tab-item .icon,.tabs-icon-left.tabs .tab-item .tab-title,.tabs-icon-left>.tabs .tab-item .icon,.tabs-icon-left>.tabs .tab-item .tab-title,.tabs-icon-right.tabs .tab-item .icon,.tabs-icon-right.tabs .tab-item .tab-title,.tabs-icon-right>.tabs .tab-item .icon,.tabs-icon-right>.tabs .tab-item .tab-title{display:inline-block;vertical-align:top;margin-top:-.1em}.tabs-icon-left.tabs .tab-item .icon:before,.tabs-icon-left.tabs .tab-item .tab-title:before,.tabs-icon-left>.tabs .tab-item .icon:before,.tabs-icon-left>.tabs .tab-item .tab-title:before,.tabs-icon-right.tabs .tab-item .icon:before,.tabs-icon-right.tabs .tab-item .tab-title:before,.tabs-icon-right>.tabs .tab-item .icon:before,.tabs-icon-right>.tabs .tab-item .tab-title:before{font-size:24px;line-height:49px}.tabs-icon-left.tabs .tab-item .icon,.tabs-icon-left>.tabs .tab-item .icon{padding-right:3px}.tabs-icon-right.tabs .tab-item .icon,.tabs-icon-right>.tabs .tab-item .icon{padding-left:3px}.tabs-icon-only.tabs .icon,.tabs-icon-only>.tabs .icon{line-height:inherit}.tab-item.has-badge{position:relative}.tab-item .badge{position:absolute;top:4%;right:33%;right:calc(50% - 26px);padding:1px 6px;height:auto;font-size:9pt;line-height:1pc}.tab-item.activated,.tab-item.active,.tab-item.tab-item-active{opacity:1}.tab-item.activated.tab-item-light,.tab-item.active.tab-item-light,.tab-item.tab-item-active.tab-item-light{color:#fff}.tab-item.activated.tab-item-stable,.tab-item.active.tab-item-stable,.tab-item.tab-item-active.tab-item-stable{color:#f8f8f8}.tab-item.activated.tab-item-positive,.tab-item.active.tab-item-positive,.tab-item.tab-item-active.tab-item-positive{color:#387ef5}.tab-item.activated.tab-item-calm,.tab-item.active.tab-item-calm,.tab-item.tab-item-active.tab-item-calm{color:#11c1f3}.tab-item.activated.tab-item-assertive,.tab-item.active.tab-item-assertive,.tab-item.tab-item-active.tab-item-assertive{color:#ef473a}.tab-item.activated.tab-item-balanced,.tab-item.active.tab-item-balanced,.tab-item.tab-item-active.tab-item-balanced{color:#33cd5f}.tab-item.activated.tab-item-energized,.tab-item.active.tab-item-energized,.tab-item.tab-item-active.tab-item-energized{color:#ffc900}.tab-item.activated.tab-item-royal,.tab-item.active.tab-item-royal,.tab-item.tab-item-active.tab-item-royal{color:#886aea}.tab-item.activated.tab-item-dark,.tab-item.active.tab-item-dark,.tab-item.tab-item-active.tab-item-dark{color:#444}.item.tabs{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;padding:0}.item.tabs .icon:before{position:relative}.tab-item.disabled,.tab-item[disabled]{opacity:.4;cursor:default;pointer-events:none}.nav-bar-tabs-top.hide~.view-container .tabs-top .tabs{top:0}.pane[hide-nav-bar=true] .has-tabs-top{top:49px}.menu{position:absolute;top:0;bottom:0;z-index:0;overflow:hidden;min-height:100%;max-height:100%;width:275px;background-color:#fff}.menu .scroll-content{z-index:10}.menu .bar-header{z-index:11}.menu-content{-webkit-transform:none;transform:none;box-shadow:-1px 0 2px rgba(0,0,0,.2),1px 0 2px rgba(0,0,0,.2)}.menu-open .menu-content .pane,.menu-open .menu-content .scroll-content{pointer-events:none;overflow:hidden}.grade-b .menu-content,.grade-c .menu-content{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;right:-1px;left:-1px;border-right:1px solid #ccc;border-left:1px solid #ccc;box-shadow:none}.menu-left{left:0}.menu-right{right:0}.aside-open.aside-resizing .menu-right{display:none}.menu-animated{-webkit-transition:-webkit-transform .2s ease;transition:transform .2s ease}.modal-backdrop,.modal-backdrop-bg{position:fixed;top:0;left:0;z-index:10;width:100%;height:100%}.modal-backdrop-bg{pointer-events:none}.modal{display:block;position:absolute;top:0;z-index:10;overflow:hidden;min-height:100%;width:100%;background-color:#fff}@media (min-width:680px){.modal{top:20%;right:20%;bottom:20%;left:20%;min-height:15pc;width:60%}.modal.ng-leave-active{bottom:0}.platform-ios.platform-cordova .modal-wrapper .modal .bar-header:not(.bar-subheader){height:44px}.platform-ios.platform-cordova .modal-wrapper .modal .bar-header:not(.bar-subheader)>*{margin-top:0}.platform-ios.platform-cordova .modal-wrapper .modal .tabs-top>.tabs,.platform-ios.platform-cordova .modal-wrapper .modal .tabs.tabs-top{top:44px}.platform-ios.platform-cordova .modal-wrapper .modal .bar-subheader,.platform-ios.platform-cordova .modal-wrapper .modal .has-header{top:44px}.platform-ios.platform-cordova .modal-wrapper .modal .has-subheader{top:88px}.platform-ios.platform-cordova .modal-wrapper .modal .has-header.has-tabs-top{top:93px}.platform-ios.platform-cordova .modal-wrapper .modal .has-header.has-subheader.has-tabs-top{top:137px}.modal-backdrop-bg{-webkit-transition:opacity .3s ease-in-out;transition:opacity .3s ease-in-out;background-color:#000;opacity:0}.active .modal-backdrop-bg{opacity:.5}}.modal-open{pointer-events:none}.modal-open .modal,.modal-open .modal-backdrop{pointer-events:auto}.modal-open.loading-active .modal,.modal-open.loading-active .modal-backdrop{pointer-events:none}.popover-backdrop{position:fixed;top:0;left:0;z-index:10;width:100%;height:100%;background-color:transparent}.popover-backdrop.active{background-color:rgba(0,0,0,.1)}.popover{position:absolute;top:25%;left:50%;z-index:10;display:block;margin-top:9pt;margin-left:-110px;height:280px;width:220px;background-color:#fff;box-shadow:0 1px 3px rgba(0,0,0,.4);opacity:0}.popover .item:first-child{border-top:0}.popover .item:last-child{border-bottom:0}.popover.popover-bottom{margin-top:-9pt}.popover,.popover .bar-header{border-radius:2px}.popover .scroll-content{z-index:1;margin:2px 0}.popover .bar-header{border-bottom-right-radius:0;border-bottom-left-radius:0}.popover .has-header{border-top-right-radius:0;border-top-left-radius:0}.popover-arrow{display:none}.platform-ios .popover{box-shadow:0 0 40px rgba(0,0,0,.08);border-radius:10px}.platform-ios .popover .bar-header{-webkit-border-top-right-radius:10px;border-top-right-radius:10px;-webkit-border-top-left-radius:10px;border-top-left-radius:10px}.platform-ios .popover .scroll-content{margin:8px 0;border-radius:10px}.platform-ios .popover .scroll-content.has-header{margin-top:0}.platform-ios .popover-arrow{position:absolute;display:block;top:-17px;width:30px;height:19px;overflow:hidden}.platform-ios .popover-arrow:after{position:absolute;top:9pt;left:5px;width:20px;height:20px;background-color:#fff;border-radius:3px;content:'';-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}.platform-ios .popover-bottom .popover-arrow{top:auto;bottom:-10px}.platform-ios .popover-bottom .popover-arrow:after{top:-6px}.platform-android .popover{margin-top:-2pc;background-color:#fafafa;box-shadow:0 2px 6px rgba(0,0,0,.35)}.platform-android .popover .item{border-color:#fafafa;background-color:#fafafa;color:#4d4d4d}.platform-android .popover.popover-bottom{margin-top:2pc}.platform-android .popover-backdrop,.platform-android .popover-backdrop.active{background-color:transparent}.popover-open{pointer-events:none}.popover-open .popover,.popover-open .popover-backdrop{pointer-events:auto}.popover-open.loading-active .popover,.popover-open.loading-active .popover-backdrop{pointer-events:none}@media (min-width:680px){.popover{width:360px}}.popup-container{position:absolute;top:0;left:0;bottom:0;right:0;background:transparent;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;-moz-justify-content:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;z-index:12;visibility:hidden}.popup-container.popup-showing{visibility:visible}.popup-container.popup-hidden .popup{-webkit-animation-name:scaleOut;animation-name:scaleOut;-webkit-animation-duration:.1s;animation-duration:.1s;-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out;-webkit-animation-fill-mode:both;animation-fill-mode:both}.popup-container.active .popup{-webkit-animation-name:superScaleIn;animation-name:superScaleIn;-webkit-animation-duration:.2s;animation-duration:.2s;-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out;-webkit-animation-fill-mode:both;animation-fill-mode:both}.popup-container .popup{width:250px;max-width:100%;max-height:90%;border-radius:0;background-color:rgba(255,255,255,.9);display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-direction:normal;-webkit-box-orient:vertical;-webkit-flex-direction:column;-moz-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.popup-container input,.popup-container textarea{width:100%}.popup-head{padding:15px 10px;border-bottom:1px solid #eee;text-align:center}.popup-title{margin:0;padding:0;font-size:15px}.popup-sub-title{margin:5px 0 0 0;padding:0;font-weight:400;font-size:11px}.popup-body{padding:10px;overflow:auto}.popup-buttons{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-direction:normal;-webkit-box-orient:horizontal;-webkit-flex-direction:row;-moz-flex-direction:row;-ms-flex-direction:row;flex-direction:row;padding:10px;min-height:65px}.popup-buttons .button{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;display:block;min-height:45px;border-radius:2px;line-height:20px;margin-right:5px}.popup-buttons .button:last-child{margin-right:0}.popup-open{pointer-events:none}.popup-open.modal-open .modal{pointer-events:none}.popup-open .popup,.popup-open .popup-backdrop{pointer-events:auto}.loading-container{position:absolute;left:0;top:0;right:0;bottom:0;z-index:13;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;-moz-justify-content:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;-webkit-transition:.2s opacity linear;transition:.2s opacity linear;visibility:hidden;opacity:0}.loading-container:not(.visible) .icon,.loading-container:not(.visible) .spinner{display:none}.loading-container.visible{visibility:visible}.loading-container.active{opacity:1}.loading-container .loading{padding:20px;border-radius:5px;background-color:rgba(0,0,0,.7);color:#fff;text-align:center;text-overflow:ellipsis;font-size:15px}.loading-container .loading h1,.loading-container .loading h2,.loading-container .loading h3,.loading-container .loading h4,.loading-container .loading h5,.loading-container .loading h6{color:#fff}.item{border-color:#ddd;background-color:#fff;color:#444;position:relative;z-index:2;display:block;margin:-1px;padding:1pc;border-width:1px;border-style:solid;font-size:1pc}.item h2{margin:0 0 2px 0;font-size:1pc;font-weight:400}.item h3{margin:0 0 4px 0;font-size:14px}.item h4{margin:0 0 4px 0;font-size:9pt}.item h5,.item h6{margin:0 0 3px 0;font-size:10px}.item p{color:#666;font-size:14px;margin-bottom:2px}.item h1:last-child,.item h2:last-child,.item h3:last-child,.item h4:last-child,.item h5:last-child,.item h6:last-child,.item p:last-child{margin-bottom:0}.item .badge{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;position:absolute;top:1pc;right:2pc}.item.item-button-right .badge{right:67px}.item.item-divider .badge{top:8px}.item .badge+.badge{margin-right:5px}.item.item-light{border-color:#ddd;background-color:#fff;color:#444}.item.item-stable{border-color:#b2b2b2;background-color:#f8f8f8;color:#444}.item.item-positive{border-color:#0c63ee;background-color:#387ef5;color:#fff}.item.item-calm{border-color:#0a9ec7;background-color:#11c1f3;color:#fff}.item.item-assertive{border-color:#e42012;background-color:#ef473a;color:#fff}.item.item-balanced{border-color:#28a54c;background-color:#33cd5f;color:#fff}.item.item-energized{border-color:#e6b400;background-color:#ffc900;color:#fff}.item.item-royal{border-color:#6b46e5;background-color:#886aea;color:#fff}.item.item-dark{border-color:#111;background-color:#444;color:#fff}.item[ng-click]:hover{cursor:pointer}.item-borderless,.list-borderless .item{border-width:0}.item .item-content.activated,.item .item-content.active,.item-complex.activated .item-content,.item-complex.active .item-content,.item.activated,.item.active{border-color:#ccc;background-color:#D9D9D9}.item .item-content.activated.item-light,.item .item-content.active.item-light,.item-complex.activated .item-content.item-light,.item-complex.active .item-content.item-light,.item.activated.item-light,.item.active.item-light{border-color:#ccc;background-color:#fafafa}.item .item-content.activated.item-stable,.item .item-content.active.item-stable,.item-complex.activated .item-content.item-stable,.item-complex.active .item-content.item-stable,.item.activated.item-stable,.item.active.item-stable{border-color:#a2a2a2;background-color:#e5e5e5}.item .item-content.activated.item-positive,.item .item-content.active.item-positive,.item-complex.activated .item-content.item-positive,.item-complex.active .item-content.item-positive,.item.activated.item-positive,.item.active.item-positive{border-color:#0c63ee;background-color:#0c63ee}.item .item-content.activated.item-calm,.item .item-content.active.item-calm,.item-complex.activated .item-content.item-calm,.item-complex.active .item-content.item-calm,.item.activated.item-calm,.item.active.item-calm{border-color:#0a9ec7;background-color:#0a9ec7}.item .item-content.activated.item-assertive,.item .item-content.active.item-assertive,.item-complex.activated .item-content.item-assertive,.item-complex.active .item-content.item-assertive,.item.activated.item-assertive,.item.active.item-assertive{border-color:#e42012;background-color:#e42012}.item .item-content.activated.item-balanced,.item .item-content.active.item-balanced,.item-complex.activated .item-content.item-balanced,.item-complex.active .item-content.item-balanced,.item.activated.item-balanced,.item.active.item-balanced{border-color:#28a54c;background-color:#28a54c}.item .item-content.activated.item-energized,.item .item-content.active.item-energized,.item-complex.activated .item-content.item-energized,.item-complex.active .item-content.item-energized,.item.activated.item-energized,.item.active.item-energized{border-color:#e6b400;background-color:#e6b400}.item .item-content.activated.item-royal,.item .item-content.active.item-royal,.item-complex.activated .item-content.item-royal,.item-complex.active .item-content.item-royal,.item.activated.item-royal,.item.active.item-royal{border-color:#6b46e5;background-color:#6b46e5}.item .item-content.activated.item-dark,.item .item-content.active.item-dark,.item-complex.activated .item-content.item-dark,.item-complex.active .item-content.item-dark,.item.activated.item-dark,.item.active.item-dark{border-color:#000;background-color:#262626}.item,.item h1,.item h2,.item h3,.item h4,.item h5,.item h6,.item p,.item-content,.item-content h1,.item-content h2,.item-content h3,.item-content h4,.item-content h5,.item-content h6,.item-content p{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}a.item{color:inherit;text-decoration:none}a.item:focus,a.item:hover{text-decoration:none}.item-complex,a.item.item-complex,button.item.item-complex{padding:0}.item-complex .item-content,.item-radio .item-content{position:relative;z-index:2;padding:1pc 49px 1pc 1pc;border:none;background-color:#fff}a.item-content{display:block;color:inherit;text-decoration:none}.item-body h1,.item-body h2,.item-body h3,.item-body h4,.item-body h5,.item-body h6,.item-body p,.item-complex.item-text-wrap .item-content,.item-text-wrap,.item-text-wrap .item,.item-text-wrap .item-content,.item-text-wrap h1,.item-text-wrap h2,.item-text-wrap h3,.item-text-wrap h4,.item-text-wrap h5,.item-text-wrap h6,.item-text-wrap p{overflow:visible;white-space:normal}.item-complex.item-text-wrap,.item-complex.item-text-wrap h1,.item-complex.item-text-wrap h2,.item-complex.item-text-wrap h3,.item-complex.item-text-wrap h4,.item-complex.item-text-wrap h5,.item-complex.item-text-wrap h6,.item-complex.item-text-wrap p{overflow:visible;white-space:normal}.item-complex.item-light>.item-content{border-color:#ddd;background-color:#fff;color:#444}.item-complex.item-light>.item-content.active,.item-complex.item-light>.item-content:active{border-color:#ccc;background-color:#fafafa}.item-complex.item-stable>.item-content{border-color:#b2b2b2;background-color:#f8f8f8;color:#444}.item-complex.item-stable>.item-content.active,.item-complex.item-stable>.item-content:active{border-color:#a2a2a2;background-color:#e5e5e5}.item-complex.item-positive>.item-content{border-color:#0c63ee;background-color:#387ef5;color:#fff}.item-complex.item-positive>.item-content.active,.item-complex.item-positive>.item-content:active{border-color:#0c63ee;background-color:#0c63ee}.item-complex.item-calm>.item-content{border-color:#0a9ec7;background-color:#11c1f3;color:#fff}.item-complex.item-calm>.item-content.active,.item-complex.item-calm>.item-content:active{border-color:#0a9ec7;background-color:#0a9ec7}.item-complex.item-assertive>.item-content{border-color:#e42012;background-color:#ef473a;color:#fff}.item-complex.item-assertive>.item-content.active,.item-complex.item-assertive>.item-content:active{border-color:#e42012;background-color:#e42012}.item-complex.item-balanced>.item-content{border-color:#28a54c;background-color:#33cd5f;color:#fff}.item-complex.item-balanced>.item-content.active,.item-complex.item-balanced>.item-content:active{border-color:#28a54c;background-color:#28a54c}.item-complex.item-energized>.item-content{border-color:#e6b400;background-color:#ffc900;color:#fff}.item-complex.item-energized>.item-content.active,.item-complex.item-energized>.item-content:active{border-color:#e6b400;background-color:#e6b400}.item-complex.item-royal>.item-content{border-color:#6b46e5;background-color:#886aea;color:#fff}.item-complex.item-royal>.item-content.active,.item-complex.item-royal>.item-content:active{border-color:#6b46e5;background-color:#6b46e5}.item-complex.item-dark>.item-content{border-color:#111;background-color:#444;color:#fff}.item-complex.item-dark>.item-content.active,.item-complex.item-dark>.item-content:active{border-color:#000;background-color:#262626}.item-icon-left .icon,.item-icon-right .icon{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;position:absolute;top:0;height:100%;font-size:2pc}.item-icon-left .icon:before,.item-icon-right .icon:before{display:block;width:2pc;text-align:center}.item .fill-icon{min-width:30px;min-height:30px;font-size:28px}.item-icon-left{padding-left:54px}.item-icon-left .icon{left:11px}.item-complex.item-icon-left{padding-left:0}.item-complex.item-icon-left .item-content{padding-left:54px}.item-icon-right{padding-right:54px}.item-icon-right .icon{right:11px}.item-complex.item-icon-right{padding-right:0}.item-complex.item-icon-right .item-content{padding-right:54px}.item-icon-left.item-icon-right .icon:first-child{right:auto}.item-icon-left .item-delete .icon,.item-icon-left.item-icon-right .icon:last-child{left:auto}.item-icon-left .icon-accessory,.item-icon-right .icon-accessory{color:#ccc;font-size:1pc}.item-icon-left .icon-accessory{left:3px}.item-icon-right .icon-accessory{right:3px}.item-button-left{padding-left:72px}.item-button-left .item-content>.button,.item-button-left>.button{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;position:absolute;top:8px;left:11px;min-width:34px;min-height:34px;font-size:18px;line-height:2pc}.item-button-left .item-content>.button .icon:before,.item-button-left>.button .icon:before{position:relative;left:auto;width:auto;line-height:31px}.item-button-left .item-content>.button>.button,.item-button-left>.button>.button{margin:0 2px;min-height:34px;font-size:18px;line-height:2pc}.item-button-right,a.item.item-button-right,button.item.item-button-right{padding-right:5pc}.item-button-right .item-content>.button,.item-button-right .item-content>.buttons,.item-button-right>.button,.item-button-right>.buttons{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;position:absolute;top:8px;right:1pc;min-width:34px;min-height:34px;font-size:18px;line-height:2pc}.item-button-right .item-content>.button .icon:before,.item-button-right .item-content>.buttons .icon:before,.item-button-right>.button .icon:before,.item-button-right>.buttons .icon:before{position:relative;left:auto;width:auto;line-height:31px}.item-button-right .item-content>.button>.button,.item-button-right .item-content>.buttons>.button,.item-button-right>.button>.button,.item-button-right>.buttons>.button{margin:0 2px;min-width:34px;min-height:34px;font-size:18px;line-height:2pc}.item-avatar,.item-avatar .item-content,.item-avatar-left,.item-avatar-left .item-content{padding-left:72px;min-height:72px}.item-avatar .item-content .item-image,.item-avatar .item-content>img:first-child,.item-avatar .item-image,.item-avatar-left .item-content .item-image,.item-avatar-left .item-content>img:first-child,.item-avatar-left .item-image,.item-avatar-left>img:first-child,.item-avatar>img:first-child{position:absolute;top:1pc;left:1pc;max-width:40px;max-height:40px;width:100%;height:100%;border-radius:50%}.item-avatar-right,.item-avatar-right .item-content{padding-right:72px;min-height:72px}.item-avatar-right .item-content .item-image,.item-avatar-right .item-content>img:first-child,.item-avatar-right .item-image,.item-avatar-right>img:first-child{position:absolute;top:1pc;right:1pc;max-width:40px;max-height:40px;width:100%;height:100%;border-radius:50%}.item-thumbnail-left,.item-thumbnail-left .item-content{padding-top:8px;padding-left:106px;min-height:75pt}.item-thumbnail-left .item-content .item-image,.item-thumbnail-left .item-content>img:first-child,.item-thumbnail-left .item-image,.item-thumbnail-left>img:first-child{position:absolute;top:10px;left:10px;max-width:5pc;max-height:5pc;width:100%;height:100%}.item-avatar-left.item-complex,.item-avatar.item-complex,.item-thumbnail-left.item-complex{padding-top:0;padding-left:0}.item-thumbnail-right,.item-thumbnail-right .item-content{padding-top:8px;padding-right:106px;min-height:75pt}.item-thumbnail-right .item-content .item-image,.item-thumbnail-right .item-content>img:first-child,.item-thumbnail-right .item-image,.item-thumbnail-right>img:first-child{position:absolute;top:10px;right:10px;max-width:5pc;max-height:5pc;width:100%;height:100%}.item-avatar-right.item-complex,.item-thumbnail-right.item-complex{padding-top:0;padding-right:0}.item-image{padding:0;text-align:center}.item-image .list-img,.item-image img:first-child{width:100%;vertical-align:middle}.item-body{overflow:auto;padding:1pc;text-overflow:inherit;white-space:normal}.item-body h1,.item-body h2,.item-body h3,.item-body h4,.item-body h5,.item-body h6,.item-body p{margin-top:1pc;margin-bottom:1pc}.item-divider{padding-top:8px;padding-bottom:8px;min-height:30px;background-color:#f5f5f5;color:#222;font-weight:500}.item-divider-ios,.platform-ios .item-divider-platform{padding-top:26px;text-transform:uppercase;font-weight:300;font-size:13px;background-color:#efeff4;color:#555}.item-divider-android,.platform-android .item-divider-platform{font-weight:300;font-size:13px}.item-note{float:right;color:#aaa;font-size:14px}.item-left-editable .item-content,.item-right-editable .item-content{-webkit-transition-duration:250ms;transition-duration:250ms;-webkit-transition-timing-function:ease-in-out;transition-timing-function:ease-in-out;-webkit-transition-property:-webkit-transform;-moz-transition-property:-moz-transform;transition-property:transform}.item-left-editing.item-left-editable .item-content,.list-left-editing .item-left-editable .item-content{-webkit-transform:translate3d(50px,0,0);transform:translate3d(50px,0,0)}.item-remove-animate.ng-leave{-webkit-transition-duration:.3s;transition-duration:.3s}.item-remove-animate.ng-leave .item-content,.item-remove-animate.ng-leave:last-of-type{-webkit-transition-duration:.3s;transition-duration:.3s;-webkit-transition-timing-function:ease-in;transition-timing-function:ease-in;-webkit-transition-property:all;transition-property:all}.item-remove-animate.ng-leave.ng-leave-active .item-content{opacity:0;-webkit-transform:translate3d(-100%,0,0)!important;transform:translate3d(-100%,0,0)!important}.item-remove-animate.ng-leave.ng-leave-active:last-of-type{opacity:0}.item-remove-animate.ng-leave.ng-leave-active~ion-item:not(.ng-leave){-webkit-transform:translate3d(0,-webkit-calc(-100% + 1px),0);transform:translate3d(0,calc(-100% + 1px),0);-webkit-transition-duration:.3s;transition-duration:.3s;-webkit-transition-timing-function:cubic-bezier(.25,.81,.24,1);transition-timing-function:cubic-bezier(.25,.81,.24,1);-webkit-transition-property:all;transition-property:all}.item-left-edit{-webkit-transition:all ease-in-out 125ms;transition:all ease-in-out 125ms;position:absolute;top:0;left:0;z-index:0;width:50px;height:100%;line-height:100%;display:none;opacity:0;-webkit-transform:translate3d(-21px,0,0);transform:translate3d(-21px,0,0)}.item-left-edit .button{height:100%}.item-left-edit .button.icon{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;position:absolute;top:0;height:100%}.item-left-edit.visible{display:block}.item-left-edit.visible.active{opacity:1;-webkit-transform:translate3d(8px,0,0);transform:translate3d(8px,0,0)}.list-left-editing .item-left-edit{-webkit-transition-delay:125ms;transition-delay:125ms}.item-delete .button.icon{color:#ef473a;font-size:24px}.item-delete .button.icon:hover{opacity:.7}.item-right-edit{-webkit-transition:all ease-in-out 250ms;transition:all ease-in-out 250ms;position:absolute;top:0;right:0;z-index:3;width:75px;height:100%;background:inherit;padding-left:20px;display:block;opacity:0;-webkit-transform:translate3d(75px,0,0);transform:translate3d(75px,0,0)}.item-right-edit .button{min-width:50px;height:100%}.item-right-edit .button.icon{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;position:absolute;top:0;height:100%;font-size:2pc}.item-right-edit.visible{display:block}.item-right-edit.visible.active{opacity:1;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}.item-reorder .button.icon{color:#444;font-size:2pc}.item-reordering{position:absolute;left:0;top:0;z-index:9;width:100%;box-shadow:0 0 10px 0 #aaa}.item-reordering .item-reorder{z-index:9}.item-placeholder{opacity:.7}.item-options{position:absolute;top:0;right:0;z-index:1;height:100%}.item-options .button{height:100%;border:none;border-radius:0;display:-webkit-inline-box;display:-webkit-inline-flex;display:-moz-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center}.item-options .button:before{margin:0 auto}.list{position:relative;padding-top:1px;padding-bottom:1px;padding-left:0;margin-bottom:20px}.list:last-child{margin-bottom:0}.list:last-child.card{margin-bottom:40px}.list-header{margin-top:20px;padding:5px 15px;background-color:transparent;color:#222;font-weight:700}.card.list .list-item{padding-right:1px;padding-left:1px}.card,.list-inset{overflow:hidden;margin:20px 10px;border-radius:2px;background-color:#fff}.card{padding-top:1px;padding-bottom:1px;box-shadow:0 1px 3px rgba(0,0,0,.3)}.card .item{border-left:0;border-right:0}.card .item:first-child{border-top:0}.card .item:last-child{border-bottom:0}.padding .card,.padding .list-inset{margin-left:0;margin-right:0}.card .item:first-child,.list-inset .item:first-child,.padding>.list .item:first-child{border-top-left-radius:2px;border-top-right-radius:2px}.card .item:first-child .item-content,.list-inset .item:first-child .item-content,.padding>.list .item:first-child .item-content{border-top-left-radius:2px;border-top-right-radius:2px}.card .item:last-child,.list-inset .item:last-child,.padding>.list .item:last-child{border-bottom-right-radius:2px;border-bottom-left-radius:2px}.card .item:last-child .item-content,.list-inset .item:last-child .item-content,.padding>.list .item:last-child .item-content{border-bottom-right-radius:2px;border-bottom-left-radius:2px}.card .item:last-child,.list-inset .item:last-child{margin-bottom:-1px}.card .item,.list-inset .item,.padding-horizontal>.list .item,.padding>.list .item{margin-right:0;margin-left:0}.card .item.item-input input,.list-inset .item.item-input input,.padding-horizontal>.list .item.item-input input,.padding>.list .item.item-input input{padding-right:44px}.padding-left>.list .item{margin-left:0}.padding-right>.list .item{margin-right:0}.badge{background-color:transparent;color:#AAA;z-index:1;display:inline-block;padding:3px 8px;min-width:10px;border-radius:10px;vertical-align:baseline;text-align:center;white-space:nowrap;font-weight:700;font-size:14px;line-height:1pc}.badge:empty{display:none}.badge.badge-light,.tabs .tab-item .badge.badge-light{background-color:#fff;color:#444}.badge.badge-stable,.tabs .tab-item .badge.badge-stable{background-color:#f8f8f8;color:#444}.badge.badge-positive,.tabs .tab-item .badge.badge-positive{background-color:#387ef5;color:#fff}.badge.badge-calm,.tabs .tab-item .badge.badge-calm{background-color:#11c1f3;color:#fff}.badge.badge-assertive,.tabs .tab-item .badge.badge-assertive{background-color:#ef473a;color:#fff}.badge.badge-balanced,.tabs .tab-item .badge.badge-balanced{background-color:#33cd5f;color:#fff}.badge.badge-energized,.tabs .tab-item .badge.badge-energized{background-color:#ffc900;color:#fff}.badge.badge-royal,.tabs .tab-item .badge.badge-royal{background-color:#886aea;color:#fff}.badge.badge-dark,.tabs .tab-item .badge.badge-dark{background-color:#444;color:#fff}.button .badge{position:relative;top:-1px}.slider{position:relative;visibility:hidden;overflow:hidden}.slider-slides{position:relative;height:100%}.slider-slide{position:relative;display:block;float:left;width:100%;height:100%;vertical-align:top}.slider-slide-image>img{width:100%}.slider-pager{position:absolute;bottom:20px;z-index:1;width:100%;height:15px;text-align:center}.slider-pager .slider-pager-page{display:inline-block;margin:0 3px;width:15px;color:#000;text-decoration:none;opacity:.3}.slider-pager .slider-pager-page.active{-webkit-transition:opacity .4s ease-in;transition:opacity .4s ease-in;opacity:1}.scroll-refresher{position:absolute;top:-60px;right:0;left:0;overflow:hidden;margin:auto;height:60px}.scroll-refresher .ionic-refresher-content{position:absolute;bottom:15px;left:0;width:100%;color:#666;text-align:center;font-size:30px}.scroll-refresher .ionic-refresher-content .text-pulling,.scroll-refresher .ionic-refresher-content .text-refreshing{font-size:1pc;line-height:1pc}.scroll-refresher .ionic-refresher-content.ionic-refresher-with-text{bottom:10px}.scroll-refresher .icon-pulling,.scroll-refresher .icon-refreshing{width:100%;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.scroll-refresher .icon-pulling{-webkit-animation-name:refresh-spin-back;animation-name:refresh-spin-back;-webkit-animation-duration:.2s;animation-duration:.2s;-webkit-animation-timing-function:linear;animation-timing-function:linear;-webkit-animation-fill-mode:none;animation-fill-mode:none;-webkit-transform:translate3d(0,0,0) rotate(0);transform:translate3d(0,0,0) rotate(0)}.scroll-refresher .icon-refreshing,.scroll-refresher .text-refreshing{display:none}.scroll-refresher .icon-refreshing{-webkit-animation-duration:1.5s;animation-duration:1.5s}.scroll-refresher.active .icon-pulling:not(.pulling-rotation-disabled){-webkit-animation-name:refresh-spin;animation-name:refresh-spin;-webkit-transform:translate3d(0,0,0) rotate(-180deg);transform:translate3d(0,0,0) rotate(-180deg)}.scroll-refresher.active.refreshing{-webkit-transition:-webkit-transform .2s;transition:-webkit-transform .2s;-webkit-transition:transform .2s;transition:transform .2s;-webkit-transform:scale(1,1);transform:scale(1,1)}.scroll-refresher.active.refreshing .icon-pulling,.scroll-refresher.active.refreshing .text-pulling{display:none}.scroll-refresher.active.refreshing .icon-refreshing,.scroll-refresher.active.refreshing .text-refreshing{display:block}.scroll-refresher.active.refreshing.refreshing-tail{-webkit-transform:scale(0,0);transform:scale(0,0)}.overflow-scroll>.scroll{-webkit-overflow-scrolling:touch;width:100%}.overflow-scroll>.scroll.overscroll{position:fixed}@-webkit-keyframes refresh-spin{0%{-webkit-transform:translate3d(0,0,0) rotate(0)}100%{-webkit-transform:translate3d(0,0,0) rotate(180deg)}}@keyframes refresh-spin{0%{transform:translate3d(0,0,0) rotate(0)}100%{transform:translate3d(0,0,0) rotate(180deg)}}@-webkit-keyframes refresh-spin-back{0%{-webkit-transform:translate3d(0,0,0) rotate(180deg)}100%{-webkit-transform:translate3d(0,0,0) rotate(0)}}@keyframes refresh-spin-back{0%{transform:translate3d(0,0,0) rotate(180deg)}100%{transform:translate3d(0,0,0) rotate(0)}}.spinner{stroke:#444;fill:#444}.spinner svg{width:28px;height:28px}.spinner.spinner-light{stroke:#fff;fill:#fff}.spinner.spinner-stable{stroke:#f8f8f8;fill:#f8f8f8}.spinner.spinner-positive{stroke:#387ef5;fill:#387ef5}.spinner.spinner-calm{stroke:#11c1f3;fill:#11c1f3}.spinner.spinner-balanced{stroke:#33cd5f;fill:#33cd5f}.spinner.spinner-assertive{stroke:#ef473a;fill:#ef473a}.spinner.spinner-energized{stroke:#ffc900;fill:#ffc900}.spinner.spinner-royal{stroke:#886aea;fill:#886aea}.spinner.spinner-dark{stroke:#444;fill:#444}.spinner-android{stroke:#4b8bf4}.spinner-ios,.spinner-ios-small{stroke:#69717d}.spinner-spiral .stop1{stop-color:#fff;stop-opacity:0}.spinner-spiral.spinner-light .stop1{stop-color:#444}.spinner-spiral.spinner-light .stop2{stop-color:#fff}.spinner-spiral.spinner-stable .stop2{stop-color:#f8f8f8}.spinner-spiral.spinner-positive .stop2{stop-color:#387ef5}.spinner-spiral.spinner-calm .stop2{stop-color:#11c1f3}.spinner-spiral.spinner-balanced .stop2{stop-color:#33cd5f}.spinner-spiral.spinner-assertive .stop2{stop-color:#ef473a}.spinner-spiral.spinner-energized .stop2{stop-color:#ffc900}.spinner-spiral.spinner-royal .stop2{stop-color:#886aea}.spinner-spiral.spinner-dark .stop2{stop-color:#444}form{margin:0 0 1.42857}legend{display:block;margin-bottom:1.42857;padding:0;width:100%;border:1px solid #ddd;color:#444;font-size:21px;line-height:2.85714}legend small{color:#f8f8f8;font-size:1.07143}button,input,label,select,textarea{font-weight:400;font-size:14px;line-height:1.42857}button,input,select,textarea{font-family:\"Helvetica Neue\",Roboto,\"Segoe UI\",sans-serif}.item-input{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;position:relative;overflow:hidden;padding:6px 0 5px 1pc}.item-input input{-webkit-border-radius:0;border-radius:0;-webkit-box-flex:1;-webkit-flex:1 220px;-moz-box-flex:1;-moz-flex:1 220px;-ms-flex:1 220px;flex:1 220px;-webkit-appearance:none;-moz-appearance:none;appearance:none;margin:0;padding-right:24px;background-color:transparent}.item-input .button .icon{-webkit-box-flex:0;-webkit-flex:0 0 24px;-moz-box-flex:0;-moz-flex:0 0 24px;-ms-flex:0 0 24px;flex:0 0 24px;position:static;display:inline-block;height:auto;text-align:center;font-size:1pc}.item-input .button-bar{-webkit-border-radius:0;border-radius:0;-webkit-box-flex:1;-webkit-flex:1 0 220px;-moz-box-flex:1;-moz-flex:1 0 220px;-ms-flex:1 0 220px;flex:1 0 220px;-webkit-appearance:none;-moz-appearance:none;appearance:none}.item-input .icon{min-width:14px}.platform-windowsphone .item-input input{flex-shrink:1}.item-input-inset{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;position:relative;overflow:hidden;padding:10.67px}.item-input-wrapper{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-webkit-flex:1 0;-moz-box-flex:1;-moz-flex:1 0;-ms-flex:1 0;flex:1 0;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;-webkit-border-radius:4px;border-radius:4px;padding-right:8px;padding-left:8px;background:#eee}.item-input-inset .item-input-wrapper input{padding-left:4px;height:29px;background:0 0;line-height:18px}.item-input-wrapper~.button{margin-left:10.67px}.input-label{display:table;padding:7px 10px 7px 0;max-width:200px;width:35%;color:#444;font-size:1pc}.placeholder-icon{color:#aaa}.placeholder-icon:first-child{padding-right:6px}.placeholder-icon:last-child{padding-left:6px}.item-stacked-label{display:block;background-color:transparent;box-shadow:none}.item-stacked-label .icon,.item-stacked-label .input-label{display:inline-block;padding:4px 0 0 0;vertical-align:middle}.item-stacked-label input,.item-stacked-label textarea{-webkit-border-radius:2px;border-radius:2px;padding:4px 8px 3px 0;border:none;background-color:#fff}.item-stacked-label input{overflow:hidden;height:46px}.item-floating-label{display:block;background-color:transparent;box-shadow:none}.item-floating-label .input-label{position:relative;padding:5px 0 0 0;opacity:0;top:10px;-webkit-transition:opacity .15s ease-in,top .2s linear;transition:opacity .15s ease-in,top .2s linear}.item-floating-label .input-label.has-input{opacity:1;top:0;-webkit-transition:opacity .15s ease-in,top .2s linear;transition:opacity .15s ease-in,top .2s linear}input[type=search],input[type=text],input[type=password],input[type=datetime],input[type=datetime-local],input[type=date],input[type=month],input[type=time],input[type=week],input[type=number],input[type=email],input[type=url],input[type=tel],input[type=color],textarea{display:block;padding-top:2px;padding-left:0;height:34px;color:#111;vertical-align:middle;font-size:14px;line-height:1pc}.platform-android input[type=datetime-local],.platform-android input[type=date],.platform-android input[type=month],.platform-android input[type=time],.platform-android input[type=week],.platform-ios input[type=datetime-local],.platform-ios input[type=date],.platform-ios input[type=month],.platform-ios input[type=time],.platform-ios input[type=week]{padding-top:8px}.item-input input,.item-input textarea{width:100%}textarea{padding-left:0}textarea::-moz-placeholder{color:#aaa}textarea:-ms-input-placeholder{color:#aaa}textarea::-webkit-input-placeholder{color:#aaa;text-indent:-3px}textarea{height:auto}input[type=search],input[type=text],input[type=password],input[type=datetime],input[type=datetime-local],input[type=date],input[type=month],input[type=time],input[type=week],input[type=number],input[type=email],input[type=url],input[type=tel],input[type=color],textarea{border:0}input[type=radio],input[type=checkbox]{margin:0;line-height:normal}.item-input input[type=button],.item-input input[type=reset],.item-input input[type=submit],.item-input input[type=radio],.item-input input[type=checkbox],.item-input input[type=file],.item-input input[type=image]{width:auto}input[type=file]{line-height:34px}.cloned-text-input+input,.cloned-text-input+textarea,.previous-input-focus{position:absolute!important;left:-9999px;width:200px}input::-moz-placeholder,textarea::-moz-placeholder{color:#aaa}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:#aaa}input::-webkit-input-placeholder,textarea::-webkit-input-placeholder{color:#aaa;text-indent:0}input[disabled],input[readonly]:not(.cloned-text-input),select[disabled],select[readonly],textarea[disabled],textarea[readonly]:not(.cloned-text-input){background-color:#f8f8f8;cursor:not-allowed}input[type=radio][disabled],input[type=radio][readonly],input[type=checkbox][disabled],input[type=checkbox][readonly]{background-color:transparent}.checkbox{position:relative;display:inline-block;padding:7px 7px;cursor:pointer}.checkbox .checkbox-icon:before,.checkbox input:before{border-color:#ddd}.checkbox input:checked+.checkbox-icon:before,.checkbox input:checked:before{background:#387ef5;border-color:#387ef5}.checkbox-light .checkbox-icon:before,.checkbox-light input:before{border-color:#ddd}.checkbox-light input:checked+.checkbox-icon:before,.checkbox-light input:checked:before{background:#ddd;border-color:#ddd}.checkbox-stable .checkbox-icon:before,.checkbox-stable input:before{border-color:#b2b2b2}.checkbox-stable input:checked+.checkbox-icon:before,.checkbox-stable input:checked:before{background:#b2b2b2;border-color:#b2b2b2}.checkbox-positive .checkbox-icon:before,.checkbox-positive input:before{border-color:#387ef5}.checkbox-positive input:checked+.checkbox-icon:before,.checkbox-positive input:checked:before{background:#387ef5;border-color:#387ef5}.checkbox-calm .checkbox-icon:before,.checkbox-calm input:before{border-color:#11c1f3}.checkbox-calm input:checked+.checkbox-icon:before,.checkbox-calm input:checked:before{background:#11c1f3;border-color:#11c1f3}.checkbox-assertive .checkbox-icon:before,.checkbox-assertive input:before{border-color:#ef473a}.checkbox-assertive input:checked+.checkbox-icon:before,.checkbox-assertive input:checked:before{background:#ef473a;border-color:#ef473a}.checkbox-balanced .checkbox-icon:before,.checkbox-balanced input:before{border-color:#33cd5f}.checkbox-balanced input:checked+.checkbox-icon:before,.checkbox-balanced input:checked:before{background:#33cd5f;border-color:#33cd5f}.checkbox-energized .checkbox-icon:before,.checkbox-energized input:before{border-color:#ffc900}.checkbox-energized input:checked+.checkbox-icon:before,.checkbox-energized input:checked:before{background:#ffc900;border-color:#ffc900}.checkbox-royal .checkbox-icon:before,.checkbox-royal input:before{border-color:#886aea}.checkbox-royal input:checked+.checkbox-icon:before,.checkbox-royal input:checked:before{background:#886aea;border-color:#886aea}.checkbox-dark .checkbox-icon:before,.checkbox-dark input:before{border-color:#444}.checkbox-dark input:checked+.checkbox-icon:before,.checkbox-dark input:checked:before{background:#444;border-color:#444}.checkbox input:disabled+.checkbox-icon:before,.checkbox input:disabled:before{border-color:#ddd}.checkbox input:disabled:checked+.checkbox-icon:before,.checkbox input:disabled:checked:before{background:#ddd}.checkbox.checkbox-input-hidden input{display:none!important}.checkbox input,.checkbox-icon{position:relative;width:28px;height:28px;display:block;border:0;background:0 0;cursor:pointer;-webkit-appearance:none}.checkbox input:before,.checkbox-icon:before{display:table;width:100%;height:100%;border-width:1px;border-style:solid;border-radius:28px;background:#fff;content:' ';-webkit-transition:background-color 20ms ease-in-out;transition:background-color 20ms ease-in-out}.checkbox input:checked:before,input:checked+.checkbox-icon:before{border-width:2px}.checkbox input:after,.checkbox-icon:after{-webkit-transition:opacity 50ms ease-in-out;transition:opacity 50ms ease-in-out;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);position:absolute;top:33%;left:25%;display:table;width:14px;height:6px;border:1px solid #fff;border-top:0;border-right:0;content:' ';opacity:0}.checkbox-square .checkbox-icon:before,.checkbox-square input:before,.platform-android .checkbox-platform .checkbox-icon:before,.platform-android .checkbox-platform input:before{border-radius:2px;width:72%;height:72%;margin-top:14%;margin-left:14%;border-width:2px}.checkbox-square .checkbox-icon:after,.checkbox-square input:after,.platform-android .checkbox-platform .checkbox-icon:after,.platform-android .checkbox-platform input:after{border-width:2px;top:19%;left:25%;width:13px;height:7px}.grade-c .checkbox input:after,.grade-c .checkbox-icon:after{-webkit-transform:rotate(0);transform:rotate(0);top:3px;left:4px;border:none;color:#fff;content:'\\2713';font-weight:700;font-size:20px}.checkbox input:checked:after,input:checked+.checkbox-icon:after{opacity:1}.item-checkbox{padding-left:60px}.item-checkbox.active{box-shadow:none}.item-checkbox .checkbox{position:absolute;top:50%;right:8px;left:8px;z-index:3;margin-top:-21px}.item-checkbox.item-checkbox-right{padding-right:60px;padding-left:1pc}.item-checkbox-right .checkbox input,.item-checkbox-right .checkbox-icon{float:right}.item-toggle{pointer-events:none}.toggle{position:relative;display:inline-block;pointer-events:auto;margin:-5px;padding:5px}.toggle input:checked+.track{border-color:#4cd964;background-color:#4cd964}.toggle.dragging .handle{background-color:#f2f2f2!important}.toggle.toggle-light input:checked+.track{border-color:#ddd;background-color:#ddd}.toggle.toggle-stable input:checked+.track{border-color:#b2b2b2;background-color:#b2b2b2}.toggle.toggle-positive input:checked+.track{border-color:#387ef5;background-color:#387ef5}.toggle.toggle-calm input:checked+.track{border-color:#11c1f3;background-color:#11c1f3}.toggle.toggle-assertive input:checked+.track{border-color:#ef473a;background-color:#ef473a}.toggle.toggle-balanced input:checked+.track{border-color:#33cd5f;background-color:#33cd5f}.toggle.toggle-energized input:checked+.track{border-color:#ffc900;background-color:#ffc900}.toggle.toggle-royal input:checked+.track{border-color:#886aea;background-color:#886aea}.toggle.toggle-dark input:checked+.track{border-color:#444;background-color:#444}.toggle input{display:none}.toggle .track{-webkit-transition-timing-function:ease-in-out;transition-timing-function:ease-in-out;-webkit-transition-duration:.3s;transition-duration:.3s;-webkit-transition-property:background-color,border;transition-property:background-color,border;display:inline-block;box-sizing:border-box;width:51px;height:31px;border:solid 2px #e6e6e6;border-radius:20px;background-color:#fff;content:' ';cursor:pointer;pointer-events:none}.platform-android4_2 .toggle .track{-webkit-background-clip:padding-box}.toggle .handle{-webkit-transition:.3s cubic-bezier(0,1.1,1,1.1);transition:.3s cubic-bezier(0,1.1,1,1.1);-webkit-transition-property:background-color,transform;transition-property:background-color,transform;position:absolute;display:block;width:27px;height:27px;border-radius:27px;background-color:#fff;top:7px;left:7px;box-shadow:0 2px 7px rgba(0,0,0,.35),0 1px 1px rgba(0,0,0,.15)}.toggle .handle:before{position:absolute;top:-4px;left:-21.5px;padding:18.5px 34px;content:\" \"}.toggle input:checked+.track .handle{-webkit-transform:translate3d(20px,0,0);transform:translate3d(20px,0,0);background-color:#fff}.item-toggle.active{box-shadow:none}.item-toggle,.item-toggle.item-complex .item-content{padding-right:99px}.item-toggle.item-complex{padding-right:0}.item-toggle .toggle{position:absolute;top:10px;right:1pc;z-index:3}.toggle input:disabled+.track{opacity:.6}.toggle-small .track{border:0;width:34px;height:15px;background:#9e9e9e}.toggle-small input:checked+.track{background:rgba(0,150,137,.5)}.toggle-small .handle{top:2px;left:4px;width:21px;height:21px;box-shadow:0 2px 5px rgba(0,0,0,.25)}.toggle-small input:checked+.track .handle{-webkit-transform:translate3d(1pc,0,0);transform:translate3d(1pc,0,0);background:#009689}.toggle-small.item-toggle .toggle{top:19px}.toggle-small .toggle-light input:checked+.track{background-color:rgba(221,221,221,.5)}.toggle-small .toggle-light input:checked+.track .handle{background-color:#ddd}.toggle-small .toggle-stable input:checked+.track{background-color:rgba(178,178,178,.5)}.toggle-small .toggle-stable input:checked+.track .handle{background-color:#b2b2b2}.toggle-small .toggle-positive input:checked+.track{background-color:rgba(56,126,245,.5)}.toggle-small .toggle-positive input:checked+.track .handle{background-color:#387ef5}.toggle-small .toggle-calm input:checked+.track{background-color:rgba(17,193,243,.5)}.toggle-small .toggle-calm input:checked+.track .handle{background-color:#11c1f3}.toggle-small .toggle-assertive input:checked+.track{background-color:rgba(239,71,58,.5)}.toggle-small .toggle-assertive input:checked+.track .handle{background-color:#ef473a}.toggle-small .toggle-balanced input:checked+.track{background-color:rgba(51,205,95,.5)}.toggle-small .toggle-balanced input:checked+.track .handle{background-color:#33cd5f}.toggle-small .toggle-energized input:checked+.track{background-color:rgba(255,201,0,.5)}.toggle-small .toggle-energized input:checked+.track .handle{background-color:#ffc900}.toggle-small .toggle-royal input:checked+.track{background-color:rgba(136,106,234,.5)}.toggle-small .toggle-royal input:checked+.track .handle{background-color:#886aea}.toggle-small .toggle-dark input:checked+.track{background-color:rgba(68,68,68,.5)}.toggle-small .toggle-dark input:checked+.track .handle{background-color:#444}.item-radio{padding:0}.item-radio:hover{cursor:pointer}.item-radio .item-content{padding-right:4pc}.item-radio .radio-icon{position:absolute;top:0;right:0;z-index:3;visibility:hidden;padding:14px;height:100%;font-size:24px}.item-radio input{position:absolute;left:-9999px}.item-radio input:checked~.item-content{background:#f7f7f7}.item-radio input:checked~.radio-icon{visibility:visible}.platform-android.grade-b .item-radio,.platform-android.grade-c .item-radio{-webkit-animation:androidCheckedbugfix infinite 1s}@-webkit-keyframes androidCheckedbugfix{from{padding:0}to{padding:0}}.range input{display:inline-block;overflow:hidden;margin-top:5px;margin-bottom:5px;padding-right:2px;padding-left:1px;width:auto;height:43px;outline:0;background:-webkit-gradient(linear,50% 0,50% 100%,color-stop(0,#ccc),color-stop(100%,#ccc));background:linear-gradient(to right,#ccc 0,#ccc 100%);background-position:center;background-size:99% 2px;background-repeat:no-repeat;-webkit-appearance:none}.range input::-webkit-slider-thumb{position:relative;width:28px;height:28px;border-radius:50%;background-color:#fff;box-shadow:0 0 2px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2);cursor:pointer;-webkit-appearance:none;border:0}.range input::-webkit-slider-thumb:before{position:absolute;top:13px;left:-2001px;width:125pc;height:2px;background:#444;content:' '}.range input::-webkit-slider-thumb:after{position:absolute;top:-15px;left:-15px;padding:30px;content:' '}.range input::-ms-track{background:0 0;border-color:transparent;border-width:11px 0 1pc;color:transparent;margin-top:20px}.range input::-ms-thumb{width:28px;height:28px;border-radius:50%;background-color:#fff;border-color:#fff;box-shadow:0 0 2px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2);margin-left:1px;margin-right:1px;outline:0}.range input::-ms-fill-lower{height:2px;background:#444}.range input::-ms-fill-upper{height:2px;background:#ccc}.range{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center;padding:2px 11px}.range.range-light input::-webkit-slider-thumb:before{background:#ddd}.range.range-light input::-ms-fill-lower{background:#ddd}.range.range-stable input::-webkit-slider-thumb:before{background:#b2b2b2}.range.range-stable input::-ms-fill-lower{background:#b2b2b2}.range.range-positive input::-webkit-slider-thumb:before{background:#387ef5}.range.range-positive input::-ms-fill-lower{background:#387ef5}.range.range-calm input::-webkit-slider-thumb:before{background:#11c1f3}.range.range-calm input::-ms-fill-lower{background:#11c1f3}.range.range-balanced input::-webkit-slider-thumb:before{background:#33cd5f}.range.range-balanced input::-ms-fill-lower{background:#33cd5f}.range.range-assertive input::-webkit-slider-thumb:before{background:#ef473a}.range.range-assertive input::-ms-fill-lower{background:#ef473a}.range.range-energized input::-webkit-slider-thumb:before{background:#ffc900}.range.range-energized input::-ms-fill-lower{background:#ffc900}.range.range-royal input::-webkit-slider-thumb:before{background:#886aea}.range.range-royal input::-ms-fill-lower{background:#886aea}.range.range-dark input::-webkit-slider-thumb:before{background:#444}.range.range-dark input::-ms-fill-lower{background:#444}.range .icon{-webkit-box-flex:0;-webkit-flex:0;-moz-box-flex:0;-moz-flex:0;-ms-flex:0;flex:0;display:block;min-width:24px;text-align:center;font-size:24px}.range input{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;display:block;margin-right:10px;margin-left:10px}.range-label{-webkit-box-flex:0;-webkit-flex:0 0 auto;-moz-box-flex:0;-moz-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;display:block;white-space:nowrap}.range-label:first-child{padding-left:5px}.range input+.range-label{padding-right:5px;padding-left:0}.platform-windowsphone .range input{height:auto}.item-select{position:relative}.item-select select{-webkit-appearance:none;-moz-appearance:none;appearance:none;position:absolute;top:0;bottom:0;right:0;padding:0 3pc 0 1pc;max-width:65%;border:none;background:#fff;color:#333;text-indent:.01px;text-overflow:'';white-space:nowrap;font-size:14px;cursor:pointer;direction:rtl}.item-select select::-ms-expand{display:none}.item-select option{direction:ltr}.item-select:after{position:absolute;top:50%;right:1pc;margin-top:-3px;width:0;height:0;border-top:5px solid;border-right:5px solid transparent;border-left:5px solid transparent;color:#999;content:\"\";pointer-events:none}.item-select.item-light select{background:#fff;color:#444}.item-select.item-stable select{background:#f8f8f8;color:#444}.item-select.item-stable .input-label,.item-select.item-stable:after{color:#656565}.item-select.item-positive select{background:#387ef5;color:#fff}.item-select.item-positive .input-label,.item-select.item-positive:after{color:#fff}.item-select.item-calm select{background:#11c1f3;color:#fff}.item-select.item-calm .input-label,.item-select.item-calm:after{color:#fff}.item-select.item-assertive select{background:#ef473a;color:#fff}.item-select.item-assertive .input-label,.item-select.item-assertive:after{color:#fff}.item-select.item-balanced select{background:#33cd5f;color:#fff}.item-select.item-balanced .input-label,.item-select.item-balanced:after{color:#fff}.item-select.item-energized select{background:#ffc900;color:#fff}.item-select.item-energized .input-label,.item-select.item-energized:after{color:#fff}.item-select.item-royal select{background:#886aea;color:#fff}.item-select.item-royal .input-label,.item-select.item-royal:after{color:#fff}.item-select.item-dark select{background:#444;color:#fff}.item-select.item-dark .input-label,.item-select.item-dark:after{color:#fff}select[multiple],select[size]{height:auto}progress{display:block;margin:15px auto;width:100%}.button{border-color:#b2b2b2;background-color:#f8f8f8;color:#444;position:relative;display:inline-block;margin:0;padding:0 9pt;min-width:52px;min-height:47px;border-width:1px;border-style:solid;border-radius:2px;vertical-align:top;text-align:center;text-overflow:ellipsis;font-size:1pc;line-height:42px;cursor:pointer}.button:hover{color:#444;text-decoration:none}.button.activated,.button.active{border-color:#a2a2a2;background-color:#e5e5e5;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.button:after{position:absolute;top:-6px;right:-6px;bottom:-6px;left:-6px;content:' '}.button .icon{vertical-align:top;pointer-events:none}.button .icon:before,.button.icon-left:before,.button.icon-right:before,.button.icon:before{display:inline-block;padding:0 0 1px 0;vertical-align:inherit;font-size:24px;line-height:41px;pointer-events:none}.button.icon-left:before{float:left;padding-right:.2em;padding-left:0}.button.icon-right:before{float:right;padding-right:0;padding-left:.2em}.button.button-block,.button.button-full{margin-top:10px;margin-bottom:10px}.button.button-light{border-color:#ddd;background-color:#fff;color:#444}.button.button-light:hover{color:#444;text-decoration:none}.button.button-light.activated,.button.button-light.active{border-color:#ccc;background-color:#fafafa;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.button.button-light.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#ddd}.button.button-light.button-icon{border-color:transparent;background:0 0}.button.button-light.button-outline{border-color:#ddd;background:0 0;color:#ddd}.button.button-light.button-outline.activated,.button.button-light.button-outline.active{background-color:#ddd;box-shadow:none;color:#fff}.button.button-stable{border-color:#b2b2b2;background-color:#f8f8f8;color:#444}.button.button-stable:hover{color:#444;text-decoration:none}.button.button-stable.activated,.button.button-stable.active{border-color:#a2a2a2;background-color:#e5e5e5;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.button.button-stable.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#b2b2b2}.button.button-stable.button-icon{border-color:transparent;background:0 0}.button.button-stable.button-outline{border-color:#b2b2b2;background:0 0;color:#b2b2b2}.button.button-stable.button-outline.activated,.button.button-stable.button-outline.active{background-color:#b2b2b2;box-shadow:none;color:#fff}.button.button-positive{border-color:#0c63ee;background-color:#387ef5;color:#fff}.button.button-positive:hover{color:#fff;text-decoration:none}.button.button-positive.activated,.button.button-positive.active{border-color:#0c63ee;background-color:#0c63ee;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.button.button-positive.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#387ef5}.button.button-positive.button-icon{border-color:transparent;background:0 0}.button.button-positive.button-outline{border-color:#387ef5;background:0 0;color:#387ef5}.button.button-positive.button-outline.activated,.button.button-positive.button-outline.active{background-color:#387ef5;box-shadow:none;color:#fff}.button.button-calm{border-color:#0a9ec7;background-color:#11c1f3;color:#fff}.button.button-calm:hover{color:#fff;text-decoration:none}.button.button-calm.activated,.button.button-calm.active{border-color:#0a9ec7;background-color:#0a9ec7;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.button.button-calm.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#11c1f3}.button.button-calm.button-icon{border-color:transparent;background:0 0}.button.button-calm.button-outline{border-color:#11c1f3;background:0 0;color:#11c1f3}.button.button-calm.button-outline.activated,.button.button-calm.button-outline.active{background-color:#11c1f3;box-shadow:none;color:#fff}.button.button-assertive{border-color:#e42012;background-color:#ef473a;color:#fff}.button.button-assertive:hover{color:#fff;text-decoration:none}.button.button-assertive.activated,.button.button-assertive.active{border-color:#e42012;background-color:#e42012;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.button.button-assertive.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#ef473a}.button.button-assertive.button-icon{border-color:transparent;background:0 0}.button.button-assertive.button-outline{border-color:#ef473a;background:0 0;color:#ef473a}.button.button-assertive.button-outline.activated,.button.button-assertive.button-outline.active{background-color:#ef473a;box-shadow:none;color:#fff}.button.button-balanced{border-color:#28a54c;background-color:#33cd5f;color:#fff}.button.button-balanced:hover{color:#fff;text-decoration:none}.button.button-balanced.activated,.button.button-balanced.active{border-color:#28a54c;background-color:#28a54c;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.button.button-balanced.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#33cd5f}.button.button-balanced.button-icon{border-color:transparent;background:0 0}.button.button-balanced.button-outline{border-color:#33cd5f;background:0 0;color:#33cd5f}.button.button-balanced.button-outline.activated,.button.button-balanced.button-outline.active{background-color:#33cd5f;box-shadow:none;color:#fff}.button.button-energized{border-color:#e6b400;background-color:#ffc900;color:#fff}.button.button-energized:hover{color:#fff;text-decoration:none}.button.button-energized.activated,.button.button-energized.active{border-color:#e6b400;background-color:#e6b400;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.button.button-energized.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#ffc900}.button.button-energized.button-icon{border-color:transparent;background:0 0}.button.button-energized.button-outline{border-color:#ffc900;background:0 0;color:#ffc900}.button.button-energized.button-outline.activated,.button.button-energized.button-outline.active{background-color:#ffc900;box-shadow:none;color:#fff}.button.button-royal{border-color:#6b46e5;background-color:#886aea;color:#fff}.button.button-royal:hover{color:#fff;text-decoration:none}.button.button-royal.activated,.button.button-royal.active{border-color:#6b46e5;background-color:#6b46e5;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.button.button-royal.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#886aea}.button.button-royal.button-icon{border-color:transparent;background:0 0}.button.button-royal.button-outline{border-color:#886aea;background:0 0;color:#886aea}.button.button-royal.button-outline.activated,.button.button-royal.button-outline.active{background-color:#886aea;box-shadow:none;color:#fff}.button.button-dark{border-color:#111;background-color:#444;color:#fff}.button.button-dark:hover{color:#fff;text-decoration:none}.button.button-dark.activated,.button.button-dark.active{border-color:#000;background-color:#262626;box-shadow:inset 0 1px 4px rgba(0,0,0,.1)}.button.button-dark.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#444}.button.button-dark.button-icon{border-color:transparent;background:0 0}.button.button-dark.button-outline{border-color:#444;background:0 0;color:#444}.button.button-dark.button-outline.activated,.button.button-dark.button-outline.active{background-color:#444;box-shadow:none;color:#fff}.button-small{padding:2px 4px 1px;min-width:28px;min-height:30px;font-size:9pt;line-height:26px}.button-small .icon:before,.button-small.icon-left:before,.button-small.icon-right:before,.button-small.icon:before{font-size:1pc;line-height:19px;margin-top:3px}.button-large{padding:0 1pc;min-width:68px;min-height:59px;font-size:20px;line-height:53px}.button-large .icon:before,.button-large.icon-left:before,.button-large.icon-right:before,.button-large.icon:before{padding-bottom:2px;font-size:2pc;line-height:51px}.button-icon{-webkit-transition:opacity .1s;transition:opacity .1s;padding:0 6px;min-width:initial;border-color:transparent;background:0 0}.button-icon.button.activated,.button-icon.button.active{border-color:transparent;background:0 0;box-shadow:none;opacity:.3}.button-icon .icon:before,.button-icon.icon:before{font-size:2pc}.button-clear{-webkit-transition:opacity .1s;transition:opacity .1s;padding:0 6px;max-height:42px;border-color:transparent;background:0 0;box-shadow:none}.button-clear.button-clear{border-color:transparent;background:0 0;box-shadow:none;color:#b2b2b2}.button-clear.button-icon{border-color:transparent;background:0 0}.button-clear.activated,.button-clear.active{opacity:.3}.button-outline{-webkit-transition:opacity .1s;transition:opacity .1s;background:0 0;box-shadow:none}.button-outline.button-outline{border-color:#b2b2b2;background:0 0;color:#b2b2b2}.button-outline.button-outline.activated,.button-outline.button-outline.active{background-color:#b2b2b2;box-shadow:none;color:#fff}.padding>.button.button-block:first-child{margin-top:0}.button-block{display:block;clear:both}.button-block:after{clear:both}.button-full,.button-full>.button{display:block;margin-right:0;margin-left:0;border-right-width:0;border-left-width:0;border-radius:0}.button-full>button.button,button.button-block,button.button-full,input.button.button-block{width:100%}a.button{text-decoration:none}a.button .icon:before,a.button.icon-left:before,a.button.icon-right:before,a.button.icon:before{margin-top:2px}.button.disabled,.button[disabled]{opacity:.4;cursor:default!important;pointer-events:none}.button-bar{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;width:100%}.button-bar.button-bar-inline{display:block;width:auto}.button-bar.button-bar-inline:after,.button-bar.button-bar-inline:before{display:table;content:\"\";line-height:0}.button-bar.button-bar-inline:after{clear:both}.button-bar.button-bar-inline>.button{width:auto;display:inline-block;float:left}.button-bar>.button{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;display:block;overflow:hidden;padding:0 1pc;width:0;border-width:1px 0 1px 1px;border-radius:0;text-align:center;text-overflow:ellipsis;white-space:nowrap}.button-bar>.button .icon:before,.button-bar>.button:before{line-height:44px}.button-bar>.button:first-child{border-radius:2px 0 0 2px}.button-bar>.button:last-child{border-right-width:1px;border-radius:0 2px 2px 0}.button-bar>.button-small .icon:before,.button-bar>.button-small:before{line-height:28px}.row{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-moz-flex;display:-ms-flexbox;display:flex;padding:5px;width:100%}.row-wrap{-webkit-flex-wrap:wrap;-moz-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap}.row-no-padding{padding:0}.row-no-padding>.col{padding:0}.row+.row{margin-top:-5px;padding-top:0}.col{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;display:block;padding:5px;width:100%}.row-top{-webkit-box-align:start;-ms-flex-align:start;-webkit-align-items:flex-start;-moz-align-items:flex-start;align-items:flex-start}.row-bottom{-webkit-box-align:end;-ms-flex-align:end;-webkit-align-items:flex-end;-moz-align-items:flex-end;align-items:flex-end}.row-center{-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;-moz-align-items:center;align-items:center}.row-stretch{-webkit-box-align:stretch;-ms-flex-align:stretch;-webkit-align-items:stretch;-moz-align-items:stretch;align-items:stretch}.row-baseline{-webkit-box-align:baseline;-ms-flex-align:baseline;-webkit-align-items:baseline;-moz-align-items:baseline;align-items:baseline}.col-top{-webkit-align-self:flex-start;-moz-align-self:flex-start;-ms-flex-item-align:start;align-self:flex-start}.col-bottom{-webkit-align-self:flex-end;-moz-align-self:flex-end;-ms-flex-item-align:end;align-self:flex-end}.col-center{-webkit-align-self:center;-moz-align-self:center;-ms-flex-item-align:center;align-self:center}.col-offset-10{margin-left:10%}.col-offset-20{margin-left:20%}.col-offset-25{margin-left:25%}.col-offset-33,.col-offset-34{margin-left:33.3333%}.col-offset-50{margin-left:50%}.col-offset-66,.col-offset-67{margin-left:66.6666%}.col-offset-75{margin-left:75%}.col-offset-80{margin-left:80%}.col-offset-90{margin-left:90%}.col-10{-webkit-box-flex:0;-webkit-flex:0 0 10%;-moz-box-flex:0;-moz-flex:0 0 10%;-ms-flex:0 0 10%;flex:0 0 10%;max-width:10%}.col-20{-webkit-box-flex:0;-webkit-flex:0 0 20%;-moz-box-flex:0;-moz-flex:0 0 20%;-ms-flex:0 0 20%;flex:0 0 20%;max-width:20%}.col-25{-webkit-box-flex:0;-webkit-flex:0 0 25%;-moz-box-flex:0;-moz-flex:0 0 25%;-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.col-33,.col-34{-webkit-box-flex:0;-webkit-flex:0 0 33.3333%;-moz-box-flex:0;-moz-flex:0 0 33.3333%;-ms-flex:0 0 33.3333%;flex:0 0 33.3333%;max-width:33.3333%}.col-50{-webkit-box-flex:0;-webkit-flex:0 0 50%;-moz-box-flex:0;-moz-flex:0 0 50%;-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.col-66,.col-67{-webkit-box-flex:0;-webkit-flex:0 0 66.6666%;-moz-box-flex:0;-moz-flex:0 0 66.6666%;-ms-flex:0 0 66.6666%;flex:0 0 66.6666%;max-width:66.6666%}.col-75{-webkit-box-flex:0;-webkit-flex:0 0 75%;-moz-box-flex:0;-moz-flex:0 0 75%;-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.col-80{-webkit-box-flex:0;-webkit-flex:0 0 80%;-moz-box-flex:0;-moz-flex:0 0 80%;-ms-flex:0 0 80%;flex:0 0 80%;max-width:80%}.col-90{-webkit-box-flex:0;-webkit-flex:0 0 90%;-moz-box-flex:0;-moz-flex:0 0 90%;-ms-flex:0 0 90%;flex:0 0 90%;max-width:90%}@media (max-width:567px){.responsive-sm{-webkit-box-direction:normal;-moz-box-direction:normal;-webkit-box-orient:vertical;-moz-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.responsive-sm .col,.responsive-sm .col-10,.responsive-sm .col-20,.responsive-sm .col-25,.responsive-sm .col-33,.responsive-sm .col-34,.responsive-sm .col-50,.responsive-sm .col-66,.responsive-sm .col-67,.responsive-sm .col-75,.responsive-sm .col-80,.responsive-sm .col-90{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;margin-bottom:15px;margin-left:0;max-width:100%;width:100%}}@media (max-width:767px){.responsive-md{-webkit-box-direction:normal;-moz-box-direction:normal;-webkit-box-orient:vertical;-moz-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.responsive-md .col,.responsive-md .col-10,.responsive-md .col-20,.responsive-md .col-25,.responsive-md .col-33,.responsive-md .col-34,.responsive-md .col-50,.responsive-md .col-66,.responsive-md .col-67,.responsive-md .col-75,.responsive-md .col-80,.responsive-md .col-90{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;margin-bottom:15px;margin-left:0;max-width:100%;width:100%}}@media (max-width:1023px){.responsive-lg{-webkit-box-direction:normal;-moz-box-direction:normal;-webkit-box-orient:vertical;-moz-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.responsive-lg .col,.responsive-lg .col-10,.responsive-lg .col-20,.responsive-lg .col-25,.responsive-lg .col-33,.responsive-lg .col-34,.responsive-lg .col-50,.responsive-lg .col-66,.responsive-lg .col-67,.responsive-lg .col-75,.responsive-lg .col-80,.responsive-lg .col-90{-webkit-box-flex:1;-webkit-flex:1;-moz-box-flex:1;-moz-flex:1;-ms-flex:1;flex:1;margin-bottom:15px;margin-left:0;max-width:100%;width:100%}}.hide{display:none}.opacity-hide{opacity:0}.grade-b .opacity-hide,.grade-c .opacity-hide{opacity:1;display:none}.show{display:block}.opacity-show{opacity:1}.invisible{visibility:hidden}.keyboard-open .hide-on-keyboard-open{display:none}.keyboard-open .bar-footer.hide-on-keyboard-open+.pane .has-footer,.keyboard-open .tabs.hide-on-keyboard-open+.pane .has-tabs{bottom:0}.inline{display:inline-block}.disable-pointer-events{pointer-events:none}.enable-pointer-events{pointer-events:auto}.disable-user-behavior{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-touch-callout:none;-webkit-tap-highlight-color:transparent;-webkit-tap-highlight-color:transparent;-webkit-user-drag:none;-ms-touch-action:none;-ms-content-zooming:none}.click-block{position:absolute;top:0;right:0;bottom:0;left:0;opacity:0;z-index:99999;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);overflow:hidden}.click-block-hide{-webkit-transform:translate3d(-9999px,0,0);transform:translate3d(-9999px,0,0)}.no-resize{resize:none}.block{display:block;clear:both}.block:after{display:block;visibility:hidden;clear:both;height:0;content:\".\"}.full-image{width:100%}.clearfix:after,.clearfix:before{display:table;content:\"\";line-height:0}.clearfix:after{clear:both}.padding{padding:10px}.padding-top,.padding-vertical{padding-top:10px}.padding-horizontal,.padding-right{padding-right:10px}.padding-bottom,.padding-vertical{padding-bottom:10px}.padding-horizontal,.padding-left{padding-left:10px}.iframe-wrapper{position:fixed;-webkit-overflow-scrolling:touch;overflow:scroll}.iframe-wrapper iframe{height:100%;width:100%}.rounded{border-radius:4px}.light,a.light{color:#fff}.light-bg{background-color:#fff}.light-border{border-color:#ddd}.stable,a.stable{color:#f8f8f8}.stable-bg{background-color:#f8f8f8}.stable-border{border-color:#b2b2b2}.positive,a.positive{color:#387ef5}.positive-bg{background-color:#387ef5}.positive-border{border-color:#0c63ee}.calm,a.calm{color:#11c1f3}.calm-bg{background-color:#11c1f3}.calm-border{border-color:#0a9ec7}.assertive,a.assertive{color:#ef473a}.assertive-bg{background-color:#ef473a}.assertive-border{border-color:#e42012}.balanced,a.balanced{color:#33cd5f}.balanced-bg{background-color:#33cd5f}.balanced-border{border-color:#28a54c}.energized,a.energized{color:#ffc900}.energized-bg{background-color:#ffc900}.energized-border{border-color:#e6b400}.royal,a.royal{color:#886aea}.royal-bg{background-color:#886aea}.royal-border{border-color:#6b46e5}.dark,a.dark{color:#444}.dark-bg{background-color:#444}.dark-border{border-color:#111}[collection-repeat]{left:0!important;top:0!important;position:absolute!important;z-index:1}.collection-repeat-container{position:relative;z-index:1}.collection-repeat-after-container{z-index:0;display:block}.collection-repeat-after-container.horizontal{display:inline-block}.ng-cloak,.ng-hide:not(.ng-hide-animate),.x-ng-cloak,[data-ng-cloak],[ng-cloak],[ng\\:cloak],[x-ng-cloak]{display:none!important}.platform-ios.platform-cordova:not(.fullscreen) .bar-header:not(.bar-subheader){height:4pc}.platform-ios.platform-cordova:not(.fullscreen) .bar-header:not(.bar-subheader).item-input-inset .item-input-wrapper{margin-top:19px!important}.platform-ios.platform-cordova:not(.fullscreen) .bar-header:not(.bar-subheader)>*{margin-top:20px}.platform-ios.platform-cordova:not(.fullscreen) .tabs-top>.tabs,.platform-ios.platform-cordova:not(.fullscreen) .tabs.tabs-top{top:4pc}.platform-ios.platform-cordova:not(.fullscreen) .bar-subheader,.platform-ios.platform-cordova:not(.fullscreen) .has-header{top:4pc}.platform-ios.platform-cordova:not(.fullscreen) .has-subheader{top:81pt}.platform-ios.platform-cordova:not(.fullscreen) .has-header.has-tabs-top{top:113px}.platform-ios.platform-cordova:not(.fullscreen) .has-header.has-subheader.has-tabs-top{top:157px}.platform-ios.platform-cordova .popover .bar-header:not(.bar-subheader){height:44px}.platform-ios.platform-cordova .popover .bar-header:not(.bar-subheader).item-input-inset .item-input-wrapper{margin-top:-1px}.platform-ios.platform-cordova .popover .bar-header:not(.bar-subheader)>*{margin-top:0}.platform-ios.platform-cordova .popover .bar-subheader,.platform-ios.platform-cordova .popover .has-header{top:44px}.platform-ios.platform-cordova .popover .has-subheader{top:88px}.platform-ios.platform-cordova.status-bar-hide{margin-bottom:20px}@media (orientation:landscape){.platform-ios.platform-browser.platform-ipad{position:fixed}}.platform-c:not(.enable-transitions) *{-webkit-transition:none!important;transition:none!important}.slide-in-up{-webkit-transform:translate3d(0,100%,0);transform:translate3d(0,100%,0)}.slide-in-up.ng-enter,.slide-in-up>.ng-enter{-webkit-transition:all cubic-bezier(.1,.7,.1,1) .4s;transition:all cubic-bezier(.1,.7,.1,1) .4s}.slide-in-up.ng-enter-active,.slide-in-up>.ng-enter-active{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}.slide-in-up.ng-leave,.slide-in-up>.ng-leave{-webkit-transition:all ease-in-out 250ms;transition:all ease-in-out 250ms}@-webkit-keyframes scaleOut{from{-webkit-transform:scale(1);opacity:1}to{-webkit-transform:scale(.8);opacity:0}}@keyframes scaleOut{from{transform:scale(1);opacity:1}to{transform:scale(.8);opacity:0}}@-webkit-keyframes superScaleIn{from{-webkit-transform:scale(1.2);opacity:0}to{-webkit-transform:scale(1);opacity:1}}@keyframes superScaleIn{from{transform:scale(1.2);opacity:0}to{transform:scale(1);opacity:1}}[nav-view-transition=ios] [nav-view=entering],[nav-view-transition=ios] [nav-view=leaving]{-webkit-transition-duration:.5s;transition-duration:.5s;-webkit-transition-timing-function:cubic-bezier(.36,.66,.04,1);transition-timing-function:cubic-bezier(.36,.66,.04,1);-webkit-transition-property:opacity,-webkit-transform,box-shadow;transition-property:opacity,transform,box-shadow}[nav-view-transition=ios][nav-view-direction=forward],[nav-view-transition=ios][nav-view-direction=back]{background-color:#000}[nav-view-transition=ios] [nav-view=active],[nav-view-transition=ios][nav-view-direction=forward] [nav-view=entering],[nav-view-transition=ios][nav-view-direction=back] [nav-view=leaving]{z-index:3}[nav-view-transition=ios][nav-view-direction=forward] [nav-view=leaving],[nav-view-transition=ios][nav-view-direction=back] [nav-view=entering]{z-index:2}[nav-bar-transition=ios] .back-text,[nav-bar-transition=ios] .buttons,[nav-bar-transition=ios] .title{-webkit-transition-duration:.5s;transition-duration:.5s;-webkit-transition-timing-function:cubic-bezier(.36,.66,.04,1);transition-timing-function:cubic-bezier(.36,.66,.04,1);-webkit-transition-property:opacity,-webkit-transform;transition-property:opacity,transform}[nav-bar-transition=ios] [nav-bar=entering],[nav-bar-transition=ios] [nav-bar=active]{z-index:10}[nav-bar-transition=ios] [nav-bar=entering] .bar,[nav-bar-transition=ios] [nav-bar=active] .bar{background:0 0}[nav-bar-transition=ios] [nav-bar=cached]{display:block}[nav-bar-transition=ios] [nav-bar=cached] .header-item{display:none}[nav-view-transition=android] [nav-view=entering],[nav-view-transition=android] [nav-view=leaving]{-webkit-transition-duration:.2s;transition-duration:.2s;-webkit-transition-timing-function:cubic-bezier(.4,.6,.2,1);transition-timing-function:cubic-bezier(.4,.6,.2,1);-webkit-transition-property:-webkit-transform;transition-property:transform}[nav-view-transition=android] [nav-view=active],[nav-view-transition=android][nav-view-direction=forward] [nav-view=entering],[nav-view-transition=android][nav-view-direction=back] [nav-view=leaving]{z-index:3}[nav-view-transition=android][nav-view-direction=forward] [nav-view=leaving],[nav-view-transition=android][nav-view-direction=back] [nav-view=entering]{z-index:2}[nav-bar-transition=android] .buttons,[nav-bar-transition=android] .title{-webkit-transition-duration:.2s;transition-duration:.2s;-webkit-transition-timing-function:cubic-bezier(.4,.6,.2,1);transition-timing-function:cubic-bezier(.4,.6,.2,1);-webkit-transition-property:opacity;transition-property:opacity}[nav-bar-transition=android] [nav-bar=entering],[nav-bar-transition=android] [nav-bar=active]{z-index:10}[nav-bar-transition=android] [nav-bar=entering] .bar,[nav-bar-transition=android] [nav-bar=active] .bar{background:0 0}[nav-bar-transition=android] [nav-bar=cached]{display:block}[nav-bar-transition=android] [nav-bar=cached] .header-item{display:none}[nav-swipe=fast] .back-text,[nav-swipe=fast] .buttons,[nav-swipe=fast] .title,[nav-swipe=fast] [nav-view]{-webkit-transition-duration:50ms;transition-duration:50ms;-webkit-transition-timing-function:linear;transition-timing-function:linear}[nav-swipe=slow] .back-text,[nav-swipe=slow] .buttons,[nav-swipe=slow] .title,[nav-swipe=slow] [nav-view]{-webkit-transition-duration:160ms;transition-duration:160ms;-webkit-transition-timing-function:linear;transition-timing-function:linear}[nav-bar=cached],[nav-view=cached]{display:none}[nav-view=stage]{opacity:0;-webkit-transition-duration:0;transition-duration:0}[nav-bar=stage] .back-text,[nav-bar=stage] .buttons,[nav-bar=stage] .title{position:absolute;opacity:0;-webkit-transition-duration:0s;transition-duration:0s}");
(function() {
  var loader = System;
  if (typeof indexOf == 'undefined')
    indexOf = Array.prototype.indexOf;

  function readGlobalProperty(p, value) {
    var pParts = p.split('.');
    while (pParts.length)
      value = value[pParts.shift()];
    return value;
  }

  var ignoredGlobalProps = ['sessionStorage', 'localStorage', 'clipboardData', 'frames', 'external'];

  var hasOwnProperty = loader.global.hasOwnProperty;

  function iterateGlobals(callback) {
    if (Object.keys)
      Object.keys(loader.global).forEach(callback);
    else
      for (var g in loader.global) {
        if (!hasOwnProperty.call(loader.global, g))
          continue;
        callback(g);
      }
  }

  function forEachGlobal(callback) {
    iterateGlobals(function(globalName) {
      if (indexOf.call(ignoredGlobalProps, globalName) != -1)
        return;
      try {
        var value = loader.global[globalName];
      }
      catch(e) {
        ignoredGlobalProps.push(globalName);
      }
      callback(globalName, value);
    });
  }

  var moduleGlobals = {};

  var globalSnapshot;

  loader.set('@@global-helpers', loader.newModule({
    prepareGlobal: function(moduleName, deps) {
      // first, we add all the dependency modules to the global
      for (var i = 0; i < deps.length; i++) {
        var moduleGlobal = moduleGlobals[deps[i]];
        if (moduleGlobal)
          for (var m in moduleGlobal)
            loader.global[m] = moduleGlobal[m];
      }

      // now store a complete copy of the global object
      // in order to detect changes
      globalSnapshot = {};
      
      forEachGlobal(function(name, value) {
        globalSnapshot[name] = value;
      });
    },
    retrieveGlobal: function(moduleName, exportName, init) {
      var singleGlobal;
      var multipleExports;
      var exports = {};

      // run init
      if (init)
        singleGlobal = init.call(loader.global);

      // check for global changes, creating the globalObject for the module
      // if many globals, then a module object for those is created
      // if one global, then that is the module directly
      else if (exportName) {
        var firstPart = exportName.split('.')[0];
        singleGlobal = readGlobalProperty(exportName, loader.global);
        exports[firstPart] = loader.global[firstPart];
      }

      else {
        forEachGlobal(function(name, value) {
          if (globalSnapshot[name] === value)
            return;
          if (typeof value === 'undefined')
            return;
          exports[name] = value;
          if (typeof singleGlobal !== 'undefined') {
            if (!multipleExports && singleGlobal !== value)
              multipleExports = true;
          }
          else {
            singleGlobal = value;
          }
        });
      }

      moduleGlobals[moduleName] = exports;

      return multipleExports ? exports : singleGlobal;
    }
  }));
})();
});
//# sourceMappingURL=build.js.map